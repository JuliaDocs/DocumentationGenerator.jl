<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Problems and solvers · GeoStats.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GeoStats.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">User guide</span><ul><li class="current"><a class="toctext" href>Problems and solvers</a><ul class="internal"><li><a class="toctext" href="#Estimation-problem-1">Estimation problem</a></li><li><a class="toctext" href="#Simulation-problem-1">Simulation problem</a></li><li><a class="toctext" href="#List-of-solvers-1">List of solvers</a></li></ul></li><li><a class="toctext" href="../spatialdata/">Spatial data</a></li><li><a class="toctext" href="../domains/">Domains</a></li><li><span class="toctext">Variography</span><ul><li><a class="toctext" href="../empirical_variograms/">Empirical variograms</a></li><li><a class="toctext" href="../theoretical_variograms/">Theoretical variograms</a></li><li><a class="toctext" href="../fitting_variograms/">Fitting variograms</a></li></ul></li><li><a class="toctext" href="../estimators/">Kriging estimators</a></li><li><a class="toctext" href="../comparisons/">Solver comparisons</a></li><li><a class="toctext" href="../plotting/">Plotting</a></li></ul></li><li><a class="toctext" href="../tutorials/">Tutorials</a></li><li><a class="toctext" href="../contributing/">Contributing</a></li><li><span class="toctext">About</span><ul><li><a class="toctext" href="../about/community/">Community</a></li><li><a class="toctext" href="../about/license/">License</a></li><li><a class="toctext" href="../about/citing/">Citing</a></li></ul></li><li><a class="toctext" href="../developers/">Developer guide</a></li><li><a class="toctext" href="../links/">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li>User guide</li><li><a href>Problems and solvers</a></li></ul></nav><hr/><div id="topbar"><span>Problems and solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Problems-and-solvers-1" href="#Problems-and-solvers-1">Problems and solvers</a></h1><p>One of the greatest features of GeoStats.jl is the ability to define geostatistical problems independently of the solution strategy. This design allows researchers and practioners to perform <em>fair comparisons</em> between different solvers. It is perhaps the single most important contribution of this project.</p><p>If you are an experienced user of geostatistics or if you do research in the field, you know how hard it is to compare algorithms fairly. Often a new algorithm is proposed in the literature, and yet the task of comparing it with the state of the art is quite demanding. Even when a comparison is made by the author after a great amount of effort, it is inevitably biased.</p><p>Part of this issue is attributed to the fact that a general definition of the problem is missing. What is it that we call an &quot;estimation problem&quot; in geostatistics? What about &quot;stochastic simulation&quot;? The answer to these questions is given below in the form of code.</p><h2><a class="nav-anchor" id="Estimation-problem-1" href="#Estimation-problem-1">Estimation problem</a></h2><p>An estimation problem in geostatitsics is a triplet:</p><ol><li>Spatial data (i.e. data with coordinates)</li><li>Spatial domain (e.g. regular grid, point collection)</li><li>Target variables (or variables to be estimated)</li></ol><p>Each of these components is constructed separately, and then grouped (no memory is copied) in an <code>EstimationProblem</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeoStatsBase.EstimationProblem" href="#GeoStatsBase.EstimationProblem"><code>GeoStatsBase.EstimationProblem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">EstimationProblem(spatialdata, domain, targetvars)</code></pre><p>A spatial estimation problem on a given <code>domain</code> in which the variables to be estimated are listed in <code>targetvars</code>. The data of the problem is stored in <code>spatialdata</code>.</p><p><strong>Examples</strong></p><p>Create an estimation problem for rainfall precipitation measurements:</p><pre><code class="language-julia">julia&gt; EstimationProblem(spatialdata, domain, :precipitation)</code></pre><p>Create an estimation problem for precipitation and CO₂:</p><pre><code class="language-julia">julia&gt; EstimationProblem(spatialdata, domain, [:precipitation, :CO₂])</code></pre></div></div></section><p>Please check <a href="../spatialdata/">Spatial data</a> and <a href="../domains/">Domains</a> for currently implemented data and domain types.</p><h2><a class="nav-anchor" id="Simulation-problem-1" href="#Simulation-problem-1">Simulation problem</a></h2><p>Likewise, a stochastic simulation problem in geostatistics is represented with the same triplet. However, the spatial data in this case is optional in order to accomodate the concept of conditional versus unconditional simulation.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeoStatsBase.SimulationProblem" href="#GeoStatsBase.SimulationProblem"><code>GeoStatsBase.SimulationProblem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SimulationProblem(spatialdata, domain, targetvars, nreals)
SimulationProblem(domain, targetvars, nreals)</code></pre><p>A spatial simulation problem on a given <code>domain</code> in which the variables to be simulated are listed in <code>targetvars</code>.</p><p>For conditional simulation, the data of the problem is stored in <code>spatialdata</code>.</p><p>For unconditional simulation, a dictionary <code>targetvars</code> must be provided mapping variable names to their types.</p><p>In both cases, a number <code>nreals</code> of realizations is requested.</p><p><strong>Examples</strong></p><p>Create a conditional simulation problem for porosity and permeability with 100 realizations:</p><pre><code class="language-julia">julia&gt; SimulationProblem(spatialdata, domain, [:porosity,:permeability], 100)</code></pre><p>Create an unconditional simulation problem for porosity and facies type with 100 realizations:</p><pre><code class="language-julia">julia&gt; SimulationProblem(domain, Dict(:porosity =&gt; Float64, :facies =&gt; Int), 100)</code></pre><p><strong>Notes</strong></p><p>To check if a simulation problem has data (i.e. conditional vs. unconditional) use the <a href="#GeoStatsBase.hasdata"><code>hasdata</code></a> method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeoStatsBase.hasdata" href="#GeoStatsBase.hasdata"><code>GeoStatsBase.hasdata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hasdata(problem)</code></pre><p>Return <code>true</code> if simulation <code>problem</code> has data.</p></div></div></section><h2><a class="nav-anchor" id="List-of-solvers-1" href="#List-of-solvers-1">List of solvers</a></h2><p>Below is the list of solvers distributed with GeoStats.jl. For more solvers, please check the <a href="https://github.com/juliohm/GeoStats.jl#problems-and-solvers">project page on GitHub</a> where a table is provided with links to accompanying repositories.</p><h3><a class="nav-anchor" id="Estimation-1" href="#Estimation-1">Estimation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeoStats.Kriging" href="#GeoStats.Kriging"><code>GeoStats.Kriging</code></a> — <span class="docstring-category">Type</span>.</div><div><div><div><pre><code class="language-none">Kriging(var₁=&gt;param₁, var₂=&gt;param₂, ...)</code></pre><p>A polyalgorithm Kriging estimation solver.</p><p>Each pair <code>var=&gt;param</code> specifies the <code>KrigingParam</code> <code>param</code> for the Kriging variable <code>var</code>. In order to avoid boilerplate code, the constructor expects pairs of <code>Symbol</code> and <code>NamedTuple</code> instead.</p><p><strong>Parameters</strong></p><ul><li><code>variogram</code> - Variogram model (default to <code>GaussianVariogram()</code>)</li><li><code>mean</code>      - Simple Kriging mean</li><li><code>degree</code>    - Universal Kriging degree</li><li><code>drifts</code>    - External Drift Kriging drift functions</li></ul><p>Latter options override former options. For example, by specifying <code>drifts</code>, the user is telling the algorithm to ignore <code>degree</code> and <code>mean</code>. If no option is specified, Ordinary Kriging is used by default with the <code>variogram</code> only.</p><ul><li><code>maxneighbors</code> - Maximum number of neighbors (default to <code>nothing</code>)</li><li><code>neighborhood</code> - Search neighborhood (default to <code>nothing</code>)</li><li><code>metric</code>       - Metric used to find nearest neighbors (default to <code>Euclidean()</code>)</li></ul><p>The <code>maxneighbors</code> option can be used to perform approximate Kriging with a subset of data points per estimation location. Two neighborhood search methods are available depending on the value of <code>neighborhood</code>:</p><ul><li><p>If a <code>neighborhood</code> is provided, local Kriging is performed by sliding the <code>neighborhood</code> in the domain.</p></li><li><p>If <code>neighborhood</code> is not provided, the Kriging system is built using <code>maxneighbors</code> nearest neighbors according to a <code>metric</code>.</p></li></ul><p><strong>Examples</strong></p><p>Solve the variable <code>:var₁</code> with Simple Kriging by specifying the <code>mean</code>, and the variable <code>:var₂</code> with Universal Kriging by specifying the <code>degree</code> and the <code>variogram</code> model.</p><pre><code class="language-julia">julia&gt; Kriging(
  :var₁ =&gt; (mean=1.,),
  :var₂ =&gt; (degree=1, variogram=SphericalVariogram(range=20.))
)</code></pre><p>Solve all variables of the problem with the default parameters (i.e. Ordinary Kriging with unit Gaussian variogram):</p><pre><code class="language-julia">julia&gt; Kriging()</code></pre></div></div></div></section><h3><a class="nav-anchor" id="Simulation-1" href="#Simulation-1">Simulation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeoStats.SeqGaussSim" href="#GeoStats.SeqGaussSim"><code>GeoStats.SeqGaussSim</code></a> — <span class="docstring-category">Type</span>.</div><div><div><div><pre><code class="language-none">SeqGaussSim(var₁=&gt;param₁, var₂=&gt;param₂, ...)</code></pre><p>A polyalgorithm sequential Gaussian simulation solver.</p><p>Each pair <code>var=&gt;param</code> specifies the <code>SeqGaussSimParam</code> <code>param</code> for the simulation variable <code>var</code>. In order to avoid boilerplate code, the constructor expects pairs of <code>Symbol</code> and <code>NamedTuple</code> instead. See <a href="#GeoStats.Kriging"><code>Kriging</code></a> documentation for examples.</p><p><strong>Parameters</strong></p><ul><li><code>variogram</code> - Variogram model (default to <code>GaussianVariogram()</code>)</li><li><code>mean</code>      - Simple Kriging mean</li><li><code>degree</code>    - Universal Kriging degree</li><li><code>drifts</code>    - External Drift Kriging drift functions</li></ul><p>Latter options override former options. For example, by specifying <code>drifts</code>, the user is telling the algorithm to ignore <code>degree</code> and <code>mean</code>. If no option is specified, Ordinary Kriging is used by default with the <code>variogram</code> only.</p><ul><li><code>maxneighbors</code> - Maximum number of neighbors (default to 10)</li><li><code>neighborhood</code> - Search neighborhood (default to <code>nothing</code>)</li><li><code>metric</code>       - Metric used to find nearest neighbors (default to <code>Euclidean()</code>)</li><li><code>path</code>         - Simulation path (default to <code>RandomPath</code>)</li></ul><p>For each location in the simulation <code>path</code>, a maximum number of neighbors <code>maxneighbors</code> is used to fit a Gaussian distribution. The nearest neighbors are searched according to a <code>metric</code> or according to a <code>neighborhood</code> when the latter is provided.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeoStats.CookieCutter" href="#GeoStats.CookieCutter"><code>GeoStats.CookieCutter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CookieCutter(master, others)</code></pre><p>A cookie-cutter simulation solver.</p><p><strong>Parameters</strong></p><ul><li><code>master</code> - Master simulation solver (a.k.a. facies solver)</li><li><code>others</code> - A list of pairs mapping categories to solvers</li></ul><p><strong>Examples</strong></p><p>Simulate lithology facies with image quilting and fill property with direct Gaussian simulation:</p><pre><code class="language-julia">julia&gt; fsolver  = ImgQuilt(:facies =&gt; (TI=Strebelle, template=(30,30,1)))
julia&gt; psolver₀ = DirectGaussSim(:property =&gt; (variogram=SphericalVariogram(range=10.),))
julia&gt; psolver₁ = DirectGaussSim(:property =&gt; (variogram=SphericalVariogram(range=20.),))
julia&gt; solver   = CookieCutter(fsolver, [0 =&gt; psolver₀, 1 =&gt; psolver₁])</code></pre></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../spatialdata/"><span class="direction">Next</span><span class="title">Spatial data</span></a></footer></article></body></html>
