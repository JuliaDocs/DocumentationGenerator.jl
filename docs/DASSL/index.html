<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· DASSL.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DASSL.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Common-Interface-Example-1">Common Interface Example</a></li><li><a class="toctext" href="#Examples-1">Examples</a></li><li><a class="toctext" href="#Output-1">Output</a></li><li><a class="toctext" href="#Keyword-arguments-1">Keyword arguments</a></li><li><a class="toctext" href="#Iterator-version-1">Iterator version</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DASSL.jl-1" href="#DASSL.jl-1">DASSL.jl</a></h1><p><a href="https://travis-ci.org/JuliaDiffEq/DASSL.jl"><img src="https://travis-ci.org/JuliaDiffEq/DASSL.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://coveralls.io/r/pwl/DASSL.jl"><img src="https://img.shields.io/coveralls/pwl/DASSL.jl.svg" alt="Coverage Status"/></a></p><p>This is an implementation of DASSL algorithm for solving algebraic differential equations.  To inastall a stable version run</p><pre><code class="language-none">Pkg.add(&quot;DASSL&quot;)</code></pre><h2><a class="nav-anchor" id="Common-Interface-Example-1" href="#Common-Interface-Example-1">Common Interface Example</a></h2><p>This package is compatible with the JuliaDiffEq common solver interface which is documented in the <a href="http://docs.juliadiffeq.org/latest/">DifferentialEquations.jl documentation</a>. Following the <a href="http://docs.juliadiffeq.org/latest/tutorials/dae_example.html">DAE Tutorial</a>, one can use <code>dassl()</code> as follows:</p><pre><code class="language-julia">using DASSL
u0 = [1.0, 0, 0]
du0 = [-0.04, 0.04, 0.0]
tspan = (0.0,100000.0)

function resrob(r,yp,y,p,t)
    r[1]  = -0.04*y[1] + 1.0e4*y[2]*y[3]
    r[2]  = -r[1] - 3.0e7*y[2]*y[2] - yp[2]
    r[1] -=  yp[1]
    r[3]  =  y[1] + y[2] + y[3] - 1.0
end

prob = DAEProblem(resrob,u0,du0,tspan)    
sol = solve(prob, dassl())</code></pre><p>For more details on using this interface, <a href="http://docs.juliadiffeq.org/latest/tutorials/ode_example.html">see the ODE tutorial</a>.</p><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><p>To solve a scalar equation <code>y&#39;(t)+y(t)=0</code> with initial data <code>y(0)=0.0</code> up to time <code>t=10.0</code> run the following code</p><pre><code class="language-none">using DASSL
F(t,y,dy) = dy+y                   # the equation solved is F(t,y,dy)=0
y0        = 1.0                    # the initial value
tspan     = [0.0,10.0]             # time span over which we integrate
(tn,yn)   = dasslSolve(F,y0,tspan) # returns (tn,yn)</code></pre><p>You can also change the relative error tolerance <code>rtol</code>, absolute error tolerance <code>atol</code> as well as initial step size <code>h0</code> as follows</p><pre><code class="language-none">(tn,yn)   = dasslSolve(F,y0,tspan)</code></pre><p>To test the convergence and execution time for index-1 problem run <code>convergence.jl</code> from the <code>test</code> directory.</p><p>Naturally, DASSL.jl also supports multiple equations.  For example the pendulum equation</p><pre><code class="language-none">u&#39;-v=0
v&#39;+sin(u)=0</code></pre><p>with initial data <code>u(0)=0.0</code> and <code>v(0)=1.0</code> can be solved by defining the following residual function</p><pre><code class="language-none">function F(t,y,dy)
       [
       dy[1]-y[2],           #  y[1]=u,   y[2]=v
       dy[2]+sin(y[1])       # dy[1]=u&#39;, dy[2]=v&#39;
       ]
end</code></pre><p>The initial data shoud now be set as a vector</p><pre><code class="language-none">y0      = [0.0,1.0]           # y0=[u(0),v(0)]</code></pre><p>The solution can be computed by calling</p><pre><code class="language-none">tspan   = [0.0,10.0]
(tn,yn) = dasslSolve(F,y0,tspan)</code></pre><h2><a class="nav-anchor" id="Output-1" href="#Output-1">Output</a></h2><p>Apart from producing the times <code>tn</code> and values <code>yn</code>, dasslSolve also produces the derivatives <code>dyn</code> (as the byproduct of BDF algorithm), e.g.</p><pre><code class="language-none">(tn,yn,dyn) = dasslSolve(F,y0,tspan)</code></pre><p>The decision to produce these values is that it is not entirely trivial to compute <code>y&#39;</code> from <code>F(t,y,y&#39;)=0</code> when <code>t</code> and <code>y</code> are given.</p><h2><a class="nav-anchor" id="Keyword-arguments-1" href="#Keyword-arguments-1">Keyword arguments</a></h2><p>DASSL supports a number of keyword arguments, the names of most of them are compatible with the namse used in ODE package.</p><ul><li><p><code>reltol=1e-3</code>/<code>abstol=1e-5</code> set the relative/absolute local error tolerances</p></li><li><p><code>initstep=1e-4</code>/<code>minstep=0</code>/<code>maxstep=Inf</code> set the initial/minimal/maximal step sizes (when step size drops below minimum the integration stops)</p></li><li><p><code>jacobian</code> The most expensive step during the integration is solving the nonlinear equation <code>F(t,y,a*y+b)=0</code> via Newton&#39;s method, which requires a jacobian of the form <code>dF/dy+a*dF/dy&#39;</code>.  By default, the solver approximates this Jacobian by a method of finite differences but you can provide your own method as a function <code>(t,y,dy,a)-&gt;dF/dy+a*dF/dy&#39;</code>.  For the pendulum equation we would define jacobian as</p><pre><code class="language-none">jacobian=(t,y,dy,a)-&gt;[[a,cos(y[1])] [-1,a]]</code></pre></li><li><p><code>maxorder=6</code> Apart from selecting the current step size DASSL method can also dynamically change the order of BDF method used.  BDF is stable up to 6-th order, which is the defaul upper limit but for some systems of equations it may make more sense to use lower orders.</p></li><li><p><code>dy0=zero(y)</code> When solving differential algebraic equations it is important to start with consistent initial conditions, i.e. to choose <code>y</code> and <code>y&#39;</code> such that <code>F(t,y,y&#39;)=0</code> initially.  DASSL tries to guess the initial value of <code>y&#39;</code>, but if it fails you can set your own initial condtions for the derivative.</p></li><li><p><code>norm=dassl_norm</code>/<code>weights=dassl_weights</code> DASSL computes the error roughly as <code>err=norm(yc-y0)</code>, and accepting the step when <code>err&lt;1</code>.  The local error tolerances <code>reltol</code> and <code>abstol</code> are hidden in the definition of <code>dassl_norm(v, wt)=norm(v./wt)/sqrt(length(v))</code>, where weights <code>wt</code> are defined by <code>dassl_weights(y,reltol,abstol)=reltol*abs(y).+abstol</code>.  You can supply your own weights and norms when they are more appropriate for the problem at hand.</p></li><li><p><code>factorize_jacobian=true</code> is a Boolean option which forces the factorization of Jacobian before storing it.  It dramatically increases performance for large systems, but may decrease the computation speed for small systems.</p></li></ul><h2><a class="nav-anchor" id="Iterator-version-1" href="#Iterator-version-1">Iterator version</a></h2><p>DASSL.jl supports an iterative version of solver (implemented via coroutines, so debugging might be a little tricky) via <code>dasslIterator</code>.  In the following example the <code>dasslIterator</code> is used to stop the integration when the solution <code>y</code> drops below <code>0.1</code></p><pre><code class="language-none">F(t,y,dy)=dy+y

# iterator version of dassl solver
for (t,y,dy) in dasslIterator(F,1.0,0.0)
    if y &lt; 0.1
        @show (t,y,dy)
        break
    end
end</code></pre><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
