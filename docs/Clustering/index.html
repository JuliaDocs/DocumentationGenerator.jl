<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Clustering.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Clustering.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.Hclust" href="#Clustering.Hclust"><code>Clustering.Hclust</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Hierarchical clustering of the data returned by <code>hclust()</code>. The data hierarchy is defined by the <code>merges</code> matrix:</p><ul><li>each row specifies which subtrees (referenced by their IDs) are merged into a higher-level subtree</li><li>negative subtree <code>id</code> denotes leaf node and corresponds to the datapoint at position <code>-id</code></li><li>positive <code>id</code> denotes nontrivial subtree: the row <code>merges[id, :]</code> specifies its left and right subtrees, and <code>heights[id]</code> – its height.</li></ul><p>This type mostly follows R&#39;s <code>hclust</code> class.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.MCLResult" href="#Clustering.MCLResult"><code>Clustering.MCLResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct MCLResult &lt;: ClusteringResult</code></pre><p>Result returned by <code>mcl()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.dbscan-Tuple{AbstractArray{T,2} where T,Real}" href="#Clustering.dbscan-Tuple{AbstractArray{T,2} where T,Real}"><code>Clustering.dbscan</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dbscan(points, radius ; leafsize = 20, min_neighbors = 1, min_cluster_size = 1) -&gt; clusters</code></pre><p>Cluster points using the DBSCAN (density-based spatial clustering of applications with noise) algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>points</code>: matrix of points</li><li><code>radius::Real</code>: query radius</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>leafsize::Int</code>: number of points binned in each leaf node in the <code>KDTree</code></li><li><code>min_neighbors::Int</code>: minimum number of neighbors to be a core point</li><li><code>min_cluster_size::Int</code>: minimum number of points to be a valid cluster</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{DbscanCluster}</code>: an array of clusters with the id, size core indices and boundary indices</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">points = randn(3, 10000)
clusters = dbscan(points, 0.05, min_neighbors = 3, min_cluster_size = 20) # clusters with less than 20 points will be discarded</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.mcl-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real" href="#Clustering.mcl-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real"><code>Clustering.mcl</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mcl(adj::Matrix; [keyword arguments])::MCLResult</code></pre><p>Identify clusters in the weighted graph using Markov Clustering Algorithm (MCL).</p><p><strong>Arguments</strong></p><ul><li><code>adj::Matrix{Float64}</code>: adjacency matrix that defines the weighted graph to cluster</li><li><code>add_loops::Bool</code>: whether edges of weight 1.0 from the node to itself should be appended to the graph (enabled by default)</li><li><code>expansion::Number</code>: MCL expansion constant (2)</li><li><code>inflation::Number</code>: MCL inflation constant (2.0)</li><li><code>save_final_matrix::Bool</code>: save final equilibrium state in the result, otherwise leave it empty; disabled by default, could be useful if MCL doesn&#39;t converge</li><li><code>max_iter::Integer</code>: max number of MCL iterations</li><li><code>tol::Number</code>: MCL adjacency matrix convergence threshold</li><li><code>prune_tol::Number</code>: pruning threshold</li><li><code>display::Symbol</code>: <code>:none</code> for no output or <code>:verbose</code> for diagnostic messages</li></ul><p>See <a href="http://micans.org/mcl">original MCL implementation</a>.</p><p>Ref: Stijn van Dongen, &quot;Graph clustering by flow simulation&quot;, 2001</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.silhouettes-Union{Tuple{T}, Tuple{AbstractArray{#s808,1} where #s808&lt;:Integer,AbstractArray{#s807,1} where #s807&lt;:Integer,AbstractArray{T,2}}} where T&lt;:Real" href="#Clustering.silhouettes-Union{Tuple{T}, Tuple{AbstractArray{#s808,1} where #s808&lt;:Integer,AbstractArray{#s807,1} where #s807&lt;:Integer,AbstractArray{T,2}}} where T&lt;:Real"><code>Clustering.silhouettes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">silhouettes(assignments::AbstractVector, [counts,] dists)
silhouettes(clustering::ClusteringResult, dists)</code></pre><p>Compute silhouette values for individual points w.r.t. given clustering.</p><ul><li><code>assignments</code> the vector of point assignments (cluster indices)</li><li><code>counts</code> the optional vector of cluster sizes (how many points assigned to each cluster; should match <code>assignments</code>)</li><li><code>clustering</code> the output of some clustering method</li><li><code>dists</code> point×point pairwise distance matrix</li></ul><p>Returns a vector of silhouette values for each individual point.</p><p><code>mean(silhouettes(...))</code> could be used as a measure of clustering quality; higher values indicate better separation of clusters w.r.t. distances provided in <code>dists</code>.</p><p><strong>References</strong></p><ol><li><a href="http://en.wikipedia.org/wiki/Silhouette_(clustering)">Silhouette Wikipedia page</a>.</li><li>Peter J. Rousseeuw (1987). &quot;Silhouettes: a Graphical Aid to the Interpretation and Validation of Cluster Analysis&quot;. Computational and Applied Mathematics. 20: 53–65.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.vmeasure-Tuple{Union{ClusteringResult, AbstractArray{#s809,1} where #s809&lt;:Integer},Union{ClusteringResult, AbstractArray{#s808,1} where #s808&lt;:Integer}}" href="#Clustering.vmeasure-Tuple{Union{ClusteringResult, AbstractArray{#s809,1} where #s809&lt;:Integer},Union{ClusteringResult, AbstractArray{#s808,1} where #s808&lt;:Integer}}"><code>Clustering.vmeasure</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">vmeasure(assign1, assign2; β = 1.0)</code></pre><p>V-measure between two clustering assignments.</p><p><code>assign1</code> and <code>assign2</code> can be either <code>ClusteringResult</code> objects or assignments vectors (<code>AbstractVector{&lt;:Integer}</code>).</p><p>The <code>β</code> parameter defines trade-off between <em>homogeneity</em> and <em>completeness</em>:</p><ul><li>if <code>β</code> is greater than 1, <em>completeness</em> is weighted more strongly,</li><li>if <code>β</code> is less than 1, <em>homogeneity</em> is weighted more strongly.</li></ul><p><em>Ref:</em> Andrew Rosenberg and Julia Hirschberg, 2007. &quot;V-Measure: A conditional entropy-based external cluster evaluation measure&quot;</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.AverageDistance" href="#Clustering.AverageDistance"><code>Clustering.AverageDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Average distance between a pair of points from each clusters.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.MaximumDistance" href="#Clustering.MaximumDistance"><code>Clustering.MaximumDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Maximum distance between a pair of point from each clusters.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.MinimalDistance" href="#Clustering.MinimalDistance"><code>Clustering.MinimalDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Distance between the clusters is the minimal distance between any pair of their points.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.ReducibleMetric" href="#Clustering.ReducibleMetric"><code>Clustering.ReducibleMetric</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base type for <em>reducible</em> Lance–Williams cluster metrics.</p><p>The metric <code>d</code> is called <em>reducible</em> if for any clusters <code>A</code>, <code>B</code> and <code>C</code> and some <code>ρ &gt; 0</code> s.t.</p><pre><code class="language-none">d(A, B) &lt; ρ, d(A, C) &gt; ρ, d(B, C) &gt; ρ</code></pre><p>it follows that</p><pre><code class="language-none">d(A∪B, C) &gt; ρ</code></pre><p>If the cluster metrics belongs to Lance-Williams family, there is an efficient formula that defines <code>d(A∪B, C)</code> using <code>d(A, C)</code>, <code>d(B, C)</code> and <code>d(A, B)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.WardDistance" href="#Clustering.WardDistance"><code>Clustering.WardDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Ward distance between the two clusters <code>A</code> and <code>B</code> is the amount by which merging the two clusters into a single larger cluster <code>A∪B</code> would increase the average squared distance of a point to its cluster centroid.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering._dbscan-Tuple{NearestNeighbors.KDTree,AbstractArray{T,2} where T,Real}" href="#Clustering._dbscan-Tuple{NearestNeighbors.KDTree,AbstractArray{T,2} where T,Real}"><code>Clustering._dbscan</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>An implementation of DBSCAN algorithm that keeps track of both the core and boundary points </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.accept_cluster!-Tuple{Array{DbscanCluster,1},BitArray{1},BitArray{1},Int64}" href="#Clustering.accept_cluster!-Tuple{Array{DbscanCluster,1},BitArray{1},BitArray{1},Int64}"><code>Clustering.accept_cluster!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">accept_cluster!(clusters, core_selection, cluster_selection)</code></pre><p>Accept cluster and update the clusters list</p><p><strong>Input</strong></p><ul><li><code>clusters :: Vector{DbscanCluster}</code>: a list of the accepted clusters</li><li><code>core_selection :: Vector{Bool}</code>: selection of the core points of the cluster</li><li><code>cluster_selection :: Vector{Bool}</code>: selection of all the cluster points</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.update_exploration_list!-Union{Tuple{T}, Tuple{Array{T,N} where N,Array{T,1},BitArray{1}}} where T&lt;:Int64" href="#Clustering.update_exploration_list!-Union{Tuple{T}, Tuple{Array{T,N} where N,Array{T,1},BitArray{1}}} where T&lt;:Int64"><code>Clustering.update_exploration_list!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">update_exploration_list!(adj_list, exploration_list, visited)</code></pre><p>Update the queue for expanding the cluster</p><p><strong>Input</strong></p><ul><li><code>adj_list :: Vector{Int}</code>: indices of the neighboring points</li><li><code>exploration_list :: Vector{Int}</code>: the indices that  will be explored in the future</li><li><code>visited :: Vector{Bool}</code>: a flag to indicate whether a point has been explored already</li></ul></div></div></section><footer><hr/></footer></article></body></html>
