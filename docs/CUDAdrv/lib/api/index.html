<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API wrappers · CUDAdrv.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CUDAdrv.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/usage/">Usage</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href>API wrappers</a><ul class="internal"><li><a class="toctext" href="#Installation-properties-1">Installation properties</a></li><li><a class="toctext" href="#Initialization-1">Initialization</a></li><li><a class="toctext" href="#Error-Handling-1">Error Handling</a></li><li><a class="toctext" href="#Version-Management-1">Version Management</a></li><li><a class="toctext" href="#Device-Management-1">Device Management</a></li><li><a class="toctext" href="#Context-Management-1">Context Management</a></li><li><a class="toctext" href="#Module-Management-1">Module Management</a></li><li><a class="toctext" href="#Memory-Management-1">Memory Management</a></li><li><a class="toctext" href="#Stream-Management-1">Stream Management</a></li><li><a class="toctext" href="#Event-Management-1">Event Management</a></li><li><a class="toctext" href="#Execution-Control-1">Execution Control</a></li><li><a class="toctext" href="#Profiler-Control-1">Profiler Control</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>API wrappers</a></li></ul></nav><hr/><div id="topbar"><span>API wrappers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-wrappers-1" href="#API-wrappers-1">API wrappers</a></h1><p>This section lists the package&#39;s public functionality that directly corresponds to functionality of the CUDA driver API. In general, the abstractions stay close to those of the CUDA driver API, so for more information on certain library calls you can consult the <a href="http://docs.nvidia.com/cuda/cuda-driver-api/">CUDA driver API reference</a>.</p><p>The documentation is grouped according to the modules of the driver API.</p><h2><a class="nav-anchor" id="Installation-properties-1" href="#Installation-properties-1">Installation properties</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.vendor" href="#CUDAdrv.vendor"><code>CUDAdrv.vendor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns a string identifying the vendor of your CUDA driver.</p></div></div></section><h2><a class="nav-anchor" id="Initialization-1" href="#Initialization-1">Initialization</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.init" href="#CUDAdrv.init"><code>CUDAdrv.init</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Initialize the CUDA driver API.</p><p>This function is automatically called upon loading the package. You should not have to call this manually.</p></div></div></section><h2><a class="nav-anchor" id="Error-Handling-1" href="#Error-Handling-1">Error Handling</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuError" href="#CUDAdrv.CuError"><code>CUDAdrv.CuError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CuError(code::Integer)
CuError(code::Integer, info::String)</code></pre><p>Create a CUDA error object with error code <code>code</code>. The optional <code>info</code> parameter indicates whether extra information, such as error logs, is known.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.name-Tuple{CuError}" href="#CUDAdrv.name-Tuple{CuError}"><code>CUDAdrv.name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">name(err::CuError)</code></pre><p>Gets the string representation of an error code.</p><p>This name can often be used as a symbol in source code to get an instance of this error. For example:</p><pre><code class="language-julia-repl">julia&gt; using CUDAdrv

julia&gt; err = CuError(1)
CuError(1, ERROR_INVALID_VALUE)

julia&gt; name(err)
&quot;ERROR_INVALID_VALUE&quot;

julia&gt; CUDAdrv.ERROR_INVALID_VALUE
CuError(1, ERROR_INVALID_VALUE)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.description-Tuple{CuError}" href="#CUDAdrv.description-Tuple{CuError}"><code>CUDAdrv.description</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">description(err::CuError)</code></pre><p>Gets the string description of an error code.</p></div></div></section><h2><a class="nav-anchor" id="Version-Management-1" href="#Version-Management-1">Version Management</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.version-Tuple{}" href="#CUDAdrv.version-Tuple{}"><code>CUDAdrv.version</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">version()</code></pre><p>Returns the CUDA version as reported by the driver.</p></div></div></section><h2><a class="nav-anchor" id="Device-Management-1" href="#Device-Management-1">Device Management</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuDevice" href="#CUDAdrv.CuDevice"><code>CUDAdrv.CuDevice</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CuDevice(i::Integer)</code></pre><p>Get a handle to a compute device.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.devices" href="#CUDAdrv.devices"><code>CUDAdrv.devices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">devices()</code></pre><p>Get an iterator for the compute devices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.name-Tuple{CuDevice}" href="#CUDAdrv.name-Tuple{CuDevice}"><code>CUDAdrv.name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">name(dev::CuDevice)</code></pre><p>Returns an identifier string for the device.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.totalmem-Tuple{CuDevice}" href="#CUDAdrv.totalmem-Tuple{CuDevice}"><code>CUDAdrv.totalmem</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">totalmem(dev::CuDevice)</code></pre><p>Returns the total amount of memory (in bytes) on the device.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.attribute" href="#CUDAdrv.attribute"><code>CUDAdrv.attribute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">attribute(dev::CuDevice, code)</code></pre><p>Returns information about the device.</p></div></div></section><p>Certain common attributes are exposed by additional convenience functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.capability-Tuple{CuDevice}" href="#CUDAdrv.capability-Tuple{CuDevice}"><code>CUDAdrv.capability</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">capability(dev::CuDevice)</code></pre><p>Returns the compute capability of the device.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.warpsize-Tuple{CuDevice}" href="#CUDAdrv.warpsize-Tuple{CuDevice}"><code>CUDAdrv.warpsize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">warpsize(dev::CuDevice)</code></pre><p>Returns the warp size (in threads) of the device.</p></div></div></section><h2><a class="nav-anchor" id="Context-Management-1" href="#Context-Management-1">Context Management</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuContext" href="#CUDAdrv.CuContext"><code>CUDAdrv.CuContext</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CuContext(dev::CuDevice, flags::CUctx_flags=SCHED_AUTO)
CuContext(f::Function, ...)</code></pre><p>Create a CUDA context for device. A context on the GPU is analogous to a process on the CPU, with its own distinct address space and allocated resources. When a context is destroyed, the system cleans up the resources allocated to it.</p><p>Contexts are unique instances which need to be <code>destroy</code>ed after use. For automatic management, prefer the <code>do</code> block syntax, which implicitly calls <code>destroy</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.destroy!-Tuple{CuContext}" href="#CUDAdrv.destroy!-Tuple{CuContext}"><code>CUDAdrv.destroy!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">destroy!(ctx::CuContext)</code></pre><p>Mark a context for destruction.</p><p>This does not immediately destroy the context, as there might still be dependent resources which have not been collected yet. The context will get freed as soon as all outstanding instances have been finalized.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuCurrentContext" href="#CUDAdrv.CuCurrentContext"><code>CUDAdrv.CuCurrentContext</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CuCurrentContext()</code></pre><p>Return the current context, or <code>nothing</code> if there is no active context.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.activate-Tuple{CuContext}" href="#CUDAdrv.activate-Tuple{CuContext}"><code>CUDAdrv.activate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">activate(ctx::CuContext)</code></pre><p>Binds the specified CUDA context to the calling CPU thread.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.synchronize-Tuple{CuContext}" href="#CUDAdrv.synchronize-Tuple{CuContext}"><code>CUDAdrv.synchronize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">synchronize(ctx::CuContext=CuCurrentContext())</code></pre><p>Block for a context&#39;s tasks to complete.</p><p>The <code>ctx</code> parameter defaults to the current active context.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.device-Tuple{CuContext}" href="#CUDAdrv.device-Tuple{CuContext}"><code>CUDAdrv.device</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">device()
device(ctx::Cucontext)</code></pre><p>Returns the device for the current context. The optional <code>ctx</code> parameter is to make sure that the current context is really active, and hence the returned device is valid.</p></div></div></section><h3><a class="nav-anchor" id="Primary-Context-Management-1" href="#Primary-Context-Management-1">Primary Context Management</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuPrimaryContext" href="#CUDAdrv.CuPrimaryContext"><code>CUDAdrv.CuPrimaryContext</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CuPrimaryContext(dev::CuDevice)</code></pre><p>Create a primary CUDA context for a given device.</p><p>Each primary context is unique per device and is shared with CUDA runtime API. It is meant for interoperability with (applications using) the runtime API.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuContext-Tuple{CuPrimaryContext}" href="#CUDAdrv.CuContext-Tuple{CuPrimaryContext}"><code>CUDAdrv.CuContext</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">CuContext(pctx::CuPrimaryContext)
CuContext(f::Function, pctx::CuPrimaryContext)</code></pre><p>Retain the primary context on the GPU, returning a context compatible with the driver API. The primary context will be released when the returned driver context is finalized. For that reason, it is advised to use this function with <code>do</code> block syntax.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.isactive-Tuple{CuPrimaryContext}" href="#CUDAdrv.isactive-Tuple{CuPrimaryContext}"><code>CUDAdrv.isactive</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isactive(pctx::CuPrimaryContext)</code></pre><p>Query whether a primary context is active.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.flags-Tuple{CuPrimaryContext}" href="#CUDAdrv.flags-Tuple{CuPrimaryContext}"><code>CUDAdrv.flags</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">flags(pctx::CuPrimaryContext)</code></pre><p>Query the flags of a primary context.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.setflags!-Tuple{CuPrimaryContext,CUDAdrv.CUctx_flags}" href="#CUDAdrv.setflags!-Tuple{CuPrimaryContext,CUDAdrv.CUctx_flags}"><code>CUDAdrv.setflags!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setflags!(pctx::CuPrimaryContext)</code></pre><p>Set the flags of a primary context.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.unsafe_reset!-Tuple{CuPrimaryContext,Bool}" href="#CUDAdrv.unsafe_reset!-Tuple{CuPrimaryContext,Bool}"><code>CUDAdrv.unsafe_reset!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_reset!(pctx::CuPrimaryContext, [checked::Bool=true])</code></pre><p>Explicitly destroys and cleans up all resources associated with a device&#39;s primary context in the current process. Note that this forcibly invalidates all contexts derived from this primary context, and as a result outstanding resources might become invalid.</p><p>It is normally unnecessary to call this function, as resource are automatically freed when contexts go out of scope. In the case of primary contexts, they are collected when all contexts derived from that primary context have gone out of scope.</p><p>The <code>checked</code> argument determines whether to verify that the primary context has become inactive after resetting the derived driver contexts. This may not be possible, eg. if the CUDA runtime API itself has retained an additional context instance.</p></div></div></section><h2><a class="nav-anchor" id="Module-Management-1" href="#Module-Management-1">Module Management</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuModule" href="#CUDAdrv.CuModule"><code>CUDAdrv.CuModule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CuModule(data, options::Dict{CUjit_option,Any})
CuModuleFile(path, options::Dict{CUjit_option,Any})</code></pre><p>Create a CUDA module from a data, or a file containing data. The data may be PTX code, a CUBIN, or a FATBIN.</p><p>The <code>options</code> is an optional dictionary of JIT options and their respective value.</p></div></div></section><h3><a class="nav-anchor" id="Function-Management-1" href="#Function-Management-1">Function Management</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuFunction" href="#CUDAdrv.CuFunction"><code>CUDAdrv.CuFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CuFunction(mod::CuModule, name::String)</code></pre><p>Acquires a function handle from a named function in a module.</p></div></div></section><h3><a class="nav-anchor" id="Global-Variable-Management-1" href="#Global-Variable-Management-1">Global Variable Management</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuGlobal" href="#CUDAdrv.CuGlobal"><code>CUDAdrv.CuGlobal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CuGlobal{T}(mod::CuModule, name::String)</code></pre><p>Acquires a typed global variable handle from a named global in a module.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eltype-Tuple{CuGlobal}" href="#Base.eltype-Tuple{CuGlobal}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">eltype(var::CuGlobal)</code></pre><p>Return the element type of a global variable object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.get-Tuple{CuGlobal}" href="#Base.get-Tuple{CuGlobal}"><code>Base.get</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get(var::CuGlobal)</code></pre><p>Return the current value of a global variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.set-Union{Tuple{T}, Tuple{CuGlobal{T},T}} where T" href="#CUDAdrv.set-Union{Tuple{T}, Tuple{CuGlobal{T},T}} where T"><code>CUDAdrv.set</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set(var::CuGlobal{T}, T)</code></pre><p>Set the value of a global variable to <code>val</code></p></div></div></section><h3><a class="nav-anchor" id="Linker-1" href="#Linker-1">Linker</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuLink" href="#CUDAdrv.CuLink"><code>CUDAdrv.CuLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CuLink()</code></pre><p>Creates a pending JIT linker invocation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.add_data!" href="#CUDAdrv.add_data!"><code>CUDAdrv.add_data!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_data!(link::CuLink, name::String, code::String)</code></pre><p>Add PTX code to a pending link operation.</p></div></div><div><div><pre><code class="language-none">add_data!(link::CuLink, name::String, data::Vector{UInt8}, type::CUjit_input)</code></pre><p>Add object code to a pending link operation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.add_file!" href="#CUDAdrv.add_file!"><code>CUDAdrv.add_file!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_file!(link::CuLink, path::String, typ::CUjit_input)</code></pre><p>Add data from a file to a link operation. The argument <code>typ</code> indicates the type of the contained data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuLinkImage" href="#CUDAdrv.CuLinkImage"><code>CUDAdrv.CuLinkImage</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The result of a linking operation.</p><p>This object keeps its parent linker object alive, as destroying a linker destroys linked images too.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.complete" href="#CUDAdrv.complete"><code>CUDAdrv.complete</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">complete(link::CuLink)</code></pre><p>Complete a pending linker invocation, returning an output image.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuModule-Tuple{CUDAdrv.CuLinkImage,Vararg{Any,N} where N}" href="#CUDAdrv.CuModule-Tuple{CUDAdrv.CuLinkImage,Vararg{Any,N} where N}"><code>CUDAdrv.CuModule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">CuModule(img::CuLinkImage, ...)
CuModule(f::Function, img::CuLinkImage, ...)</code></pre><p>Create a CUDA module from a completed linking operation. Options from <code>CuModule</code> apply.</p></div></div></section><h2><a class="nav-anchor" id="Memory-Management-1" href="#Memory-Management-1">Memory Management</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.alloc" href="#CUDAdrv.Mem.alloc"><code>CUDAdrv.Mem.alloc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Allocate linear memory on the device and return a buffer to the allocated memory. The allocated memory is suitably aligned for any kind of variable. The memory will not be freed automatically, use <a href="#CUDAdrv.Mem.free"><code>free(::Buffer)</code></a> for that.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.free" href="#CUDAdrv.Mem.free"><code>CUDAdrv.Mem.free</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Free device memory.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.set!" href="#CUDAdrv.Mem.set!"><code>CUDAdrv.Mem.set!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Initialize device memory with a repeating value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.upload" href="#CUDAdrv.Mem.upload"><code>CUDAdrv.Mem.upload</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Upload memory from host to device. Executed asynchronously on <code>stream</code> if <code>async</code> is true.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.upload!" href="#CUDAdrv.Mem.upload!"><code>CUDAdrv.Mem.upload!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p>Upload memory from host to device. Executed asynchronously on <code>stream</code> if <code>async</code> is true.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.download" href="#CUDAdrv.Mem.download"><code>CUDAdrv.Mem.download</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Download memory from device to host. Executed asynchronously on <code>stream</code> if <code>async</code> is true.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.download!" href="#CUDAdrv.Mem.download!"><code>CUDAdrv.Mem.download!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p>Download memory from device to host. Executed asynchronously on <code>stream</code> if <code>async</code> is true.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.transfer" href="#CUDAdrv.Mem.transfer"><code>CUDAdrv.Mem.transfer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Transfer memory from device to device. Executed asynchronously on <code>stream</code> if <code>async</code> is true.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.transfer!" href="#CUDAdrv.Mem.transfer!"><code>CUDAdrv.Mem.transfer!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p>Transfer memory from device to device. Executed asynchronously on <code>stream</code> if <code>async</code> is true.</p></div></div></div></section><h3><a class="nav-anchor" id="Memory-info-1" href="#Memory-info-1">Memory info</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.info" href="#CUDAdrv.Mem.info"><code>CUDAdrv.Mem.info</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">info()</code></pre><p>Returns a tuple of two integers, indicating respectively the free and total amount of memory (in bytes) available for allocation by the CUDA context.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.total" href="#CUDAdrv.Mem.total"><code>CUDAdrv.Mem.total</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">total()</code></pre><p>Returns the total amount of memory (in bytes), available for allocation by the CUDA context.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.used" href="#CUDAdrv.Mem.used"><code>CUDAdrv.Mem.used</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">used()</code></pre><p>Returns the used amount of memory (in bytes), allocated by the CUDA context.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.free-Tuple{}" href="#CUDAdrv.Mem.free-Tuple{}"><code>CUDAdrv.Mem.free</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">free()</code></pre><p>Returns the free amount of memory (in bytes), available for allocation by the CUDA context.</p></div></div></section><h2><a class="nav-anchor" id="Stream-Management-1" href="#Stream-Management-1">Stream Management</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuStream" href="#CUDAdrv.CuStream"><code>CUDAdrv.CuStream</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CuStream(flags=0)</code></pre><p>Create a CUDA stream.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuDefaultStream" href="#CUDAdrv.CuDefaultStream"><code>CUDAdrv.CuDefaultStream</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CuDefaultStream()</code></pre><p>Return the default stream.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.synchronize-Tuple{CuStream}" href="#CUDAdrv.synchronize-Tuple{CuStream}"><code>CUDAdrv.synchronize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">synchronize(s::CuStream)</code></pre><p>Wait until a stream&#39;s tasks are completed.</p></div></div></section><h2><a class="nav-anchor" id="Event-Management-1" href="#Event-Management-1">Event Management</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuEvent" href="#CUDAdrv.CuEvent"><code>CUDAdrv.CuEvent</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CuEvent()</code></pre><p>Create a new CUDA event.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.record" href="#CUDAdrv.record"><code>CUDAdrv.record</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">record(e::CuEvent, stream=CuDefaultStream())</code></pre><p>Record an event on a stream.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.synchronize-Tuple{CuEvent}" href="#CUDAdrv.synchronize-Tuple{CuEvent}"><code>CUDAdrv.synchronize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">synchronize(e::CuEvent)</code></pre><p>Waits for an event to complete.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.elapsed" href="#CUDAdrv.elapsed"><code>CUDAdrv.elapsed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">elapsed(start::CuEvent, stop::CuEvent)</code></pre><p>Computes the elapsed time between two events (in seconds).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.@elapsed" href="#CUDAdrv.@elapsed"><code>CUDAdrv.@elapsed</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@elapsed stream ex
@elapsed ex</code></pre><p>A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute on the GPU, as a floating-point number.</p></div></div></section><h2><a class="nav-anchor" id="Execution-Control-1" href="#Execution-Control-1">Execution Control</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuDim3" href="#CUDAdrv.CuDim3"><code>CUDAdrv.CuDim3</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CuDim3(x)

CuDim3((x,))
CuDim3((x, y))
CuDim3((x, y, x))</code></pre><p>A type used to specify dimensions, consisting of 3 integers for respectively the <code>x</code>, <code>y</code> and <code>z</code> dimension. Unspecified dimensions default to <code>1</code>.</p><p>Often accepted as argument through the <code>CuDim</code> type alias, eg. in the case of <a href="#CUDAdrv.cudacall"><code>cudacall</code></a> or <a href="#CUDAdrv.launch"><code>launch</code></a>, allowing to pass dimensions as a plain integer or a tuple without having to construct an explicit <code>CuDim3</code> object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.cudacall" href="#CUDAdrv.cudacall"><code>CUDAdrv.cudacall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cudacall(f::CuFunction, types, values...;
         blocks::CuDim, threads::CuDim, shmem=0, stream=CuDefaultStream())</code></pre><p><code>ccall</code>-like interface for launching a CUDA function <code>f</code> on a GPU.</p><p>For example:</p><pre><code class="language-none">vadd = CuFunction(md, &quot;vadd&quot;)
a = rand(Float32, 10)
b = rand(Float32, 10)
ad = Mem.upload(a)
bd = Mem.upload(b)
c = zeros(Float32, 10)
cd = Mem.alloc(c)

cudacall(vadd, (Ptr{Cfloat},Ptr{Cfloat},Ptr{Cfloat}), ad, bd, cd;
         threads=10)
Mem.download!(c, cd)</code></pre><p>The <code>blocks</code> and <code>threads</code> arguments control the launch configuration, and should both consist of either an integer, or a tuple of 1 to 3 integers (omitted dimensions default to 1). The <code>types</code> argument can contain both a tuple of types, and a tuple type, the latter being slightly faster.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.launch" href="#CUDAdrv.launch"><code>CUDAdrv.launch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">launch(f::CuFunction, blocks::CuDim, threads::CuDim, args...;
       shmem=0, stream=CuDefaultStream())
launch(f::CuFunction, blocks::CuDim, threads::CuDim, shmem::Int, stream::CuStream, args...)</code></pre><p>Low-level call to launch a CUDA function <code>f</code> on the GPU, using <code>blocks</code> and <code>threads</code> as respectively the grid and block configuration. Dynamic shared memory is allocated according to <code>shmem</code>, and the kernel is launched on stream <code>stream</code>.</p><p>Arguments to a kernel should either be bitstype, in which case they will be copied to the internal kernel parameter buffer, or a pointer to device memory.</p><p>This is a low-level call, prefer to use <a href="#CUDAdrv.cudacall"><code>cudacall</code></a> instead.</p></div></div></section><h2><a class="nav-anchor" id="Profiler-Control-1" href="#Profiler-Control-1">Profiler Control</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.@profile" href="#CUDAdrv.@profile"><code>CUDAdrv.@profile</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@profile ex</code></pre><p>Run expressions while activating the CUDA profiler.</p><p>Note that this API is used to programmatically control the profiling granularity by allowing profiling to be done only on selective pieces of code. It does not perform any profiling on itself, you need external tools for that.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Profile.start" href="#CUDAdrv.Profile.start"><code>CUDAdrv.Profile.start</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">start()</code></pre><p>Enables profile collection by the active profiling tool for the current context. If profiling is already enabled, then this call has no effect.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Profile.stop" href="#CUDAdrv.Profile.stop"><code>CUDAdrv.Profile.stop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stop()</code></pre><p>Disables profile collection by the active profiling tool for the current context. If profiling is already disabled, then this call has no effect.</p></div></div></section><footer><hr/><a class="previous" href="../../man/usage/"><span class="direction">Previous</span><span class="title">Usage</span></a></footer></article></body></html>
