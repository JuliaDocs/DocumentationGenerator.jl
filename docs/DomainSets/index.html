<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DomainSets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DomainSets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.AbstractMap" href="#DomainSets.AbstractMap"><code>DomainSets.AbstractMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A map is any transformation of the form <code>y = f(x)</code>, where <code>x</code> has type <code>S</code> and <code>y</code> has type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.AffineMap" href="#DomainSets.AffineMap"><code>DomainSets.AffineMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>AffineMap</code> represents <code>y = a*x + b</code>, i.e. it combines a <code>LinearMap</code> and a <code>Translation</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.CartToPolarMap" href="#DomainSets.CartToPolarMap"><code>DomainSets.CartToPolarMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A Cartesion to Polar map. First dimension is interpreted as radial distance, second as an angle. The unit circle is mapped to a square [-1,1]x[-1,1]</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ChebyshevInterval" href="#DomainSets.ChebyshevInterval"><code>DomainSets.ChebyshevInterval</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The closed interval [-1,1].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.CompositeMap" href="#DomainSets.CompositeMap"><code>DomainSets.CompositeMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The composition of several maps.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ConstantMap" href="#DomainSets.ConstantMap"><code>DomainSets.ConstantMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The constant map <code>f(x) = c</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.DerivedDomain" href="#DomainSets.DerivedDomain"><code>DomainSets.DerivedDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>DerivedDomain is an abstract supertype for domains that are implemented in terms of another domain using composition. DerivedDomain transfers the interface of Domain to this superdomain.</p><p>A concrete subtype that inherits from DerivedDomain and stores a <code>superdomain</code> is functionally equivalent to that superdomain. Any properties of the superdomain can be modified by overriding a suitable function. For example, <code>in</code> of the concrete domain may be implemented in terms of the <code>in</code> of the superdomain.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.EuclideanDomain" href="#DomainSets.EuclideanDomain"><code>DomainSets.EuclideanDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>EuclideanDomain</code> is any domain whose eltype is <code>SVector{N,T}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.HalfLine" href="#DomainSets.HalfLine"><code>DomainSets.HalfLine</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The half-open positive halfline <code>[0,∞)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.IdentityMap" href="#DomainSets.IdentityMap"><code>DomainSets.IdentityMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The identity map.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.IntersectionDomain" href="#DomainSets.IntersectionDomain"><code>DomainSets.IntersectionDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An <code>IntersectionDomain</code> represents the intersection of a set of domains.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.LinearMap" href="#DomainSets.LinearMap"><code>DomainSets.LinearMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>LinearMap</code> is an affine map that represents <code>y = a*x</code>, where <code>a</code> can have any type such that <code>a*x</code> maps type <code>S</code> to type <code>T.</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.NegativeHalfLine" href="#DomainSets.NegativeHalfLine"><code>DomainSets.NegativeHalfLine</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The open negative halfline <code>(-∞,0)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.Point" href="#DomainSets.Point"><code>DomainSets.Point</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Point(x)</code></pre><p>represents a single point at <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.PolarToCartMap" href="#DomainSets.PolarToCartMap"><code>DomainSets.PolarToCartMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A Polar to Cartesian map. The angle is mapped to the second dimension, radius to the first. A square [-1,1]x[-1,1] is mapped to the unit circle</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ProductDomain" href="#DomainSets.ProductDomain"><code>DomainSets.ProductDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>ProductDomain</code> represents the cartesian product of other domains.</p><p>A product domain has two eltypes, an internal type <code>S</code> and an external type <code>T</code>. The internal type <code>S</code> is a tuple containing the eltypes of the elements of the product domain. The external eltype <code>T</code> is a type whose associated space is isomorphic to that of <code>S</code>, but which has been simplified. (See also <code>simplify_product_eltype</code>).</p><p>For example, if <code>S</code> is <code>Tuple{Float64,Float64}</code>, then <code>T</code> is <code>SVector{2,Float64}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ProductMap" href="#DomainSets.ProductMap"><code>DomainSets.ProductMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A product map is diagonal and acts on each of the components of x separately: <code>y = f(x)</code> becomes <code>y_i = f_i(x_i)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.Translation" href="#DomainSets.Translation"><code>DomainSets.Translation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Translation represents <code>y = x + v</code>, where <code>v</code> is a vector in the same space as <code>x</code> and <code>y</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.UnionDomain" href="#DomainSets.UnionDomain"><code>DomainSets.UnionDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>UnionDomain</code> represents the union of a set of domains.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.UnitHyperBall" href="#DomainSets.UnitHyperBall"><code>DomainSets.UnitHyperBall</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The unit ball (of radius 1) in <code>N</code> dimensions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.UnitHyperSphere" href="#DomainSets.UnitHyperSphere"><code>DomainSets.UnitHyperSphere</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The unit sphere (of radius 1) in <code>N</code> dimensions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.UnitInterval" href="#DomainSets.UnitInterval"><code>DomainSets.UnitInterval</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The closed unit interval [0,1].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ℂ" href="#DomainSets.ℂ"><code>DomainSets.ℂ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The complex plane with Float64 real and imaginar parts (ℂ = \BbbC).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ℚ" href="#DomainSets.ℚ"><code>DomainSets.ℚ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The set of rational numbers of type Rational{Int} (ℚ = \BbbQ).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ℝ" href="#DomainSets.ℝ"><code>DomainSets.ℝ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The set of reals of type Float64 (ℝ = \BbbR).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ℝ1" href="#DomainSets.ℝ1"><code>DomainSets.ℝ1</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The space ℝ^1</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ℝ2" href="#DomainSets.ℝ2"><code>DomainSets.ℝ2</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The space ℝ^2</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ℝ3" href="#DomainSets.ℝ3"><code>DomainSets.ℝ3</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The space ℝ^3</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ℝ4" href="#DomainSets.ℝ4"><code>DomainSets.ℝ4</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The space ℝ^4</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ℤ" href="#DomainSets.ℤ"><code>DomainSets.ℤ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The set of integers of type Int (ℤ = \BbbZ).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.:↪" href="#DomainSets.:↪"><code>DomainSets.:↪</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The symbol ↪ (\hookrightarrow) is a synonym for <code>embedded</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.:≅" href="#DomainSets.:≅"><code>DomainSets.:≅</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The symbol ≅ (\cong) is a synonym for <code>isomorphic</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.apply_inverse-Tuple{AbstractMap,Any}" href="#DomainSets.apply_inverse-Tuple{AbstractMap,Any}"><code>DomainSets.apply_inverse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Apply the inverse of the given map. By default, this constructs the inverse of <code>m</code>. However, some maps know its own inverse and may provide a more efficient implementation of <code>apply_inverse</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.cartesianproduct-Tuple{}" href="#DomainSets.cartesianproduct-Tuple{}"><code>DomainSets.cartesianproduct</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Create a cartesian product of the supplied arguments.</p><p>The function cartesianproduct applies some simplifications and does not necessarily return a Product type.</p><p>A <code>cartesianproduct(a)</code> with just a single element returns <code>a</code>.</p><p>For integer <code>n</code>, <code>cartesianproduct(a, n)</code> becomes <code>cartesianproduct(a, a, ..., a)</code>. A type-safe variant is <code>cartesianproduct(a, Val{N})</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ellipse-Tuple{Number,Number}" href="#DomainSets.ellipse-Tuple{Number,Number}"><code>DomainSets.ellipse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Create an ellipse curve with semi-axes lengths <code>a</code> and <code>b</code> respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ellipse_shape-Tuple{Number,Number}" href="#DomainSets.ellipse_shape-Tuple{Number,Number}"><code>DomainSets.ellipse_shape</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Create an ellipse-shaped domain with semi-axes lengths <code>a</code> and <code>b</code> respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.embedded-Tuple{DomainSets.GeometricSpace,DomainSets.GeometricSpace}" href="#DomainSets.embedded-Tuple{DomainSets.GeometricSpace,DomainSets.GeometricSpace}"><code>DomainSets.embedded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns true if <code>A</code> is embedded in <code>B</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.interval_map-NTuple{4,Any}" href="#DomainSets.interval_map-NTuple{4,Any}"><code>DomainSets.interval_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Map the interval [a,b] to the interval [c,d].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.isomorphic-Tuple{DomainSets.GeometricSpace,DomainSets.GeometricSpace}" href="#DomainSets.isomorphic-Tuple{DomainSets.GeometricSpace,DomainSets.GeometricSpace}"><code>DomainSets.isomorphic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns true if <code>A</code> is isomorphic to <code>B</code>, and false otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.issubspace-Union{Tuple{T}, Tuple{Type{GeometricSpace{T}},Type{GeometricSpace{T}}}} where T" href="#DomainSets.issubspace-Union{Tuple{T}, Tuple{Type{GeometricSpace{T}},Type{GeometricSpace{T}}}} where T"><code>DomainSets.issubspace</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>A space <code>A</code> is a subspace of space <code>B</code> if <code>B</code> is a supertype of <code>A</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.left_inverse-Tuple{AbstractMap}" href="#DomainSets.left_inverse-Tuple{AbstractMap}"><code>DomainSets.left_inverse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return a left inverse of the given map. This left inverse <code>mli</code> is not unique, but in any case it is such that <code>(mli ∘ m) * x = x</code> for each <code>x</code> in the domain of <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.linear_map-Tuple{Any,Any}" href="#DomainSets.linear_map-Tuple{Any,Any}"><code>DomainSets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Make the linear map y = a*x + b.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.origin-Tuple{DomainSets.GeometricSpace}" href="#DomainSets.origin-Tuple{DomainSets.GeometricSpace}"><code>DomainSets.origin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>The origin of a space is its zero element.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.right_inverse-Tuple{AbstractMap}" href="#DomainSets.right_inverse-Tuple{AbstractMap}"><code>DomainSets.right_inverse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return a right inverse of the given map. This right inverse <code>mri</code> is not unique, but in any case it is such that <code>(m ∘ mri) * y = y</code> for each <code>y</code> in the range of <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.scaling_map-NTuple{4,Any}" href="#DomainSets.scaling_map-NTuple{4,Any}"><code>DomainSets.scaling_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Scale the variables by a, b, c and d.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.scaling_map-Tuple{Any,Any,Any}" href="#DomainSets.scaling_map-Tuple{Any,Any,Any}"><code>DomainSets.scaling_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Scale the variables by a, b and c.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.scaling_map-Tuple{Any,Any}" href="#DomainSets.scaling_map-Tuple{Any,Any}"><code>DomainSets.scaling_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Scale the variables by a and b.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.scaling_map-Tuple{Any}" href="#DomainSets.scaling_map-Tuple{Any}"><code>DomainSets.scaling_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Scale all variables by a.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.spaceof-Union{Tuple{T}, Tuple{T}} where T" href="#DomainSets.spaceof-Union{Tuple{T}, Tuple{T}} where T"><code>DomainSets.spaceof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return the geometric space of all elements with the same type as <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.spacetype-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#DomainSets.spacetype-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>DomainSets.spacetype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return the geometric space type with eltype <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.subeltype-Tuple{Domain}" href="#DomainSets.subeltype-Tuple{Domain}"><code>DomainSets.subeltype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>If the type <code>T</code> is a container type, the elements of <code>T</code> may have a different <code>subeltype</code>. If <code>T</code> is not a container, <code>subeltype</code> simply evaluates to <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.subeltype-Union{Tuple{Type{GeometricSpace{T}}}, Tuple{T}} where T" href="#DomainSets.subeltype-Union{Tuple{Type{GeometricSpace{T}}}, Tuple{T}} where T"><code>DomainSets.subeltype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Some geometric spaces have an eltype that is composed in terms of an underlying eltype. For example, <code>Complex{Float64}</code> and <code>SVector{2,Float64}</code> are based on <code>Float64</code>, which is their <code>subeltype</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.superspace-Union{Tuple{Type{GeometricSpace{T}}}, Tuple{T}} where T" href="#DomainSets.superspace-Union{Tuple{Type{GeometricSpace{T}}}, Tuple{T}} where T"><code>DomainSets.superspace</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return the superspace of the given geometric space <code>A</code>. The superspace of <code>A</code> should be larger than <code>A</code>, and <code>A</code> should be embedded in it.</p><p>Superspaces are used to automatically discover embeddings and promotion rules. Its role is analogous to that of <code>supertype</code> in the Julia type system. Indeed, <code>AnySpace</code> is a superspace of all spaces, much like <code>Any</code> is a supertype of all types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.AbstractAffineMap" href="#DomainSets.AbstractAffineMap"><code>DomainSets.AbstractAffineMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An affine map has the general form <code>y = a*x + b</code>, with types for <code>a</code>, <code>b</code>, <code>x</code> and <code>y</code> such that the expression is valid.</p><p>We use matrix and vector to denote <code>a</code> and <code>b</code> respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.AbstractConstantMap" href="#DomainSets.AbstractConstantMap"><code>DomainSets.AbstractConstantMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The supertype of several maps that map to a constant value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.AngleMap" href="#DomainSets.AngleMap"><code>DomainSets.AngleMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>AngleMap</code> is a left inverse of <code>UnitCircleMap</code>. A 2D vector <code>x</code> is projected onto the intersection point with the unit circle of the line connecting <code>x</code> to the origin. The angle of this point, scaled to the interval <code>[0,1)</code>, is the result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.AnySpace" href="#DomainSets.AnySpace"><code>DomainSets.AnySpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>AnySpace is the superset of all possible geometric spaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ArraySpace" href="#DomainSets.ArraySpace"><code>DomainSets.ArraySpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A general Array space, with arrays of dimension <code>N</code> and element type <code>T</code>. Note that the arrays can have any size. Thus, <code>ArraySpace{2,Float64}</code> contains all possible matrices of size <code>m × n</code> for any combination of <code>m,n ∈ ℕ</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.BidirectionalMappedDomain" href="#DomainSets.BidirectionalMappedDomain"><code>DomainSets.BidirectionalMappedDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>BidirectionalMappedDomain</code> stores the <code>source</code> domain and both the map <code>f</code> and a left inverse.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ComplexSpace" href="#DomainSets.ComplexSpace"><code>DomainSets.ComplexSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A geometric space with complex type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.EmbeddingMap" href="#DomainSets.EmbeddingMap"><code>DomainSets.EmbeddingMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A map between embedded spaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.FixedInterval" href="#DomainSets.FixedInterval"><code>DomainSets.FixedInterval</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The abstract type <code>FixedInterval</code> is the supertype of intervals with endpoints determined by the type, rather than field values. Examples include <code>UnitInterval</code> and <code>ChebyshevInterval</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ForwardMappedDomain" href="#DomainSets.ForwardMappedDomain"><code>DomainSets.ForwardMappedDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>ForwardMappedDomain</code> stores the <code>source</code> domain and the forward map <code>f</code>, which maps <code>source</code> to <code>target</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.GeometricSpace" href="#DomainSets.GeometricSpace"><code>DomainSets.GeometricSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A domain is always a subset of a geometric space. A geometric space is completely characterized by the type <code>T</code> of its elements. There are no restrictions on concrete values: each instance of type <code>T</code> belongs to <code>GeometricSpace{T}</code>. Conversely, each numeric type <code>T</code> can give rise to only one geometric space.</p><p>The goal of <code>GeometricSpace</code> is to provide a lightweight framework for converting elements between spaces. Two features are embeddings and isomorphisms. It is lightweight because the space is characterized by the type and has no state, hence it can be inferred from any variable based only on its type. A restriction that results from this choice is that there can only be one type of embedding from one space to another. More general embeddings could be implemented using domains or specific maps.</p><p>Embeddings: A space <code>A</code> is embedded in a space <code>B</code> if each element of <code>A</code> corresponds to an element of <code>B</code>. In that case an element of <code>A</code> can be promoted (using <code>promote_space</code>) to an element of type <code>B</code>. This is not necessarily the same as the promotion of the type of <code>A</code> to the type of <code>B</code>. For example, a scalar can be embedded into a two-dimensional space (say with the second component equal to zero). It would be undesirable to implement that using the standard Julia promotion system, since it would apply to all Julia code used concurrently.</p><p>Isomorphisms: If <code>A</code> is embedded in <code>B</code> and <code>B</code> is embedded in <code>A</code> than they <code>A</code> and <code>B</code> are isomorphic. In that case, an element of <code>A</code> can be converted to an element of <code>B</code> and vice-versa. The conversion is invertible. One example is the isomorphism between ℝ^2 and ℂ.</p><p>New spaces can be defined by defining a new numeric type. Embeddings and isomorphisms are defined by defining new <code>embedding_reduction</code> and <code>isomorphism_reduction</code> rules, along with conversiong using <code>convert_space</code> and <code>restrict_space</code>. See the documentation of these functions for information on how to use them.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.IntegerSpace" href="#DomainSets.IntegerSpace"><code>DomainSets.IntegerSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A geometric space with integer type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.InverseMappedDomain" href="#DomainSets.InverseMappedDomain"><code>DomainSets.InverseMappedDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An <code>InverseMappedDomain</code> stores the <code>source</code> and the inverse of the map <code>f</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.IsomorphismMap" href="#DomainSets.IsomorphismMap"><code>DomainSets.IsomorphismMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A map between isomorphic spaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.MappedDomain" href="#DomainSets.MappedDomain"><code>DomainSets.MappedDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>There are three objects involved in the mapping of a domain:</p><ul><li>the original domain (denoted source)</li><li>the map (denoted f)</li><li>the resulting domain (target)</li></ul><p>If <code>f</code> maps a variable of type <code>S</code> to a variable of type <code>T</code>, then the <code>source</code> domain has eltype <code>S</code> and the target domain has eltype <code>T</code>.</p><p>The characteristic function of the resulting domain is defined in terms of the inverse of the map <code>f</code>, i.e.:</p><pre><code class="language-none">in(x, target) = in(inv(f)*x, source)</code></pre><p>Concrete mapped domains can be implemented in various ways, e.g. by storing <code>source</code> and <code>f</code>, or by storing <code>source</code> and <code>inv(f)</code>, ...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ProductSpace" href="#DomainSets.ProductSpace"><code>DomainSets.ProductSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>By convention a geometric space with a tuple type <code>T</code> represents a product space of the individual entries of <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.RationalSpace" href="#DomainSets.RationalSpace"><code>DomainSets.RationalSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A geometric space with rational types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.RealSpace" href="#DomainSets.RealSpace"><code>DomainSets.RealSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A geometric space with floating point type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.RestrictionMap" href="#DomainSets.RestrictionMap"><code>DomainSets.RestrictionMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A restriction map from a space to an embedded space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.TypeFactory" href="#DomainSets.TypeFactory"><code>DomainSets.TypeFactory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>TypeFactory{T}</code> is a convenience type to simplify construction of a type.</p><p>Having <code>t = TypeFactory{T}</code> overrides <code>getindex</code> such that <code>t[a]</code> invokes <code>T(a)</code>.</p><p>For example:</p><pre><code class="language-none">v = TypeFactory{SVector}
v[0.1,0.2]</code></pre><p>makes an <code>SVector{2,Float64}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.UnitCircleMap" href="#DomainSets.UnitCircleMap"><code>DomainSets.UnitCircleMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The map <code>[cos(2πt), sin(2πt)]</code> from <code>[0,1)</code> to the unit circle in <code>ℝ^2</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.UnityMap" href="#DomainSets.UnityMap"><code>DomainSets.UnityMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The unity map <code>f(x) = 1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.VectorSpace" href="#DomainSets.VectorSpace"><code>DomainSets.VectorSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A Euclidean space with static vector types. It is the space of all vectors of fixed length <code>N</code>, with entries of type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.ZeroMap" href="#DomainSets.ZeroMap"><code>DomainSets.ZeroMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The zero map <code>f(x) = 0</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets._product_eltype-Tuple{Any}" href="#DomainSets._product_eltype-Tuple{Any}"><code>DomainSets._product_eltype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Create an eltype that is suitable for a product domain. The result is a tuple type, where each of the elements is the eltype of the corresponding element of the product domain.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.affine_composition-Tuple{DomainSets.AbstractAffineMap,DomainSets.AbstractAffineMap}" href="#DomainSets.affine_composition-Tuple{DomainSets.AbstractAffineMap,DomainSets.AbstractAffineMap}"><code>DomainSets.affine_composition</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Compute the affine map that represents map2 after map1, that is: y = a2<em>(a1</em>x+b1)+b2 = a2<em>a1</em>x + a2*b1 + b2.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.convert_space-Union{Tuple{T}, Tuple{Type{GeometricSpace{T}},T}} where T" href="#DomainSets.convert_space-Union{Tuple{T}, Tuple{Type{GeometricSpace{T}},T}} where T"><code>DomainSets.convert_space</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Convert the variable <code>x</code> to an element of the space <code>B</code>. This is possible if the space of <code>x</code> is embedded in <code>B</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.default_tolerance-Tuple{Domain}" href="#DomainSets.default_tolerance-Tuple{Domain}"><code>DomainSets.default_tolerance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return a suitable tolerance to use for verifying whether a point is close to a domain. Typically, the tolerance is close to the precision limit of the numeric type associated with the domain.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.demote-Union{Tuple{T}, Tuple{Type{T},Any}} where T" href="#DomainSets.demote-Union{Tuple{T}, Tuple{Type{T},Any}} where T"><code>DomainSets.demote</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>The function <code>demote(S, y::T)</code> is a left inverse of <code>convert(T, x::S)</code>, for the case where type <code>S</code> promotes to type <code>T</code> (i.e. <code>promote_type(S,T) == T</code>).</p><p>This means that <code>demote(S, convert(T, x::S)) == x</code>, while <code>demote(S, y)</code> may be anything for <code>y::T</code> not in the range of <code>convert(T, x::S)</code>.</p><p>Note that Julia&#39;s <code>convert</code> function is its own left inverse, in the sense that <code>convert(S, convert(T,x)) == x</code> usually holds if <code>x::S</code>. However, the <code>convert</code> function generally throws an <code>InexactError()</code> for elements of type <code>T</code> that are not in (or close to) the range of <code>convert(T, x::S)</code>. In those cases, <code>demote</code> does not throw an error, but there may be an arbitrarily large difference between <code>convert(T, demote(S, y))</code> and <code>y</code> itself. In other words, <code>demote</code> may differ wildly from a right inverse of <code>convert</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.element-Tuple{Any,Any}" href="#DomainSets.element-Tuple{Any,Any}"><code>DomainSets.element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return the i-th element of a composite structure.</p><p>See also: <code>elements</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.elements-Tuple{}" href="#DomainSets.elements-Tuple{}"><code>DomainSets.elements</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Some types have composite structure, e.g. product domains, a union of domains. These types contain a list of domains.</p><p>It is often undesirable to use <code>getindex</code> to access the elements of the composite type. For this reason we introduce the <code>elements</code> functions. Composite types can implement <code>elements</code> and provide a generic way to access their components.</p><p><code>elements(t)</code>: returns the elements making up the composite type <code>t</code></p><p><code>element(t, i)</code>: return the <code>i</code>-th element of the composite type <code>t</code></p><p><code>numelements(t)</code>: return the number of elements of the composite type <code>t</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.embedding-Union{Tuple{T}, Tuple{Type{GeometricSpace{T}},Type{GeometricSpace{T}}}} where T" href="#DomainSets.embedding-Union{Tuple{T}, Tuple{Type{GeometricSpace{T}},Type{GeometricSpace{T}}}} where T"><code>DomainSets.embedding</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>The function <code>embedding</code> describes in the type domain whether a space with type <code>T</code> is embedded into a space with type <code>B</code>. If so, it returns True, otherwise it returns False.</p><p>Embeddings are the result of the following rules:</p><ol><li>A{T} is embedded in A{S} if T promotes to S in the Julia type system</li><li>If a rule embedding_reduction(A,B) = (C,D) has been defined, then A is embedded in B if C is embedded in D.</li><li>Say A and B are isomorphic if C and D are. This automatically results in embedding reduction rules from A to B and from B to A.</li><li>A is embedded in B if the superspace of A is embedded in B.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.isomorphism-Union{Tuple{T}, Tuple{Type{GeometricSpace{T}},Type{GeometricSpace{T}}}} where T" href="#DomainSets.isomorphism-Union{Tuple{T}, Tuple{Type{GeometricSpace{T}},Type{GeometricSpace{T}}}} where T"><code>DomainSets.isomorphism</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return <code>True</code> if <code>A</code> and <code>B</code> are isomorphic. This implies that any point in <code>A</code> can be converted to a point in <code>B</code>, and vice-versa, with an exact inverse.</p><p>The functionality is implemented recursively in terms of the <code>isomorphism_reduction</code> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.isomorphism_reduction-Union{Tuple{S}, Tuple{T}, Tuple{Type{GeometricSpace{T}},Type{GeometricSpace{S}}}} where S where T" href="#DomainSets.isomorphism_reduction-Union{Tuple{S}, Tuple{T}, Tuple{Type{GeometricSpace{T}},Type{GeometricSpace{S}}}} where S where T"><code>DomainSets.isomorphism_reduction</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Indicate a reduction rule for isomorphism. The function either returns <code>()</code> or a 2-tuple. If <code>isomorphism_reduction(A,B)</code> returns <code>(C,D)</code>, this means that <code>A</code> and <code>B</code> are isomorphic if <code>C</code> and <code>D</code> are. Here, <code>C</code> and <code>D</code> are the subeltypes of <code>A</code> and <code>B</code> respectively.</p><p>For example, <code>VectorSpace{2,T}</code> and <code>ComplexSpace{S}</code> are isomorphic if <code>GeometricSpace{T}</code> and <code>GeometricSpace{S}</code> are isomorphic.</p><p>The isomorphism only has to be declared in one direction, and is automatically valid in both directions. For space promotions, in case of ambiguity the first space <code>A</code> here is chosen as the preferred promotion space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.numelements-Tuple{Any}" href="#DomainSets.numelements-Tuple{Any}"><code>DomainSets.numelements</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return the number of elements of a composite structure.</p><p>See also: <code>elements</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.promote_space-Tuple{}" href="#DomainSets.promote_space-Tuple{}"><code>DomainSets.promote_space</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Promote the geometric spaces of the arguments to a joined space, to which all arguments can be converted using embeddings. If no such concrete space exists, the joined space is AnySpace and the arguments remain unaltered.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.promotes_to-Tuple{Any,Any}" href="#DomainSets.promotes_to-Tuple{Any,Any}"><code>DomainSets.promotes_to</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return True if S promotes to T, i.e., if promote_type(S,T) == T.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.restrict_space-Union{Tuple{T}, Tuple{Type{GeometricSpace{T}},T}} where T" href="#DomainSets.restrict_space-Union{Tuple{T}, Tuple{Type{GeometricSpace{T}},T}} where T"><code>DomainSets.restrict_space</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Restrict the variable <code>x</code> to an element of the space <code>B</code>. This is possible if <code>B</code> is embedded in the space of <code>x</code>.</p><p>Mathematically, <code>restrict_space(A, y)</code> for <code>y</code> in space <code>B</code> is a left inverse of <code>convert_space(B, x)</code> for <code>x</code> in space <code>A</code>. This means that <code>restrict_space(A, convert_space(B, x)) == x</code> for any <code>x</code> in space <code>A</code>. However, <code>restrict_space(A, y)</code> for a <code>y</code> not in the range of <code>convert_space(B, x)</code> could take any value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.return_type-Union{Tuple{T}, Tuple{S}, Tuple{AbstractMap{S,T},Type{S}}} where T where S" href="#DomainSets.return_type-Union{Tuple{T}, Tuple{S}, Tuple{AbstractMap{S,T},Type{S}}} where T where S"><code>DomainSets.return_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>return_type(map, U)</code> is a generic function that computes the return type when the given map is applied to a variable of type <code>U</code>.</p><p>For any <code>AbstractMap{S,T}</code>, we have that <code>return_type(map, S) = T</code>. We also return <code>T</code> if <code>U</code> can be promoted to <code>T</code> using Julia&#39;s promotion system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.similar_interval-Union{Tuple{T}, Tuple{FixedInterval{:closed,:closed,T},Any,Any}} where T" href="#DomainSets.similar_interval-Union{Tuple{T}, Tuple{FixedInterval{:closed,:closed,T},Any,Any}} where T"><code>DomainSets.similar_interval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return an interval that is similar to the given interval, but with endpoints <code>a</code> and <code>b</code> instead.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.similar_space-Union{Tuple{S}, Tuple{T}, Tuple{Type{GeometricSpace{T}},Type{S}}} where S where T" href="#DomainSets.similar_space-Union{Tuple{S}, Tuple{T}, Tuple{Type{GeometricSpace{T}},Type{S}}} where S where T"><code>DomainSets.similar_space</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Create a space that is similar to the given space, but with a different <code>subeltype</code>.</p><p>For example, <code>similar_space(ComplexSpace{Float64}, BigFloat)</code> yields a <code>ComplexSpace{BigFloat}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.simplify_product_eltype-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#DomainSets.simplify_product_eltype-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>DomainSets.simplify_product_eltype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Try to simplify the type of a product domain to a type to which it is isomorphic. The goal is to automatically embed the product domain in ℝ^N if possible.</p><p>Examples of simplifications: <code>Tuple{Float64,Float64} -&gt; SVector{2,Float64}</code> <code>Tuple{Tuple{Float64,Float64},Float64} -&gt; SVector{3,Float64}</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DomainSets.supereltype-Tuple{DerivedDomain}" href="#DomainSets.supereltype-Tuple{DerivedDomain}"><code>DomainSets.supereltype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return the eltype of the superdomain.</p></div></div></section><footer><hr/></footer></article></body></html>
