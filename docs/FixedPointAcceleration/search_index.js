var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#FixedPointAcceleration.jl-1",
    "page": "Readme",
    "title": "FixedPointAcceleration.jl",
    "category": "section",
    "text": "Build Coverage\n(Image: Build Status) (Image: Coverage Status)This package implements similar functionality to https://cran.r-project.org/web/packages/FixedPoint/index.html. The key differences are:This package makes use of Julia\'s type system and is generally typed in a more stable and extendible way. FixedPoint results are always output in a FixedPointResults struct. All algorithms are specified by an enum.\nThis package does not include the plotting capability of the R package. This is not essential for the functionality of the package and since fixed_point calls can be chained together you can easily do whatever plotting you want pretty easily where necessary."
},

{
    "location": "#Included-Acceleration-algorithms.-1",
    "page": "Readme",
    "title": "Included Acceleration algorithms.",
    "category": "section",
    "text": "There are 8 acceleration algorithms included in this package. A more extensive explanation is available in the documentation for the R package: https://cran.r-project.org/web/packages/FixedPoint/vignettes/FixedPoint.pdf and the original papers are all cited there. A very brief description however is:Simple - This takes the output of the previous iterate and uses it as the next guess.In addition the following three scalar algorithms can be used (they are elementwise for vectors):Aitken - This considers the sequence p, f(p), f(f(p)) ... convergences at a constant rate to the fixed point. After each two iterates it estimates the rate and jumps to the anticipated fixed point;\nNewton - This uses a Newtonian rootfinder to solve for the root of f(x) - x;\nSEA - or Scalar Epsilon Algorithm. This uses an epsilon algorithm for finding a fixed point where an elementwise inverse is taken;In addition the following four algorithms are specialised for vectors of arbitrary length. This is done after every \"ExtrapolationPeriod\" number of iterates which is 7 by default;VEA - or Vector Epsilon Algorithm. This uses an epsilon algorithm for finding a fixed point where an Moore-Penrose Pseudoinverse is used for vectors. This is done after every \"ExtrapolationPeriod\" number off iterates which is 7 by default;\nMPE - or Minimal Polynomial Extrapolation uses a linear combination of previous iterates for the next guess. This is done after every \"ExtrapolationPeriod\" number off iterates which is 7 by default;\nRRE - or Reduced Rank Extrapolation uses a linear combination of previous iterates for the next guess. This is done after every \"ExtrapolationPeriod\" number off iterates which is 7 by default;\nAnderson (default) - This takes a linear combination of previous iterates (it gets weights from an OLS regression). Unlike RRE, MPE,VEA this linear combination does not need to be of sequential simple iterates but can be any previous iterates. At maximum \"MaxM\" previous iterates are used but fewer may be used for numerical stability reasons if a certain matrix used in an OLS regression has a condition number above \"ConditionNumberThreshold\"."
},

{
    "location": "#Using-FixedPointAcceleration-1",
    "page": "Readme",
    "title": "Using FixedPointAcceleration",
    "category": "section",
    "text": "We can first use FixedPointAcceleration to find the fixed point of the 1d function cos(x) with the Anderson method.using FixedPointAcceleration\ncos_func(x) = cos.(x)\nInputs = 1.1\nfp_anderson = fixed_point(cos_func, Inputs; Algorithm = Anderson)\n# And we can see the fixed point by looking at\nfp_anderson.FixedPoint_Two important issues are important to highlight here:All input functions must take and return Array{Float64,1} types. When solving for the fixedpoint of a scalar function use of the dot syntax - cos.(x) instead of cos(x) - might be useful for this.\nfpanderson.FixedPoint  in this case may be missing. This occurs whenever a fixedpoint was not found that is correct to the specified ConvergenceMetric and ConvergenceMetricThreshold. In this case the fpanderson.Outputs array will probably contain something close to a fixed point in its rightmost column."
},

{
    "location": "#Chaining-Fixed-Point-Acceleration-Algorithms-1",
    "page": "Readme",
    "title": "Chaining Fixed Point Acceleration Algorithms",
    "category": "section",
    "text": "We can \"chain\" together different calls to the fixed_point function in order to switch acceleration algorithm at any point. For instance consider the following function and initial guess at a fixed point:func(x) = [0.5*sqrt(abs(x[1] + x[2])), 1.5*x[1] + 0.5*x[2]]\nInitial_Guess = [1.1,2.2]Now we can initially do two simple iterates. Then do three iterates with the MPE method. Then one with the simple method and then finish with the RRE method. This can be done in the following way:fp_chain      = fixed_point(func, Initial_Guess; Algorithm = Simple, MaxIter = 2)\nfp_chain      = fixed_point(func, fp_chain; Algorithm = MPE, MaxIter = 3)\nfp_chain      = fixed_point(func, fp_chain; Algorithm = Simple, MaxIter = 1)\nfp_chain      = fixed_point(func, fp_chain; Algorithm = RRE, MaxIter = 100)Now as it turns out The MPE (and RRE) does simple iterates except for every iterate that is a multiple of the ExtrapolationPeriod (7 by default). And so there is no difference from the above sequence of iterates and just doing all iterates with the RRE. This can be verified with the following:fp_nochain = fixed_point(func, Inputs; Algorithm = RRE, MaxIter = 100)\nfp_chain.Iterations_ == fp_nochain.Iterations_\nall(abs.(fp_chain.Inputs_ .- fp_nochain.Inputs_) .< 1e-14)This does highlight that there is no waste in changing fixed_point algorithm in this way. No iterates are reevaluated.Changing algorithms can be useful in some cases where an error occurs. For instance consider we are trying to find the fixed point of the following function:simple_vector_function(x) = [0.5*sqrt(x[1] + x[2]), 1.5*x[1] + 0.5*x[2]]\nInputs = [0.3,900]\nfp = fixed_point(simple_vector_function, Inputs; Algorithm = Anderson)Inspecting this fp object reveals an error after the 3rditeration because Anderson tries to use a negative value for both x entries which results in the square root of a negative number. We can switch to simple iterations to get closer to the fixed point at which point Anderson will no longer try negative numbers. This will fix this.fp = fixed_point(simple_vector_function, fp; Algorithm = Simple, MaxIter = 7)\nfp = fixed_point(simple_vector_function, fp; Algorithm = Anderson)"
},

{
    "location": "#Termination-conditions-and-Error-handling.-1",
    "page": "Readme",
    "title": "Termination conditions and Error handling.",
    "category": "section",
    "text": "There are three possible TerminationCondition_ types that can be returned in the FixedPointResults struct. These are:ReachedConvergenceThreshold - A fixed point has been reached.\nReachedMaxIter - The maximum number of iterations has been reached.\nInvalidInputOrOutputOfIteration - A fatal error has occured while trying to solve for a fixed point. This is often simple to fix by simply changing algorithms for a while and hence any errors are caught and a FixedPointResults struct is returned detailing the error rather than explicitly throwing an error.There are a few errors that can result in a InvalidInputOrOutputOfIteration termination. To aid in debugging where this termination condition is returned a FunctionEvaluationResult struct is returned as part of the FixedPointResults struct. This includes the inputs used when the error occured, the outputs (if they could be generated) and an additional error code (of enum type FP_FunctionEvaluationError):NoError - This indicates no error. You should never see this unless developing in the package as a function evaluation without an error will not cause a InvalidInputOrOutputOfIteration termination that causes the FunctionEvaluationResult struct to be returned.\nErrorExecutingFunction - This indicates that there was an error evaluating the function with the given inputs. This will occur for instance if you try to evaluate sqrt.(x) at x = [-1.0] or 1/x at x = [0.0]. This may be solved by changing acceleration algorithm so that it does not try a vector which causes errors in the function. It may also be possible to reparameterise the function so that any vector is a valid input to the function.\nLengthOfOutputNotSameAsInput - A function taking an N-dimensional vector is not returning an N-dimensional vector.\nInputMissingsDetected - A function is returning an input vector containing missing values.\nInputNAsDetected - A function is returning an input vector containing NaN values.\nInputInfsDetected - A function is returning an input vector containing Inf values. While mathematically there is nothing wrong with this (Inf is a fixedpoint of the f(x) = x!), the algorithms of this package are not going to be useful in this case and hence it is not supported.\nOutputMissingsDetected - A function is returning an output vector containing missing values.\nOutputNAsDetected - A function is returning an output vector containing NaN values.\nOutputInfsDetected - A function is returning an output vector containing Inf values. While mathematically there is nothing wrong with this (like for InputInfsDetected) it is not supported.Together this error handling system should handle any errors gracefully without raising an ErrorException. ErrorExceptions are avoided so that the Inputs and Outputs from previous iterates are retained and the search for a fixed point can be resumed without interruption. If an ErrorException does occur while using fixed_point please raise an issue in github because this is not expected."
},

{
    "location": "autodocs/#FixedPointAcceleration.execute_function_safely-Tuple{Function,Array{Float64,1}}",
    "page": "Docstrings",
    "title": "FixedPointAcceleration.execute_function_safely",
    "category": "method",
    "text": "execute_function_safely(Func::Function, x::Array{Float64,1})\n\nThis function creates a function that executes the function for which a fixed point is sought. It is a helper function that is not exported.\n\nTakes\n\nFunc - The function input to fixed_point\nx - The point at which to evaluate the function.\n\nReturns\n\nA FunctionEvaluationResult containing the following fields:\n\nInput_ - The input\nOutput_ - The output of the FunctionExecutor. May be missing if function could not complete without error.\nError_ - A enum of type FP_FunctionEvaluationError representing what error occured.\n\nExamples\n\nFunc(x) = sqrt(x) executefunctionsafely(Func, [-1.0,0.0,1.0]) executefunctionsafely(Func,[Missing(),0.0,1.0]) executefunctionsafely(Func,[7.0,0.0,1.0]) executefunctionsafely(Func,[NaN,0.0,1.0]) executefunctionsafely(Func,[Inf,0.0,1.0]) executefunctionsafely(Func,-1.0) executefunctionsafely(Func,Missing()) executefunctionsafely(Func,1.0) executefunctionsafely(Func,NaN) executefunctionsafely(Func,Inf)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#FixedPointAcceleration.fixed_point-Tuple{Function,FixedPointResults}",
    "page": "Docstrings",
    "title": "FixedPointAcceleration.fixed_point",
    "category": "method",
    "text": "fixed_point(func::Function, previous_FixedPointResults::FixedPointResults;\n            Algorithm::FixedPointAccelerationAlgorithm = Anderson,  ConvergenceMetric::Function  = supnorm(Resids::Array{Float64, 1}) = maximum(abs.(Resids)),\n            ConvergenceMetricThreshold::Float64 = 1e-10, MaxIter::Int = 1000, MaxM::Int = 10, ExtrapolationPeriod::Int = 7, Dampening::Float64 = 1.0,\n            PrintReports::Bool = false, ReportingSigFig::Int = 10, ReplaceInvalids::InvalidReplacement = NoAction, ConditionNumberThreshold::Float64 = 1e3)\nfixed_point(func::Function, Inputs::Array{Float64, 1};\n            Algorithm::FixedPointAccelerationAlgorithm = Anderson,  ConvergenceMetric::Function  = supnorm(Resids::Array{Float64, 1}) = maximum(abs.(Resids)),\n            ConvergenceMetricThreshold::Float64 = 1e-10, MaxIter::Int = 1000, MaxM::Int = 10, ExtrapolationPeriod::Int = 7, Dampening::Float64 = 1.0,\n            PrintReports::Bool = false, ReportingSigFig::Int = 10, ReplaceInvalids::InvalidReplacement = NoAction, ConditionNumberThreshold::Float64 = 1e3)\nfixed_point(func::Function, Inputs::Float64;\n            Algorithm::FixedPointAccelerationAlgorithm = Anderson,  ConvergenceMetric::Function  = supnorm(Resids::Array{Float64, 1}) = maximum(abs.(Resids)),\n            ConvergenceMetricThreshold::Float64 = 1e-10, MaxIter::Int = 1000, MaxM::Int = 10, ExtrapolationPeriod::Int = 7, Dampening::Float64 = 1.0,\n            PrintReports::Bool = false, ReportingSigFig::Int = 10, ReplaceInvalids::InvalidReplacement = NoAction, ConditionNumberThreshold::Float64 = 1e3)\nfixed_point(func::Function, Inputs::Array{Float64, 2}; Outputs::Array{Float64,2} = Array{Float64,2}(undef,size(Inputs)[1],0),\n            Algorithm::FixedPointAccelerationAlgorithm = Anderson,  ConvergenceMetric::Function  = supnorm(Resids::Array{Float64, 1}) = maximum(abs.(Resids)),\n            ConvergenceMetricThreshold::Float64 = 1e-10, MaxIter::Int = 1000, MaxM::Int = 10, ExtrapolationPeriod::Int = 7, Dampening::Float64 = 1.0,\n            PrintReports::Bool = false, ReportingSigFig::Int = 10, ReplaceInvalids::InvalidReplacement = NoAction, ConditionNumberThreshold::Float64 = 1e3)\n\nA function for finding the fixed point of another function\n\nTakes\n\nf - This is the function for which a fixed point is sought. This function must take and return a vector of the same size dimension.\nInputs - This can be either a 1D-vector of values that is an initial guess for a fixed point or it can be an N x A matrix of previous inputs for which corresponding outputs are available. In this case N is the dimensionality of the fixed point vector you are seeking (Hence each column is a matrix that is input to f) and A is the number of previous Inputs/Outputs that are being provided to the fixed point. Where a matrix is input, a corresponding outputs must be provided or the last column of the outputs matrix is taken as a startpoint guess and the rest of the inputs and output matrices are discarded.\nOutputs - This is a matrix of the Function values for each column of the input. It must be provided so that column k of the outputs matrix is equal to Function(Column k of inputs matrix).\nAlgorithm - This is the fixed point Algorithm to be used. It can be Anderson, Simple, Aitken, Newton, MPE, RRE, VEA or SEA. See vignette and references to see explanations of these Algorithms.\nConvergenceMetric This is a function that takes in a vector of inputs and a table of outputs and returns a scalar. This scalar should be low when convergence is close to being achieved. By default this is the maximum residual by absolute value (the sup norm in the space of residuals).\nConvergenceMetricThreshold This is the threshold for terminating the algorithm. The algorithm will terminate when the scalar that ConvergenceMetric returns is less than ConvergenceMetricThreshold. This can be set to a negative number in which case the algorithm will run until MaxIter is hit or an error occurs (Note that an error is likely in trying to use any Algorithm other than \"Simple\" when a fixed point is already found).\nMaxIter - This is the maximum number of iterates that will be undertaken.\nMaxM - This is the maximum number of saved iterates that are used in the Anderson algorithm. It has no effect if another Algorithm is chosen. Note that the number of previous iterates that will actually be used is the minimum of MaxIter, the dimensionality of the f\'s vector and the number of inputs that have been tried to  previously (the width of the Outputs matrix at each given stage of the algorithm). If PrintReports = TRUE, the number of previous iterates actually used is reported as the algorithm is running.\nExtrapolationPeriod - This is the number of simple iterates to perform before extrapolating. This is used for the MPE, RRE, VEA and SEA Algorithms and has no effect if another Algorithm is chosen Where an epsilon algorithm is used this should be a multiple of 2, ie (4,6,8,etc).\nDampening - This is the dampening parameter. By default it is 1 which means no dampening takes place. It can also be less than 1 (indicating dampening) or more than 1 (indicating extrapolation).\nPrintReports - This is a boolean describing whether to print ongoing ConvergenceMetric values for each iterate.\nReportingSigFig - This is the number of significant figures that will be used in printing the convergence values to the console (only if PrintReports is TRUE).\nReplaceInvalids -Sometimes an acceleration algorithm proposed a vector with an invalid coordinate (NaN, Inf or missing). This parameter can be set to ReplaceInvalids (to replace invalid coordinates by the simple iterate values), ReplaceVector (to replace entire vector with a simple iterate) or NoAction (where an imminent error will occur).\nConditionNumberThreshold - This is a threshold for what condition number is acceptable for solving the least squares problem for the Anderson Algorithm. If the condition number is larger than this threshold then fewer previous iterates will be used in solving the problem. This has no effect unless the \"Anderson\" Algorithm is used.\n\nReturns\n\nA list containing the fixed_point, the Inputs and corresponding Outputs, and convergence values (which are computed under the \"ConvergenceMetric\"). The list will also include a \"Finish\" statement describing why it has finished. This is often going to be due to either MaxIter or ConvergenceMetricThreshold being reached. It may also terminate due to an error in generating a new input guess or using the function with that guess. If this occurs the function will terminate early and the \"Finish\" statement will describe the issue. In this event there will also be additional objects returned in the list \"NewInputVector\" and possibly \"NewOutputVector\" that are useful in debugging the issue.\n\nExamples\n\n#\' # For the simplest possible example we can seek the fixed point of the cos function with a scalar.  #\' Inputs = 0.3  #\' Func(x) = cos(x)  #\' A = fixedpoint(Func, Inputs; Algorithm = Aitken, Dampening = 0.5)  #\' B = fixedpoint(Func, Inputs; Algorithm = Anderson, Dampening = 1.0)  #\'  #\' # For this next one the ConvergenceMetricThreshold is negative so the algorithm  #\' # will keep running until MaxIter is met.  #\' C = fixedpoint(Func, Inputs; Algorithm = Simple, MaxIter = 4, ConvergenceMetricThreshold = -1.0)  #\' # But we can continue solving for this fixed point but now switching to the Newton Algorithm.  #\' D = fixedpoint(Func, C[:Inputs], C[:Outputs]; Algorithm = Newton)  #\'  #\' # We can also find a 4 dimensional fixed point vector of this function.  #\' Inputs = [0.3, 98, 0, pi]  #\' E = fixedpoint(Func, Inputs; Algorithm = Anderson)  #\' F = fixedpoint(Func, Inputs; Algorithm = Anderson, MaxM = 4, ReportingSigFig = 13)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#FixedPointAcceleration.fixed_point_new_input",
    "page": "Docstrings",
    "title": "FixedPointAcceleration.fixed_point_new_input",
    "category": "function",
    "text": "This function takes the previous inputs and outputs from the fixed_point function and determines what vector to try next in seeking a fixed point.\n\nTakes\n\nInputs - This is an N x A matrix of previous inputs for which corresponding outputs are available. In this case N is the dimensionality of the fixed point vector that is being sought (Hence each column is a matrix that is input to the \"Function\") and A is the number of previous Inputs/Outputs that are being provided to the fixed point.\nOutputs - This is a matrix of Function values for the each column of the \"Inputs\" matrix.\nAlgorithm - This is the fixed point Algorithm to be used. It can be \"Anderson\", \"Simple\", \"Aitken\", \"Newton\", \"MPE\", \"RRE\", \"VEA\", \"SEA\".\nMaxM - This is the number of saved iterates that are used in the Anderson algorithm. This has no role if another Algorithm is used.\nSimpleStartIndex - This is the index for what column in the input/output matrices did the algorithm start doing simple iterates without jumps. This is used for all Algorithms except the simple and Anderson Algorithms where it has no effect.\nExtrapolationPeriod - This is the number of simple iterates to perform before extrapolating. This is used for the MPE, RRE, VEA and SEA Algorithms and has no effect if another Algorithm is chosen.\nDampening - This is the dampening parameter. By default it is 1 which means no dampening takes place. It can also be less than 1 (indicating dampening) or more than 1 (indicating extrapolation).\nConditionNumberThreshold - This is what threshold should be chosen to drop previous iterates if the matrix is ill conditioned. Only used in Anderson acceleration.\nPrintReports - This is a boolean describing whether to print ongoing ConvergenceMetric values for each iterate.\n\nReturns\n\nA nicely formatted string version of the input number for printing to the console.\n\nExamples\n\nFPFunction = function(x){c(0.5sqrt(abs(x[1] + x[2])), 1.5x[1] + 0.5*x[2])} A = fixedpoint( Function = FPFunction, Inputs = [0.3,900], MaxIter = 6, Algorithm = Simple) NewGuessAnderson = fixedpointnewinput(A[:Inputs], A[:Outputs], Algorithm = Anderson) NewGuessVEA = fixedpointnewinput(A[:Inputs], A[:Outputs], Algorithm = VEA) NewGuessMPE = fixedpointnewinput(A[:Inputs], A[:Outputs], Algorithm = MPE) NewGuessAitken = fixedpointnew_input(A[:Inputs], A[:Outputs], Algorithm = Aitken)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#FixedPointAcceleration.put_together_without_jumps",
    "page": "Docstrings",
    "title": "FixedPointAcceleration.put_together_without_jumps",
    "category": "function",
    "text": "This function takes the previous inputs and outputs and assembles a matrix with both excluding jumps.\n\nTakes\n\nInputs - This is an N x A matrix of previous inputs for which corresponding outputs are available. In this case N is the dimensionality of the fixed point vector that is being sought (and each column is a matrix that is input to the \"Function\") and A is the number of previous Inputs/Outputs that are being provided to the fixed point.\nOutputs This is a matrix of \"Function\" values for each column of the \"Inputs\" matrix.\nAgreementThreshold A parameter for determining when a column in Inputs and a column in Outputs match. They are deemed to match if the sum of the absolute values of the difference in the columns is less than AgreementThreshold.\n\nReturns\n\nA matrix of inputs and outputs excluding jumps.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#FixedPointAcceleration.EpsilonExtrapolation-Tuple{Array{Float64,2},FixedPointAccelerationAlgorithm}",
    "page": "Docstrings",
    "title": "FixedPointAcceleration.EpsilonExtrapolation",
    "category": "method",
    "text": "This is a helper function for EpsilonExtrapolation\n\nTakes\n\nIterates - A matrix representing different iterates with one iterate per column. Can be pieced together from Inputs and Outputs matrices of the fixedpoint function using the puttogetherwithoutjumps function\nAlgorithm - Algorithm for epsilon extrapolation. Should be either \"VEA\" for the vector extrapolation algorithm or \"SEA\" for the scalar epsilon algorithm.\n\nReturns\n\nA vector with the extrapolated vector.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#FixedPointAcceleration.EpsilonExtrapolationVectorOfInverses-Tuple{Array{Float64,2},FixedPointAccelerationAlgorithm}",
    "page": "Docstrings",
    "title": "FixedPointAcceleration.EpsilonExtrapolationVectorOfInverses",
    "category": "method",
    "text": "This is a helper function for EpsilonExtrapolation\n\nTakes\n\nDifferenceMatrix - The matrix of the differences in elements to be inverted.\nAlgorithm - SEA or VEA.\n\nReturns\n\nA vector of the result of inverting each (column) vector in a mmatrix.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#FixedPointAcceleration.PolynomialExtrapolation-Tuple{Array{Float64,2},FixedPointAccelerationAlgorithm}",
    "page": "Docstrings",
    "title": "FixedPointAcceleration.PolynomialExtrapolation",
    "category": "method",
    "text": "This function performs Minimal Polynomial extrapolation (MPE) or Reduced Rank Extrapolation (RRE) given a matrix of previous iterates of the function.\n\nTakes\n\nIterates - A matrix of inputs and outputs excluding jumps. Can be pieced together from Inputs and Outputs matrices of the fixedpoint function using the puttogetherwithoutjumps function\nAlgorithm The Algorithm for polynomial extrapolation. Should be either \"MPE\" for minimal polynomial extrapolation or \"RRE\" for reduced rank extrapolation.\n\nReturns\n\nA vector containing the extrapolated vector.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [FixedPointAcceleration]\nOrder = [:type, :function]"
},

]}
