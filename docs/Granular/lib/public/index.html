<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · Granular.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Granular.jl logo"/></a><h1>Granular.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/installation/">Installation</a></li><li><a class="toctext" href="../../man/package_contents/">Package contents</a></li><li><a class="toctext" href="../../man/methods/">Computational methods</a></li><li><a class="toctext" href="../../man/getting_started/">Getting started</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href>Public API</a><ul class="internal"><li><a class="toctext" href="#main-index-1">Index</a></li><li><a class="toctext" href="#Public-Interface-1">Public Interface</a></li></ul></li><li><a class="toctext" href="../internals/">Internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Public API</a></li></ul></nav><hr/><div id="topbar"><span>Public API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Public-API-documentation-1" href="#Public-API-documentation-1">Public API documentation</a></h1><p>Documentation for <code>Granular.jl</code>&#39;s public interface.</p><p>See <a href="../internals/#Package-internal-documentation-1">Package-internal documentation</a> for internal package docs.</p><h2><a class="nav-anchor" id="main-index-1" href="#main-index-1">Index</a></h2><ul><li><a href="#Granular.Granular"><code>Granular.Granular</code></a></li><li><a href="#Granular.addAtmosphereDrag!-Tuple{Granular.Simulation}"><code>Granular.addAtmosphereDrag!</code></a></li><li><a href="#Granular.addBodyForce!-Tuple{Granular.GrainCylindrical,Array{Float64,1}}"><code>Granular.addBodyForce!</code></a></li><li><a href="#Granular.addGrain!"><code>Granular.addGrain!</code></a></li><li><a href="#Granular.addGrainCylindrical!-Tuple{Granular.Simulation,Array{Float64,1},Float64,Float64}"><code>Granular.addGrainCylindrical!</code></a></li><li><a href="#Granular.addOceanDrag!-Tuple{Granular.Simulation}"><code>Granular.addOceanDrag!</code></a></li><li><a href="#Granular.addWall!"><code>Granular.addWall!</code></a></li><li><a href="#Granular.addWallLinearFrictionless!-Tuple{Granular.Simulation,Array{Float64,1},Float64}"><code>Granular.addWallLinearFrictionless!</code></a></li><li><a href="#Granular.applyAtmosphereDragToGrain!-Tuple{Granular.GrainCylindrical,Float64,Float64}"><code>Granular.applyAtmosphereDragToGrain!</code></a></li><li><a href="#Granular.applyAtmosphereVorticityToGrain!-Tuple{Granular.GrainCylindrical,Float64}"><code>Granular.applyAtmosphereVorticityToGrain!</code></a></li><li><a href="#Granular.applyOceanDragToGrain!-Tuple{Granular.GrainCylindrical,Float64,Float64}"><code>Granular.applyOceanDragToGrain!</code></a></li><li><a href="#Granular.applyOceanVorticityToGrain!-Tuple{Granular.GrainCylindrical,Float64}"><code>Granular.applyOceanVorticityToGrain!</code></a></li><li><a href="#Granular.areaOfQuadrilateral-NTuple{4,Array{Float64,1}}"><code>Granular.areaOfQuadrilateral</code></a></li><li><a href="#Granular.areaOfTriangle-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}"><code>Granular.areaOfTriangle</code></a></li><li><a href="#Granular.checkAndAddContact!"><code>Granular.checkAndAddContact!</code></a></li><li><a href="#Granular.checkForContacts-Tuple{Granular.Simulation,Any,Array{Float64,1},Float64}"><code>Granular.checkForContacts</code></a></li><li><a href="#Granular.checkTimeParameters-Tuple{Granular.Simulation}"><code>Granular.checkTimeParameters</code></a></li><li><a href="#Granular.compareAtmospheres-Tuple{Granular.Atmosphere,Granular.Atmosphere}"><code>Granular.compareAtmospheres</code></a></li><li><a href="#Granular.compareGrains-Tuple{Granular.GrainCylindrical,Granular.GrainCylindrical}"><code>Granular.compareGrains</code></a></li><li><a href="#Granular.compareOceans-Tuple{Granular.Ocean,Granular.Ocean}"><code>Granular.compareOceans</code></a></li><li><a href="#Granular.compareSimulations-Tuple{Granular.Simulation,Granular.Simulation}"><code>Granular.compareSimulations</code></a></li><li><a href="#Granular.conformalQuadrilateralCoordinates-NTuple{5,Array{Float64,1}}"><code>Granular.conformalQuadrilateralCoordinates</code></a></li><li><a href="#Granular.convertGrainDataToArrays-Tuple{Granular.Simulation}"><code>Granular.convertGrainDataToArrays</code></a></li><li><a href="#Granular.createEmptyAtmosphere-Tuple{}"><code>Granular.createEmptyAtmosphere</code></a></li><li><a href="#Granular.createEmptyOcean-Tuple{}"><code>Granular.createEmptyOcean</code></a></li><li><a href="#Granular.createRegularAtmosphereGrid-Tuple{Array{Int64,1},Array{Float64,1}}"><code>Granular.createRegularAtmosphereGrid</code></a></li><li><a href="#Granular.createRegularOceanGrid-Tuple{Array{Int64,1},Array{Float64,1}}"><code>Granular.createRegularOceanGrid</code></a></li><li><a href="#Granular.createSimulation-Tuple{}"><code>Granular.createSimulation</code></a></li><li><a href="#Granular.disableAtmosphereDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.disableAtmosphereDrag!</code></a></li><li><a href="#Granular.disableGrain!-Tuple{Granular.Simulation,Int64}"><code>Granular.disableGrain!</code></a></li><li><a href="#Granular.disableOceanDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.disableOceanDrag!</code></a></li><li><a href="#Granular.disableOutputFiles!-Tuple{Granular.Simulation}"><code>Granular.disableOutputFiles!</code></a></li><li><a href="#Granular.enableAtmosphereDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.enableAtmosphereDrag!</code></a></li><li><a href="#Granular.enableOceanDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.enableOceanDrag!</code></a></li><li><a href="#Granular.findCellContainingPoint"><code>Granular.findCellContainingPoint</code></a></li><li><a href="#Granular.findContacts!-Tuple{Granular.Simulation}"><code>Granular.findContacts!</code></a></li><li><a href="#Granular.findContactsAllToAll!-Tuple{Granular.Simulation}"><code>Granular.findContactsAllToAll!</code></a></li><li><a href="#Granular.findContactsInGrid!-Tuple{Granular.Simulation,Any}"><code>Granular.findContactsInGrid!</code></a></li><li><a href="#Granular.findEmptyPositionInGridCell-Tuple{Granular.Simulation,Any,Int64,Int64,Float64}"><code>Granular.findEmptyPositionInGridCell</code></a></li><li><a href="#Granular.findLargestGrainStiffness-Tuple{Granular.Simulation}"><code>Granular.findLargestGrainStiffness</code></a></li><li><a href="#Granular.findSmallestGrainMass-Tuple{Granular.Simulation}"><code>Granular.findSmallestGrainMass</code></a></li><li><a href="#Granular.fitGridToGrains!-Tuple{Granular.Simulation,Any}"><code>Granular.fitGridToGrains!</code></a></li><li><a href="#Granular.getCellCenterCoordinates-Tuple{Array{Float64,2},Array{Float64,2},Int64,Int64}"><code>Granular.getCellCenterCoordinates</code></a></li><li><a href="#Granular.getCellCornerCoordinates-Tuple{Array{Float64,2},Array{Float64,2},Int64,Int64}"><code>Granular.getCellCornerCoordinates</code></a></li><li><a href="#Granular.getGridCornerCoordinates-Tuple{Array{Float64,2},Array{Float64,2}}"><code>Granular.getGridCornerCoordinates</code></a></li><li><a href="#Granular.getNonDimensionalCellCoordinates-Tuple{Any,Int64,Int64,Array{Float64,1}}"><code>Granular.getNonDimensionalCellCoordinates</code></a></li><li><a href="#Granular.getWallNormalStress-Tuple{Granular.Simulation}"><code>Granular.getWallNormalStress</code></a></li><li><a href="#Granular.getWallSurfaceArea-Tuple{Granular.Simulation,Integer}"><code>Granular.getWallSurfaceArea</code></a></li><li><a href="#Granular.grainCircumreference-Tuple{Granular.GrainCylindrical}"><code>Granular.grainCircumreference</code></a></li><li><a href="#Granular.grainHorizontalSurfaceArea-Tuple{Granular.GrainCylindrical}"><code>Granular.grainHorizontalSurfaceArea</code></a></li><li><a href="#Granular.grainKineticRotationalEnergy-Tuple{Granular.GrainCylindrical}"><code>Granular.grainKineticRotationalEnergy</code></a></li><li><a href="#Granular.grainKineticTranslationalEnergy-Tuple{Granular.GrainCylindrical}"><code>Granular.grainKineticTranslationalEnergy</code></a></li><li><a href="#Granular.grainMass-Tuple{Granular.GrainCylindrical}"><code>Granular.grainMass</code></a></li><li><a href="#Granular.grainMomentOfInertia-Tuple{Granular.GrainCylindrical}"><code>Granular.grainMomentOfInertia</code></a></li><li><a href="#Granular.grainSideSurfaceArea-Tuple{Granular.GrainCylindrical}"><code>Granular.grainSideSurfaceArea</code></a></li><li><a href="#Granular.grainThermalEnergy-Tuple{Granular.GrainCylindrical}"><code>Granular.grainThermalEnergy</code></a></li><li><a href="#Granular.grainVolume-Tuple{Granular.GrainCylindrical}"><code>Granular.grainVolume</code></a></li><li><a href="#Granular.harmonicMean-Tuple{Number,Number}"><code>Granular.harmonicMean</code></a></li><li><a href="#Granular.incrementCurrentTime!-Tuple{Granular.Simulation,Float64}"><code>Granular.incrementCurrentTime!</code></a></li><li><a href="#Granular.interGrainPositionVector-Tuple{Granular.Simulation,Int64,Int64}"><code>Granular.interGrainPositionVector</code></a></li><li><a href="#Granular.interact!-Tuple{Granular.Simulation}"><code>Granular.interact!</code></a></li><li><a href="#Granular.interactGrains!-Tuple{Granular.Simulation,Int64,Int64,Int64}"><code>Granular.interactGrains!</code></a></li><li><a href="#Granular.interpolateAtmosphereState-Tuple{Granular.Atmosphere,Float64}"><code>Granular.interpolateAtmosphereState</code></a></li><li><a href="#Granular.interpolateOceanState-Tuple{Granular.Ocean,Float64}"><code>Granular.interpolateOceanState</code></a></li><li><a href="#Granular.interpolateOceanVelocitiesToCorners-Tuple{Array{Float64,4},Array{Float64,4}}"><code>Granular.interpolateOceanVelocitiesToCorners</code></a></li><li><a href="#Granular.irregularPacking!-Tuple{Granular.Simulation}"><code>Granular.irregularPacking!</code></a></li><li><a href="#Granular.isPointInCell"><code>Granular.isPointInCell</code></a></li><li><a href="#Granular.isPointInGrid"><code>Granular.isPointInGrid</code></a></li><li><a href="#Granular.plotGrainSizeDistribution-Tuple{Granular.Simulation}"><code>Granular.plotGrainSizeDistribution</code></a></li><li><a href="#Granular.plotGrains-Tuple{Granular.Simulation}"><code>Granular.plotGrains</code></a></li><li><a href="#Granular.printGrainInfo-Tuple{Granular.GrainCylindrical}"><code>Granular.printGrainInfo</code></a></li><li><a href="#Granular.printMemoryUsage-Tuple{Granular.Simulation}"><code>Granular.printMemoryUsage</code></a></li><li><a href="#Granular.randpower"><code>Granular.randpower</code></a></li><li><a href="#Granular.readOceanGridNetCDF-Tuple{String}"><code>Granular.readOceanGridNetCDF</code></a></li><li><a href="#Granular.readOceanNetCDF-Tuple{String,String}"><code>Granular.readOceanNetCDF</code></a></li><li><a href="#Granular.readOceanStateNetCDF-Tuple{String}"><code>Granular.readOceanStateNetCDF</code></a></li><li><a href="#Granular.readSimulation-Tuple{String}"><code>Granular.readSimulation</code></a></li><li><a href="#Granular.readSimulation-Tuple{Granular.Simulation}"><code>Granular.readSimulation</code></a></li><li><a href="#Granular.readSimulationStatus-Tuple{String}"><code>Granular.readSimulationStatus</code></a></li><li><a href="#Granular.reflectGrainsFromImpermeableBoundaries!-Tuple{Granular.Simulation}"><code>Granular.reflectGrainsFromImpermeableBoundaries!</code></a></li><li><a href="#Granular.regularPacking!-Tuple{Granular.Simulation,Array{Int64,1},Real,Real}"><code>Granular.regularPacking!</code></a></li><li><a href="#Granular.removeSimulationFiles-Tuple{Granular.Simulation}"><code>Granular.removeSimulationFiles</code></a></li><li><a href="#Granular.render-Tuple{Granular.Simulation}"><code>Granular.render</code></a></li><li><a href="#Granular.reportGridBoundaryConditions-Tuple{Any}"><code>Granular.reportGridBoundaryConditions</code></a></li><li><a href="#Granular.reportSimulationTimeToStdout-Tuple{Granular.Simulation}"><code>Granular.reportSimulationTimeToStdout</code></a></li><li><a href="#Granular.resetTime!-Tuple{Granular.Simulation}"><code>Granular.resetTime!</code></a></li><li><a href="#Granular.run!-Tuple{Granular.Simulation}"><code>Granular.run!</code></a></li><li><a href="#Granular.setBodyForce!-Tuple{Granular.GrainCylindrical,Array{Float64,1}}"><code>Granular.setBodyForce!</code></a></li><li><a href="#Granular.setCurrentTime!-Tuple{Granular.Simulation,Float64}"><code>Granular.setCurrentTime!</code></a></li><li><a href="#Granular.setGridBoundaryConditions!"><code>Granular.setGridBoundaryConditions!</code></a></li><li><a href="#Granular.setMaximumNumberOfContactsPerGrain!-Tuple{Granular.Simulation,Int64}"><code>Granular.setMaximumNumberOfContactsPerGrain!</code></a></li><li><a href="#Granular.setOutputFileInterval!-Tuple{Granular.Simulation,Float64}"><code>Granular.setOutputFileInterval!</code></a></li><li><a href="#Granular.setTimeStep!-Tuple{Granular.Simulation}"><code>Granular.setTimeStep!</code></a></li><li><a href="#Granular.setTotalTime!-Tuple{Granular.Simulation,Float64}"><code>Granular.setTotalTime!</code></a></li><li><a href="#Granular.sortGrainsInGrid!-Tuple{Granular.Simulation,Any}"><code>Granular.sortGrainsInGrid!</code></a></li><li><a href="#Granular.status"><code>Granular.status</code></a></li><li><a href="#Granular.totalGrainKineticRotationalEnergy-Tuple{Granular.Simulation}"><code>Granular.totalGrainKineticRotationalEnergy</code></a></li><li><a href="#Granular.totalGrainKineticTranslationalEnergy-Tuple{Granular.Simulation}"><code>Granular.totalGrainKineticTranslationalEnergy</code></a></li><li><a href="#Granular.totalGrainThermalEnergy-Tuple{Granular.Simulation}"><code>Granular.totalGrainThermalEnergy</code></a></li><li><a href="#Granular.updateGrainKinematics!-Tuple{Granular.Simulation}"><code>Granular.updateGrainKinematics!</code></a></li><li><a href="#Granular.updateGrainKinematicsThreeTermTaylor!-Tuple{Granular.GrainCylindrical,Granular.Simulation}"><code>Granular.updateGrainKinematicsThreeTermTaylor!</code></a></li><li><a href="#Granular.updateGrainKinematicsTwoTermTaylor!-Tuple{Granular.GrainCylindrical,Granular.Simulation}"><code>Granular.updateGrainKinematicsTwoTermTaylor!</code></a></li><li><a href="#Granular.updateWallKinematics!-Tuple{Granular.Simulation}"><code>Granular.updateWallKinematics!</code></a></li><li><a href="#Granular.updateWallKinematicsThreeTermTaylor!-Tuple{Granular.WallLinearFrictionless,Granular.Simulation}"><code>Granular.updateWallKinematicsThreeTermTaylor!</code></a></li><li><a href="#Granular.updateWallKinematicsTwoTermTaylor!-Tuple{Granular.WallLinearFrictionless,Granular.Simulation}"><code>Granular.updateWallKinematicsTwoTermTaylor!</code></a></li><li><a href="#Granular.vecTo3d-Tuple{Any}"><code>Granular.vecTo3d</code></a></li><li><a href="#Granular.writeGrainInteractionVTK-Tuple{Granular.Simulation,String}"><code>Granular.writeGrainInteractionVTK</code></a></li><li><a href="#Granular.writeGrainVTK-Tuple{Granular.Simulation,String}"><code>Granular.writeGrainVTK</code></a></li><li><a href="#Granular.writeParaviewPythonScript-Tuple{Granular.Simulation}"><code>Granular.writeParaviewPythonScript</code></a></li><li><a href="#Granular.writeSimulation-Tuple{Granular.Simulation}"><code>Granular.writeSimulation</code></a></li><li><a href="#Granular.writeSimulationStatus-Tuple{Granular.Simulation}"><code>Granular.writeSimulationStatus</code></a></li><li><a href="#Granular.writeVTK-Tuple{Granular.Simulation}"><code>Granular.writeVTK</code></a></li><li><a href="#Granular.zeroForcesAndTorques!-Tuple{Granular.Simulation}"><code>Granular.zeroForcesAndTorques!</code></a></li><li><a href="#Granular.zeroKinematics!-Tuple{Granular.Simulation}"><code>Granular.zeroKinematics!</code></a></li></ul><h2><a class="nav-anchor" id="Public-Interface-1" href="#Public-Interface-1">Public Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.Granular" href="#Granular.Granular"><code>Granular.Granular</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p><strong>Granular.jl</strong></p><p>Offline granular dynamics simulator module.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.addAtmosphereDrag!-Tuple{Granular.Simulation}" href="#Granular.addAtmosphereDrag!-Tuple{Granular.Simulation}"><code>Granular.addAtmosphereDrag!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Add drag from linear and angular velocity difference between atmosphere and all  grains.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.addBodyForce!-Tuple{Granular.GrainCylindrical,Array{Float64,1}}" href="#Granular.addBodyForce!-Tuple{Granular.GrainCylindrical,Array{Float64,1}}"><code>Granular.addBodyForce!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setBodyForce!(grain, force)</code></pre><p>Add to the value of the external body force on a grain.</p><p><strong>Arguments</strong></p><ul><li><code>grain::GrainCylindrical</code>: the grain to set the body force for.</li><li><code>force::Vector{Float64}</code>: a vector of force [N]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.addGrain!" href="#Granular.addGrain!"><code>Granular.addGrain!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">addGrain!(simulation::Simulation,
          grain::GrainCylindrical,
          verbose::Bool = false)</code></pre><p>Add an <code>grain</code> to the <code>simulation</code> object.  If <code>verbose</code> is true, a short  confirmation message will be printed to stdout.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.addGrainCylindrical!-Tuple{Granular.Simulation,Array{Float64,1},Float64,Float64}" href="#Granular.addGrainCylindrical!-Tuple{Granular.Simulation,Array{Float64,1},Float64,Float64}"><code>Granular.addGrainCylindrical!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function addGrainCylindrical!(simulation, lin_pos, contact_radius,
                                thickness[, areal_radius, lin_vel, lin_acc,
                                force, ang_pos, ang_vel, ang_acc, torque,
                                density, contact_stiffness_normal,
                                contact_stiffness_tangential,
                                contact_viscosity_normal,
                                contact_viscosity_tangential,
                                contact_static_friction,
                                contact_dynamic_friction,
                                youngs_modulus, poissons_ratio,
                                tensile_strength, shear_strength,
                                strength_heal_rate,
                                fracture_toughness,
                                ocean_drag_coeff_vert,
                                ocean_drag_coeff_horiz,
                                atmosphere_drag_coeff_vert,
                                atmosphere_drag_coeff_horiz,
                                pressure, fixed,
                                allow_x_acc, allow_y_acc, allow_z_acc,
                                rotating, enabled, verbose,
                                ocean_grid_pos, atmosphere_grid_pos,
                                n_contact, granular_stress, ocean_stress,
                                atmosphere_stress,
                                thermal_energy,
                                color])</code></pre><p>Creates and adds a cylindrical grain to a simulation. Most of the arguments  are optional, and come with default values.  The only required arguments are  <code>simulation</code>, <code>lin_pos</code>, <code>contact_radius</code>, and <code>thickness</code>.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation object where the grain should be   added to.</li><li><code>lin_pos::Vector{Float64}</code>: linear position of grain center [m]. If a   two-component vector is used, the values will be mapped to <em>x</em> and <em>y</em>, and   the <em>z</em> component will be set to zero.</li><li><code>contact_radius::Float64</code>: grain radius for granular interaction [m].</li><li><code>thickness::Float64</code>: grain thickness [m].</li><li><code>areal_radius = false</code>: grain radius for determining sea-ice concentration   [m].</li><li><code>lin_vel::Vector{Float64} = [0., 0., 0.]</code>: linear velocity [m/s]. If a   two-component vector is used, the values will be mapped to <em>x</em> and <em>y</em>, and   the <em>z</em> component will be set to zero.</li><li><code>lin_acc::Vector{Float64} = [0., 0., 0.]</code>: linear acceleration [m/s^2]. If a   two-component vector is used, the values will be mapped to <em>x</em> and <em>y</em>, and   the <em>z</em> component will be set to zero.</li><li><code>force::Vector{Float64} = [0., 0., 0.]</code>: linear force balance [N]. If a   two-component vector is used, the values will be mapped to <em>x</em> and <em>y</em>, and   the <em>z</em> component will be set to zero.</li><li><code>ang_pos::Float64 = [0., 0., 0.]</code>: angular position around its center vertical   axis [rad]. If a scalar is used, the value will be mapped to <em>z</em>, and the   <em>x</em> and <em>y</em> components will be set to zero.</li><li><code>ang_vel::Float64 = [0., 0., 0.]</code>: angular velocity around its center vertical   axis [rad/s]. If a scalar is used, the value will be mapped to <em>z</em>, and the   <em>x</em> and <em>y</em> components will be set to zero.</li><li><code>ang_acc::Float64 = [0., 0., 0.]</code>: angular acceleration around its center   vertical axis [rad/s^2]. If a scalar is used, the value will be mapped to   <em>z</em>, and the <em>x</em> and <em>y</em> components will be set to zero.</li><li><code>torque::Float64 = [0., 0., 0.]</code>: torque around its center vertical axis   [N<em>m]. If a scalar is used, the value will be mapped to *z</em>, and the <em>x</em> and   <em>y</em> components will be set to zero.</li><li><code>density::Float64 = 934.</code>: grain mean density [kg/m^3].</li><li><code>contact_stiffness_normal::Float64 = 1e7</code>: contact-normal stiffness [N/m];   overridden if <code>youngs_modulus</code> is set to a positive value.</li><li><code>contact_stiffness_tangential::Float64 = 0.</code>: contact-tangential stiffness   [N/m]; overridden if <code>youngs_modulus</code> is set to a positive value.</li><li><code>contact_viscosity_normal::Float64 = 0.</code>: contact-normal viscosity [N/m/s].</li><li><code>contact_viscosity_tangential::Float64 = 0.</code>: contact-tangential viscosity   [N/m/s].</li><li><code>contact_static_friction::Float64 = 0.4</code>: contact static Coulomb frictional   coefficient [-].</li><li><code>contact_dynamic_friction::Float64 = 0.4</code>: contact dynamic Coulomb frictional   coefficient [-].</li><li><code>youngs_modulus::Float64 = 2e7</code>: elastic modulus [Pa]; overrides any value   set for <code>contact_stiffness_normal</code>.</li><li><code>poissons_ratio::Float64 = 0.185</code>: Poisson&#39;s ratio, used to determine the   contact-tangential stiffness from <code>youngs_modulus</code> [-].</li><li><code>tensile_strength::Float64 = 0.</code>: contact-tensile (cohesive) bond strength   [Pa].</li><li><code>shear_strength::Float64 = 0.</code>: shear strength of bonded contacts [Pa].</li><li><code>strength_heal_rate::Float64 = 0.</code>: rate at which contact bond   strength is obtained [Pa/s].</li><li><code>fracture_toughness::Float64 = 0.</code>: fracture toughness which influences the    maximum compressive strength on granular contact [m^{1/2}<em>Pa]. A value   of 1.285e3 m^{1/2}</em>Pa is used for sea ice by Hopkins 2004.</li><li><code>ocean_drag_coeff_vert::Float64 = 0.85</code>: vertical drag coefficient for ocean   against grain sides [-].</li><li><code>ocean_drag_coeff_horiz::Float64 = 5e-4</code>: horizontal drag coefficient for   ocean against grain bottom [-].</li><li><code>atmosphere_drag_coeff_vert::Float64 = 0.4</code>: vertical drag coefficient for   atmosphere against grain sides [-].</li><li><code>atmosphere_drag_coeff_horiz::Float64 = 2.5e-4</code>: horizontal drag coefficient   for atmosphere against grain bottom [-].</li><li><code>pressure::Float64 = 0.</code>: current compressive stress on grain [Pa].</li><li><code>fixed::Bool = false</code>: grain is fixed to a constant velocity (e.g. zero).</li><li><code>allow_x_acc::Bool = false</code>: override <code>fixed</code> along <code>x</code>.</li><li><code>allow_y_acc::Bool = false</code>: override <code>fixed</code> along <code>y</code>.</li><li><code>allow_z_acc::Bool = false</code>: override <code>fixed</code> along <code>z</code>.</li><li><code>rotating::Bool = true</code>: grain is allowed to rotate.</li><li><code>enabled::Bool = true</code>: grain interacts with other grains.</li><li><code>verbose::Bool = true</code>: display diagnostic information during the function   call.</li><li><code>ocean_grid_pos::Array{Int, 1} = [0, 0]</code>: position of grain in the ocean   grid.</li><li><code>atmosphere_grid_pos::Array{Int, 1} = [0, 0]</code>: position of grain in the   atmosphere grid.</li><li><code>n_contacts::Int = 0</code>: number of contacts with other grains.</li><li><code>granular_stress::Vector{Float64} = [0., 0., 0.]</code>: resultant stress on grain   from granular interactions [Pa].</li><li><code>ocean_stress::Vector{Float64} = [0., 0., 0.]</code>: resultant stress on grain from   ocean drag [Pa].</li><li><code>atmosphere_stress::Vector{Float64} = [0., 0., 0.]</code>: resultant stress on grain   from atmosphere drag [Pa].</li><li><code>thermal_energy::Float64 = 0.0</code>: thermal energy of grain [J].</li><li><code>color::Int=0</code>: type number, usually used for associating a color to the grain   during visualization.</li></ul><p><strong>Examples</strong></p><p>The most basic example adds a new grain to the simulation <code>sim</code>, with a  center at <code>[1., 2., 0.]</code>, a radius of <code>1.</code> meter, and a thickness of <code>0.5</code>  meter:</p><pre><code class="language-julia">Granular.addGrainCylindrical!(sim, [1., 2.], 1., .5)</code></pre><p>Note that the <em>z</em> component is set to zero if a two-component vector is passed.</p><p>The following example will create a grain with tensile and shear strength, and a velocity of 0.5 m/s towards -x:</p><pre><code class="language-julia">Granular.addGrainCylindrical!(sim, [4., 2.], 1., .5,
                              tensile_strength = 200e3,
                              shear_strength = 100e3,
                              lin_vel = [-.5, 0.])</code></pre><p>Fixed grains are useful for creating walls or coasts, and loops are useful for creating regular arrangements:</p><pre><code class="language-julia">for i=1:5
    Granular.addGrainCylindrical!(sim, [i*2., 0., 3.], 1., .5, fixed=true)
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.addOceanDrag!-Tuple{Granular.Simulation}" href="#Granular.addOceanDrag!-Tuple{Granular.Simulation}"><code>Granular.addOceanDrag!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Add drag from linear and angular velocity difference between ocean and all ice  floes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.addWall!" href="#Granular.addWall!"><code>Granular.addWall!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">addWall!(simulation::Simulation,
         wall::WallLinearFrictionless,
         verbose::Bool = false)</code></pre><p>Add an <code>wall</code> to the <code>simulation</code> object.  If <code>verbose</code> is true, a short  confirmation message will be printed to stdout.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.addWallLinearFrictionless!-Tuple{Granular.Simulation,Array{Float64,1},Float64}" href="#Granular.addWallLinearFrictionless!-Tuple{Granular.Simulation,Array{Float64,1},Float64}"><code>Granular.addWallLinearFrictionless!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function addWallLinear!(simulation, normal, pos[, bc, mass, thickness, 
                        normal_stress, vel, acc, force,
                        contact_viscosity_normal, verbose])</code></pre><p>Creates and adds a linear (flat) and frictionless dynamic wall to a grain to a simulation. Most of the arguments are optional, and come with default values. The only required arguments are  <code>simulation</code>, <code>normal</code>, <code>pos</code>, and <code>bc</code>.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation object where the wall should be   added to.</li><li><code>normal::Vector{Float64}</code>: 3d vector denoting the normal to the wall [m].  The   wall will only interact in the opposite direction of this vector, so the   normal vector should point in the direction of the grains. If a 2d vector is   passed, the third (z) component is set to zero.</li><li><code>pos::Float64</code>: position along axis parallel to the normal vector [m].</li><li><code>bc::String=&quot;fixed&quot;</code>: boundary condition, possible values are <code>&quot;fixed&quot;</code>   (default), <code>&quot;normal stress&quot;</code>, or <code>&quot;velocity&quot;</code>.</li><li><code>mass::Float64=NaN</code>: wall mass, which is used if wall boundary conditions   differs from <code>bc=&quot;fixed&quot;</code>.  If the parameter is left to its default value,   the wall mass is set to be equal the total mass of grains in the simulation.   Units: [kg]</li><li><code>thickness::Float64=NaN</code>: wall thickness, which is used for determining wall   surface area.  If the parameter is left to its default value, the wall   thickness is set to be equal to the thickest grain in the simulation.   Units: [m].</li><li><code>normal_stress::Float64=0.</code>: the wall normal stress when <code>bc == &quot;normal   stress&quot;</code> [Pa].</li><li><code>vel::Float64=0.</code>: the wall velocity along the <code>normal</code> vector.  If the   wall boundary condition is <code>bc = &quot;velocity&quot;</code> the wall will move according to   this constant value.  If <code>bc = &quot;normal stress&quot;</code> the velocity will be a free   parameter. Units: [m/s]</li><li><code>force::Float64=0.</code>: sum of normal forces on the wall from interaction with   grains [N].</li><li><code>contact_viscosity_normal::Float64=0.</code>: viscosity to apply in parallel to   elasticity in interactions between wall and particles [N/(m/s)]. When this   term is larger than zero, the wall-grain interaction acts like a sink of   kinetic energy.</li><li><code>verbose::Bool=true</code>: show verbose information during function call.</li></ul><p><strong>Examples</strong></p><p>The most basic example adds a new fixed wall to the simulation <code>sim</code>, with a  wall-face normal of <code>[1., 0.]</code> (wall along <em>y</em> and normal to <em>x</em>), a position of <code>1.5</code> meter:</p><pre><code class="language-julia">Granular.addWallLinearFrictionless!(sim, [1., 0., 0.], 1.5)</code></pre><p>The following example creates a wall with a velocity of 0.5 m/s towards <em>-y</em>:</p><pre><code class="language-julia">Granular.addWallLinearFrictionless!(sim, [0., 1., 0.], 1.5,
                                    bc=&quot;velocity&quot;,
                                    vel=-0.5)</code></pre><p>To create a wall parallel to the <em>y</em> axis pushing downwards with a constant normal stress of 100 kPa, starting at a position of y = 3.5 m:</p><pre><code class="language-julia">Granular.addWallLinearFrictionless!(sim, [0., 1., 0.], 3.5,
                                    bc=&quot;normal stress&quot;,
                                    normal_stress=100e3)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.applyAtmosphereDragToGrain!-Tuple{Granular.GrainCylindrical,Float64,Float64}" href="#Granular.applyAtmosphereDragToGrain!-Tuple{Granular.GrainCylindrical,Float64,Float64}"><code>Granular.applyAtmosphereDragToGrain!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Add Stokes-type drag from velocity difference between atmosphere and a single  grain.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.applyAtmosphereVorticityToGrain!-Tuple{Granular.GrainCylindrical,Float64}" href="#Granular.applyAtmosphereVorticityToGrain!-Tuple{Granular.GrainCylindrical,Float64}"><code>Granular.applyAtmosphereVorticityToGrain!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Add Stokes-type torque from angular velocity difference between atmosphere and a  single grain.  See Eq. 9.28 in &quot;Introduction to Fluid Mechanics&quot; by Nakayama  and Boucher, 1999.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.applyOceanDragToGrain!-Tuple{Granular.GrainCylindrical,Float64,Float64}" href="#Granular.applyOceanDragToGrain!-Tuple{Granular.GrainCylindrical,Float64,Float64}"><code>Granular.applyOceanDragToGrain!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Add Stokes-type drag from velocity difference between ocean and a single ice  floe.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.applyOceanVorticityToGrain!-Tuple{Granular.GrainCylindrical,Float64}" href="#Granular.applyOceanVorticityToGrain!-Tuple{Granular.GrainCylindrical,Float64}"><code>Granular.applyOceanVorticityToGrain!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Add Stokes-type torque from angular velocity difference between ocean and a  single grain.  See Eq. 9.28 in &quot;Introduction to Fluid Mechanics&quot; by Nakayama  and Boucher, 1999.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.areaOfQuadrilateral-NTuple{4,Array{Float64,1}}" href="#Granular.areaOfQuadrilateral-NTuple{4,Array{Float64,1}}"><code>Granular.areaOfQuadrilateral</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the area of a quadrilateral with corner coordinates <code>a</code>, <code>b</code>, <code>c</code>, and  <code>d</code>.  Corners <code>a</code> and <code>c</code> should be opposite of each other, the same must be  true for <code>b</code> and <code>d</code>.  This is true if the four corners are passed as arguments  in a &quot;clockwise&quot; or &quot;counter-clockwise&quot; manner.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.areaOfTriangle-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}" href="#Granular.areaOfTriangle-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}"><code>Granular.areaOfTriangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the area of an triangle with corner coordinates <code>a</code>, <code>b</code>, and <code>c</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.checkAndAddContact!" href="#Granular.checkAndAddContact!"><code>Granular.checkAndAddContact!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">checkAndAddContact!(simulation, i, j)</code></pre><p>Check for contact between two grains and register the interaction in the  <code>simulation</code> object.  The indexes of the two grains is stored in  <code>simulation.contact_pairs</code> as <code>[i, j]</code>.  The overlap vector is parallel to a  straight line connecting the grain centers, points away from grain <code>i</code> and  towards <code>j</code>, and is stored in <code>simulation.overlaps</code>.  A zero-length vector is  written to <code>simulation.contact_parallel_displacement</code>.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation object containing the grains.</li><li><code>i::Int</code>: index of the first grain.</li><li><code>j::Int</code>: index of the second grain.</li><li><code>distance_Modifier::Vector{Float64}</code>: vector modifying percieved   inter-particle distance, which is used for contact search across periodic   boundaries.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.checkForContacts-Tuple{Granular.Simulation,Any,Array{Float64,1},Float64}" href="#Granular.checkForContacts-Tuple{Granular.Simulation,Any,Array{Float64,1},Float64}"><code>Granular.checkForContacts</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">checkForContacts(grid, position, radius)</code></pre><p>Perform an O(n*log(n)) cell-based contact search between a candidate grain with position <code>position</code> and <code>radius</code>, against all grains registered in the <code>grid</code>. Returns the number of contacts that were found as an <code>Integer</code> value, unless <code>return_when_overlap_found</code> is <code>true</code>.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: Simulation object containing grain positions.</li><li><code>grid::Any</code>: <code>Ocean</code> or <code>Atmosphere</code> grid containing sorted particles.</li><li><code>x_candidate::Vector{Float64}</code>: Candidate center position to probe for   contacts with existing grains [m].</li><li><code>r_candidate::Float64</code>: Candidate radius [m].</li><li><code>return_when_overlap_found::Bool</code> (default: <code>false</code>): Return <code>true</code> if no   contacts are found, or return <code>false</code> as soon as a contact is found.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.checkTimeParameters-Tuple{Granular.Simulation}" href="#Granular.checkTimeParameters-Tuple{Granular.Simulation}"><code>Granular.checkTimeParameters</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Checks if simulation temporal parameters are of reasonable values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.compareAtmospheres-Tuple{Granular.Atmosphere,Granular.Atmosphere}" href="#Granular.compareAtmospheres-Tuple{Granular.Atmosphere,Granular.Atmosphere}"><code>Granular.compareAtmospheres</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">compareAtmospheres(atmosphere1::atmosphere, atmosphere2::atmosphere)</code></pre><p>Compare values of two <code>atmosphere</code> objects using the <code>Base.Test</code> framework.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.compareGrains-Tuple{Granular.GrainCylindrical,Granular.GrainCylindrical}" href="#Granular.compareGrains-Tuple{Granular.GrainCylindrical,Granular.GrainCylindrical}"><code>Granular.compareGrains</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">compareGrains(if1::GrainCylindrical, if2::GrainCylindrical)</code></pre><p>Compare values of two grain objects using the <code>Base.Test</code> framework.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.compareOceans-Tuple{Granular.Ocean,Granular.Ocean}" href="#Granular.compareOceans-Tuple{Granular.Ocean,Granular.Ocean}"><code>Granular.compareOceans</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">compareOceans(ocean1::Ocean, ocean2::Ocean)</code></pre><p>Compare values of two <code>Ocean</code> objects using the <code>Base.Test</code> framework.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.compareSimulations-Tuple{Granular.Simulation,Granular.Simulation}" href="#Granular.compareSimulations-Tuple{Granular.Simulation,Granular.Simulation}"><code>Granular.compareSimulations</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">compareSimulations(sim1::Simulation, sim2::Simulation)</code></pre><p>Compare values of two <code>Simulation</code> objects using the <code>Base.Test</code> framework.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.conformalQuadrilateralCoordinates-NTuple{5,Array{Float64,1}}" href="#Granular.conformalQuadrilateralCoordinates-NTuple{5,Array{Float64,1}}"><code>Granular.conformalQuadrilateralCoordinates</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the non-dimensional coordinates <code>[x_tilde, y_tilde]</code> of a point <code>p</code>  within a quadrilateral with corner coordinates <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>. Points must be ordered in counter-clockwise order, starting from south-west  corner.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.convertGrainDataToArrays-Tuple{Granular.Simulation}" href="#Granular.convertGrainDataToArrays-Tuple{Granular.Simulation}"><code>Granular.convertGrainDataToArrays</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Gathers all grain parameters from the <code>GrainCylindrical</code> type in continuous  arrays in an <code>GrainArrays</code> structure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.createEmptyAtmosphere-Tuple{}" href="#Granular.createEmptyAtmosphere-Tuple{}"><code>Granular.createEmptyAtmosphere</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns empty ocean type for initialization purposes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.createEmptyOcean-Tuple{}" href="#Granular.createEmptyOcean-Tuple{}"><code>Granular.createEmptyOcean</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns empty ocean type for initialization purposes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.createRegularAtmosphereGrid-Tuple{Array{Int64,1},Array{Float64,1}}" href="#Granular.createRegularAtmosphereGrid-Tuple{Array{Int64,1},Array{Float64,1}}"><code>Granular.createRegularAtmosphereGrid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">createRegularAtmosphereGrid(n, L[, origo, time, name,
                            bc_west, bc_south, bc_east, bc_north])</code></pre><p>Initialize and return a regular, Cartesian <code>Atmosphere</code> grid with <code>n[1]</code> by <code>n[2]</code> cells in the horizontal dimension, and <code>n[3]</code> vertical cells.  The cell corner and center coordinates will be set according to the grid spatial dimensions <code>L[1]</code>, <code>L[2]</code>, and <code>L[3]</code>.  The grid <code>u</code>, <code>v</code>, <code>h</code>, and <code>e</code> fields will contain one 4-th dimension matrix per <code>time</code> step.  Sea surface will be at <code>z=0.</code> with the atmosphere spanning <code>z&lt;0.</code>.  Vertical indexing starts with <code>k=0</code> at the sea surface, and increases downwards.</p><p><strong>Arguments</strong></p><ul><li><code>n::Vector{Int}</code>: number of cells along each dimension [-].</li><li><code>L::Vector{Float64}</code>: domain length along each dimension [m].</li><li><code>origo::Vector{Float64}</code>: domain offset in each dimension <a href="lib/default =   `[0.0, 0.0]`">m</a>.</li><li><code>time::Vector{Float64}</code>: vector of time stamps for the grid [s].</li><li><code>name::String</code>: grid name (default = <code>&quot;unnamed&quot;</code>).</li><li><code>bc_west::Integer</code>: grid boundary condition for the grains.</li><li><code>bc_south::Integer</code>: grid boundary condition for the grains.</li><li><code>bc_east::Integer</code>: grid boundary condition for the grains.</li><li><code>bc_north::Integer</code>: grid boundary condition for the grains.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.createRegularOceanGrid-Tuple{Array{Int64,1},Array{Float64,1}}" href="#Granular.createRegularOceanGrid-Tuple{Array{Int64,1},Array{Float64,1}}"><code>Granular.createRegularOceanGrid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">createRegularOceanGrid(n, L[, origo, time, name,
                       bc_west, bc_south, bc_east, bc_north])</code></pre><p>Initialize and return a regular, Cartesian <code>Ocean</code> grid with <code>n[1]</code> by <code>n[2]</code>  cells in the horizontal dimension, and <code>n[3]</code> vertical cells.  The cell corner  and center coordinates will be set according to the grid spatial dimensions  <code>L[1]</code>, <code>L[2]</code>, and <code>L[3]</code>.  The grid <code>u</code>, <code>v</code>, <code>h</code>, and <code>e</code> fields will contain  one 4-th dimension matrix per <code>time</code> step.  Sea surface will be at <code>z=0.</code> with  the ocean spanning <code>z&lt;0.</code>.  Vertical indexing starts with <code>k=0</code> at the sea  surface, and increases downwards.</p><p><strong>Arguments</strong></p><ul><li><code>n::Vector{Int}</code>: number of cells along each dimension [-].</li><li><code>L::Vector{Float64}</code>: domain length along each dimension [m].</li><li><code>origo::Vector{Float64}</code>: domain offset in each dimension <a href="lib/default =   `[0.0, 0.0]`">m</a>.</li><li><code>time::Vector{Float64}</code>: vector of time stamps for the grid [s].</li><li><code>name::String</code>: grid name (default = <code>&quot;unnamed&quot;</code>).</li><li><code>bc_west::Integer</code>: grid boundary condition for the grains.</li><li><code>bc_south::Integer</code>: grid boundary condition for the grains.</li><li><code>bc_east::Integer</code>: grid boundary condition for the grains.</li><li><code>bc_north::Integer</code>: grid boundary condition for the grains.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.createSimulation-Tuple{}" href="#Granular.createSimulation-Tuple{}"><code>Granular.createSimulation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">createSimulation([id])</code></pre><p>Create a simulation object to contain all relevant variables such as temporal  parameters, fluid grids, grains, and contacts.  The parameter <code>id</code> is used to uniquely identify the simulation when it is written to disk.</p><p>The function returns a <code>Simulation</code> object, which you can add grains to, e.g. with <a href="#Granular.addGrainCylindrical!-Tuple{Granular.Simulation,Array{Float64,1},Float64,Float64}"><code>addGrainCylindrical!</code></a>.</p><p><strong>Optional argument</strong></p><ul><li><code>id::String=&quot;unnamed&quot;</code>: simulation identifying string.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.disableAtmosphereDrag!-Tuple{Granular.GrainCylindrical}" href="#Granular.disableAtmosphereDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.disableAtmosphereDrag!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">disableAtmosphereDrag!(grain)</code></pre><p>Disable atmosphere-caused drag on the grain.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.disableGrain!-Tuple{Granular.Simulation,Int64}" href="#Granular.disableGrain!-Tuple{Granular.Simulation,Int64}"><code>Granular.disableGrain!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Disable grain with index <code>i</code> in the <code>simulation</code> object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.disableOceanDrag!-Tuple{Granular.GrainCylindrical}" href="#Granular.disableOceanDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.disableOceanDrag!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">disableOceanDrag!(grain)</code></pre><p>Disable ocean-caused drag on the grain.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.disableOutputFiles!-Tuple{Granular.Simulation}" href="#Granular.disableOutputFiles!-Tuple{Granular.Simulation}"><code>Granular.disableOutputFiles!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Disables the write of output files to disk during a simulation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.enableAtmosphereDrag!-Tuple{Granular.GrainCylindrical}" href="#Granular.enableAtmosphereDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.enableAtmosphereDrag!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">enableAtmosphereDrag!(grain)</code></pre><p>Enable atmosphere-caused drag on the grain, with values by Hunke and Comeau (2011).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.enableOceanDrag!-Tuple{Granular.GrainCylindrical}" href="#Granular.enableOceanDrag!-Tuple{Granular.GrainCylindrical}"><code>Granular.enableOceanDrag!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">enableOceanDrag!(grain)</code></pre><p>Enable ocean-caused drag on the grain, with values by Hunke and Comeau (2011).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findCellContainingPoint" href="#Granular.findCellContainingPoint"><code>Granular.findCellContainingPoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">findCellContainingPoint(grid, point[, method])</code></pre><p>Returns the <code>i</code>, <code>j</code> index of the grid cell containing the <code>point</code>. The function uses either an area-based approach (<code>method = &quot;Area&quot;</code>), or a  conformal mapping approach (<code>method = &quot;Conformal&quot;</code>).  The area-based approach is  more robust.  This function returns the coordinates of the cell.  If no match is  found the function returns <code>(0,0)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>grid::Any</code>: grid object containing ocean or atmosphere data.</li><li><code>point::Vector{Float64}</code>: two-dimensional vector of point to check.</li><li><code>method::String</code>: approach to use for determining if point is inside cell or    not, can be &quot;Conformal&quot; (default) or &quot;Area&quot;.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findContacts!-Tuple{Granular.Simulation}" href="#Granular.findContacts!-Tuple{Granular.Simulation}"><code>Granular.findContacts!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findContacts!(simulation[, method])</code></pre><p>Top-level function to perform an inter-grain contact search, based on grain  linear positions and contact radii.</p><p>The simplest contact search algorithm (<code>method=&quot;all to all&quot;</code>) is the most  computationally expensive (O(n^2)).  The method &quot;ocean grid&quot; bins the grains  into their corresponding cells on the ocean grid and searches for contacts only  within the vicinity.  When this method is applied, it is assumed that the  <code>contact_radius</code> values of the grains are <em>smaller than half the cell size</em>.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation object containing the grains.</li><li><code>method::String</code>: the contact-search method to apply.  Valid options are &quot;all    to all&quot; and &quot;ocean grid&quot;.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findContactsAllToAll!-Tuple{Granular.Simulation}" href="#Granular.findContactsAllToAll!-Tuple{Granular.Simulation}"><code>Granular.findContactsAllToAll!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findContactsAllToAll!(simulation)</code></pre><p>Perform an O(n^2) all-to-all contact search between all grains in the  <code>simulation</code> object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findContactsInGrid!-Tuple{Granular.Simulation,Any}" href="#Granular.findContactsInGrid!-Tuple{Granular.Simulation,Any}"><code>Granular.findContactsInGrid!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findContactsInGrid!(simulation)</code></pre><p>Perform an O(n*log(n)) cell-based contact search between all grains in the  <code>simulation</code> object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findEmptyPositionInGridCell-Tuple{Granular.Simulation,Any,Int64,Int64,Float64}" href="#Granular.findEmptyPositionInGridCell-Tuple{Granular.Simulation,Any,Int64,Int64,Float64}"><code>Granular.findEmptyPositionInGridCell</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findEmptyPositionInGridCell(simulation, grid, i, j, r[, n_iter, seed,
                            verbose])</code></pre><p>Attempt locate an empty spot for an grain with radius <code>r</code> with center  coordinates in a specified grid cell (<code>i</code>, <code>j</code>) without overlapping any other  grains in that cell or the neighboring cells.  This function will stop  attempting after <code>n_iter</code> iterations, each with randomly generated positions.</p><p>This function assumes that existing grains have been binned according to the  grid (e.g., using <code>sortGrainsInGrid()</code>).</p><p>If the function sucessfully finds a position it will be returned as a two-component Vector{Float64}.  If a position is not found, the function will return <code>false</code>.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation object to add grains to.</li><li><code>grid::Any</code>: the grid to use for position search.</li><li><code>i::Int</code>: the grid-cell index along x.</li><li><code>j::Int</code>: the grid-cell index along y.</li><li><code>r::Float64</code>: the desired grain radius to fit into the cell.</li><li><code>n_iter::Int = 30</code>: the number of attempts for finding an empty spot.</li><li><code>seed::Int = 1</code>: seed for the pseudo-random number generator.</li><li><code>verbose::Bool = false</code>: print diagnostic information.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findLargestGrainStiffness-Tuple{Granular.Simulation}" href="#Granular.findLargestGrainStiffness-Tuple{Granular.Simulation}"><code>Granular.findLargestGrainStiffness</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Finds the largest elastic stiffness of all grains in a simulation.  Used to  determine the optimal time step length.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.findSmallestGrainMass-Tuple{Granular.Simulation}" href="#Granular.findSmallestGrainMass-Tuple{Granular.Simulation}"><code>Granular.findSmallestGrainMass</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Finds the smallest mass of all grains in a simulation.  Used to determine  the optimal time step length.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.fitGridToGrains!-Tuple{Granular.Simulation,Any}" href="#Granular.fitGridToGrains!-Tuple{Granular.Simulation,Any}"><code>Granular.fitGridToGrains!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fitGridToGrains!(simulation, grid[, padding])</code></pre><p>Fit the ocean or atmosphere grid for a simulation to the current grains and their positions.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: simulation object to manipulate.</li><li><code>grid::Any</code>: Ocean or Atmosphere grid to manipulate.</li><li><code>padding::Real</code>: optional padding around edges [m].</li><li><code>verbose::Bool</code>: show grid information when function completes.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.getCellCenterCoordinates-Tuple{Array{Float64,2},Array{Float64,2},Int64,Int64}" href="#Granular.getCellCenterCoordinates-Tuple{Array{Float64,2},Array{Float64,2},Int64,Int64}"><code>Granular.getCellCenterCoordinates</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getCellCenterCoordinates(grid, i, j)</code></pre><p>Returns grid center coordinates (h-point).</p><p><strong>Arguments</strong></p><ul><li><code>xh::Array{Float64, 2}</code>: nominal longitude of h-points [degrees_E]</li><li><code>yh::Array{Float64, 2}</code>: nominal latitude of h-points [degrees_N]</li><li><code>i::Int</code>: x-index of cell.</li><li><code>j::Int</code>: y-index of cell.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.getCellCornerCoordinates-Tuple{Array{Float64,2},Array{Float64,2},Int64,Int64}" href="#Granular.getCellCornerCoordinates-Tuple{Array{Float64,2},Array{Float64,2},Int64,Int64}"><code>Granular.getCellCornerCoordinates</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getCellCornerCoordinates(xq, yq, i, j)</code></pre><p>Returns grid-cell corner coordinates in the following order (south-west corner,  south-east corner, north-east corner, north-west corner).</p><p><strong>Arguments</strong></p><ul><li><code>xq::Array{Float64, 2}</code>: nominal longitude of q-points [degrees_E]</li><li><code>yq::Array{Float64, 2}</code>: nominal latitude of q-points [degrees_N]</li><li><code>i::Int</code>: x-index of cell.</li><li><code>j::Int</code>: y-index of cell.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.getGridCornerCoordinates-Tuple{Array{Float64,2},Array{Float64,2}}" href="#Granular.getGridCornerCoordinates-Tuple{Array{Float64,2},Array{Float64,2}}"><code>Granular.getGridCornerCoordinates</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getGridCornerCoordinates(xq, yq)</code></pre><p>Returns grid corner coordinates in the following order (south-west corner,  south-east corner, north-east corner, north-west corner).</p><p><strong>Arguments</strong></p><ul><li><code>xq::Array{Float64, 2}</code>: nominal longitude of q-points [degrees_E]</li><li><code>yq::Array{Float64, 2}</code>: nominal latitude of q-points [degrees_N]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.getNonDimensionalCellCoordinates-Tuple{Any,Int64,Int64,Array{Float64,1}}" href="#Granular.getNonDimensionalCellCoordinates-Tuple{Any,Int64,Int64,Array{Float64,1}}"><code>Granular.getNonDimensionalCellCoordinates</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the non-dimensional conformal mapped coordinates for point <code>point</code> in  cell <code>i,j</code>, based off the coordinates in the grid.</p><p>This function is a wrapper for <code>getCellCornerCoordinates()</code> and  <code>conformalQuadrilateralCoordinates()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.getWallNormalStress-Tuple{Granular.Simulation}" href="#Granular.getWallNormalStress-Tuple{Granular.Simulation}"><code>Granular.getWallNormalStress</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getWallNormalStress(simulation[, wall_index, stress_type])</code></pre><p>Returns the current &quot;effective&quot; or &quot;defined&quot; normal stress on the wall with index <code>wall_index</code> inside the <code>simulation</code> object.  The returned value is given in Pascal.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation object containing the wall.</li><li><code>wall_index::Integer=1</code>: the wall number in the simulation object.</li><li><code>stress_type::String=&quot;effective&quot;</code>: the normal-stress type to return.  The   defined value corresponds to the normal stress that the wall is asked to   uphold. The effective value is the actual current normal stress.  Usually,   the magnitude of the effective normal stress fluctuates around the defined   normal stress.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.getWallSurfaceArea-Tuple{Granular.Simulation,Integer}" href="#Granular.getWallSurfaceArea-Tuple{Granular.Simulation,Integer}"><code>Granular.getWallSurfaceArea</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getWallSurfaceArea(simulation, wall_index)</code></pre><p>Returns the surface area of the wall given the grid size and its index.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation object containing the wall.</li><li><code>wall_index::Integer=1</code>: the wall number in the simulation object.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainCircumreference-Tuple{Granular.GrainCylindrical}" href="#Granular.grainCircumreference-Tuple{Granular.GrainCylindrical}"><code>Granular.grainCircumreference</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the circumreference of the grain</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainHorizontalSurfaceArea-Tuple{Granular.GrainCylindrical}" href="#Granular.grainHorizontalSurfaceArea-Tuple{Granular.GrainCylindrical}"><code>Granular.grainHorizontalSurfaceArea</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the top or bottom (horizontal) surface area of the grain</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainKineticRotationalEnergy-Tuple{Granular.GrainCylindrical}" href="#Granular.grainKineticRotationalEnergy-Tuple{Granular.GrainCylindrical}"><code>Granular.grainKineticRotationalEnergy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the rotational kinetic energy of the grain</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainKineticTranslationalEnergy-Tuple{Granular.GrainCylindrical}" href="#Granular.grainKineticTranslationalEnergy-Tuple{Granular.GrainCylindrical}"><code>Granular.grainKineticTranslationalEnergy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the translational kinetic energy of the grain</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainMass-Tuple{Granular.GrainCylindrical}" href="#Granular.grainMass-Tuple{Granular.GrainCylindrical}"><code>Granular.grainMass</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the mass of the grain</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainMomentOfInertia-Tuple{Granular.GrainCylindrical}" href="#Granular.grainMomentOfInertia-Tuple{Granular.GrainCylindrical}"><code>Granular.grainMomentOfInertia</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the moment of inertia of the grain</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainSideSurfaceArea-Tuple{Granular.GrainCylindrical}" href="#Granular.grainSideSurfaceArea-Tuple{Granular.GrainCylindrical}"><code>Granular.grainSideSurfaceArea</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the surface area of the grain sides</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainThermalEnergy-Tuple{Granular.GrainCylindrical}" href="#Granular.grainThermalEnergy-Tuple{Granular.GrainCylindrical}"><code>Granular.grainThermalEnergy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the thermal energy of the grain, produced by Coulomb slip</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.grainVolume-Tuple{Granular.GrainCylindrical}" href="#Granular.grainVolume-Tuple{Granular.GrainCylindrical}"><code>Granular.grainVolume</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the volume of the grain</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.harmonicMean-Tuple{Number,Number}" href="#Granular.harmonicMean-Tuple{Number,Number}"><code>Granular.harmonicMean</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">harmonicMean(a, b)</code></pre><p>Returns the harmonic mean of two numbers <code>a::Number</code> and <code>b::Number</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.incrementCurrentTime!-Tuple{Granular.Simulation,Float64}" href="#Granular.incrementCurrentTime!-Tuple{Granular.Simulation,Float64}"><code>Granular.incrementCurrentTime!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">incrementCurrentTime!(simulation::Simulation, t::Float64)</code></pre><p>Sets the current simulation time of the <code>simulation</code> object to <code>t</code>, with  parameter value checks.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.interGrainPositionVector-Tuple{Granular.Simulation,Int64,Int64}" href="#Granular.interGrainPositionVector-Tuple{Granular.Simulation,Int64,Int64}"><code>Granular.interGrainPositionVector</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interGrainPositionVector(simulation, i, j)</code></pre><p>Returns a <code>vector</code> pointing from grain <code>i</code> to grain <code>j</code> in the  <code>simulation</code>.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation object containing the grains.</li><li><code>i::Int</code>: index of the first grain.</li><li><code>j::Int</code>: index of the second grain.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.interact!-Tuple{Granular.Simulation}" href="#Granular.interact!-Tuple{Granular.Simulation}"><code>Granular.interact!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interact!(simulation::Simulation)</code></pre><p>Resolve mechanical interaction between all particle pairs.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation object containing the grains.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.interactGrains!-Tuple{Granular.Simulation,Int64,Int64,Int64}" href="#Granular.interactGrains!-Tuple{Granular.Simulation,Int64,Int64,Int64}"><code>Granular.interactGrains!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interactGrains!(simulation::Simulation, i::Int, j::Int, ic::Int)</code></pre><p>Resolve an grain-to-grain interaction using a prescibed contact law.  This  function adds the compressive force of the interaction to the grain  <code>pressure</code> field of mean compressive stress on the grain sides.</p><p>The function uses the macroscopic contact-stiffness parameterization based on  Young&#39;s modulus and Poisson&#39;s ratio if Young&#39;s modulus is a positive value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.interpolateAtmosphereState-Tuple{Granular.Atmosphere,Float64}" href="#Granular.interpolateAtmosphereState-Tuple{Granular.Atmosphere,Float64}"><code>Granular.interpolateAtmosphereState</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Atmosphere data is containted in <code>Atmosphere</code> type at discrete times  (<code>Atmosphere.time</code>).  This function performs linear interpolation between time  steps to get the approximate atmosphere state at any point in time.  If the  <code>Atmosphere</code> data set only contains a single time step, values from that time  are returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.interpolateOceanState-Tuple{Granular.Ocean,Float64}" href="#Granular.interpolateOceanState-Tuple{Granular.Ocean,Float64}"><code>Granular.interpolateOceanState</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Ocean data is containted in <code>Ocean</code> type at discrete times (<code>Ocean.time</code>).  This  function performs linear interpolation between time steps to get the approximate  ocean state at any point in time.  If the <code>Ocean</code> data set only contains a  single time step, values from that time are returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.interpolateOceanVelocitiesToCorners-Tuple{Array{Float64,4},Array{Float64,4}}" href="#Granular.interpolateOceanVelocitiesToCorners-Tuple{Array{Float64,4},Array{Float64,4}}"><code>Granular.interpolateOceanVelocitiesToCorners</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Convert gridded data from Arakawa-C type (decomposed velocities at faces) to  Arakawa-B type (velocities at corners) through interpolation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.irregularPacking!-Tuple{Granular.Simulation}" href="#Granular.irregularPacking!-Tuple{Granular.Simulation}"><code>Granular.irregularPacking!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">irregularPacking!(simulation[, radius_max, radius_min, sample_limit,
                  padding_factor, binary_radius_search,
                  binary_sampling_quality, thickness, seed,
                  plot_during_packing, verbose)</code></pre><p>Generate a dense disc packing in 2D using Poisson disc sampling with O(N) complexity, as described by <a href="https://doi.org/10.1145/1278780.1278807">Robert Bridson (2007) &quot;Fast Poisson disk sampling in arbitrary dimensions&quot;</a>. The <code>simulation</code> can be empty or already contain grains. However, an <code>simulation.ocean</code> or <code>simulation.atmosphere</code> grid is required.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: simulation object where grains are inserted.</li><li><code>radius_max::Real</code>: largest grain radius to use.</li><li><code>radius_min::Real</code>: smallest grain radius to use.</li><li><code>sample_limit::Integer=30</code>: number of points to sample around each grain   before giving up.</li><li><code>padding_factor::Real=0.</code>: if positive and <code>binary_radius_search = false</code>, try to   add an occasional grain from the current active grain   (<code>radius_max*padding_factor</code>).</li><li><code>binary_radius_search::Bool=false</code>: use a binary radius-sampling procedure to   fit the largest possible grains into the packing. This option will create   the highest packing density.</li><li><code>binary_sampling_quality::Real=100.</code>: the quality to enforce during the binary   radius search when <code>binary_radius_search = true</code>. Larger values create   denser packings but take longer to complete.</li><li><code>seed::Integer</code>: seed value to the pseudo-random number generator.</li><li><code>plot_during_packing::Bool=false</code>: produce successive plots as the packing is   generated. Requires gnuplot (default).</li><li><code>verbose::Bool=true</code>: show diagnostic information to stdout.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.isPointInCell" href="#Granular.isPointInCell"><code>Granular.isPointInCell</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Check if a 2d point is contained inside a cell from the supplied grid. The function uses either an area-based approach (<code>method = &quot;Area&quot;</code>), or a  conformal mapping approach (<code>method = &quot;Conformal&quot;</code>).  The area-based approach is  more robust.  This function returns <code>true</code> or <code>false</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.isPointInGrid" href="#Granular.isPointInGrid"><code>Granular.isPointInGrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Check if a 2d point is contained inside the grid.  The function uses either an area-based approach (<code>method = &quot;Area&quot;</code>), or a conformal mapping approach (<code>method = &quot;Conformal&quot;</code>).  The area-based approach is more robust.  This function returns <code>true</code> or <code>false</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.plotGrainSizeDistribution-Tuple{Granular.Simulation}" href="#Granular.plotGrainSizeDistribution-Tuple{Granular.Simulation}"><code>Granular.plotGrainSizeDistribution</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">plotGrainSizeDistribution(simulation, [filename_postfix, nbins,
                            size_type, filetype, gnuplot_terminal,
                            skip_fixed, log_y, verbose)</code></pre><p>Plot the grain size distribution as a histogram and save it to the disk.  The  plot is saved accoring to the simulation id, the optional <code>filename_postfix</code>  string, and the <code>filetype</code>, and is written to the current folder.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation object containing the grains.</li><li><code>filename_postfix::String</code>: optional string for the output filename.</li><li><code>nbins::Int</code>: number of bins in the histogram (default = 12).</li><li><code>size_type::String</code>: specify whether to use the <code>contact</code> or <code>areal</code> radius    for the grain size.  The default is <code>contact</code>.</li><li><code>filetype::String</code>: the output file type (default = &quot;png&quot;).</li><li><code>gnuplot_terminal::String</code>: the gnuplot output terminal to use (default =   &quot;png&quot;).</li><li><code>skip_fixed::Bool</code>: ommit grains that are fixed in space from the size    distribution (default = true).</li><li><code>log_y::Bool</code>: plot y-axis in log scale.</li><li><code>verbose::String</code>: show output file as info message in stdout (default =    true).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.plotGrains-Tuple{Granular.Simulation}" href="#Granular.plotGrains-Tuple{Granular.Simulation}"><code>Granular.plotGrains</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">plotGrains(simulation, [filetype, gnuplot_terminal, verbose])</code></pre><p>Plot the grains using Gnuplot and save the figure to disk.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation object containing the grains.</li><li><code>filetype::String</code>: the output file type (default = &quot;png&quot;).</li><li><code>gnuplot_terminal::String</code>: the gnuplot output terminal to use (default =   &quot;png crop size 1200,1200&quot;).</li><li><code>plot_interactions::Bool</code>: show grain-grain interactions in the plot.</li><li><code>verbose::String</code>: show output file as info message in stdout (default =    true).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.printGrainInfo-Tuple{Granular.GrainCylindrical}" href="#Granular.printGrainInfo-Tuple{Granular.GrainCylindrical}"><code>Granular.printGrainInfo</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">printGrainInfo(grain::GrainCylindrical)</code></pre><p>Prints the contents of an grain to stdout in a formatted style.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.printMemoryUsage-Tuple{Granular.Simulation}" href="#Granular.printMemoryUsage-Tuple{Granular.Simulation}"><code>Granular.printMemoryUsage</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">printMemoryUsage(sim::Simulation)</code></pre><p>Shows the memory footprint of the simulation object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.randpower" href="#Granular.randpower"><code>Granular.randpower</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randpower([nvals], [distribution_power], [min_val], [max_val])</code></pre><p>Returns one or more random numbers from a power-law probability distribution.</p><p><strong>Arguments</strong></p><ul><li><code>dims::Any</code>: the dimensions of random values (default = 1)</li><li><code>distribution_power::Number</code>: the distribution power (default = 1.)</li><li><code>min_val::Number</code>: the lower bound of the distribution range (default = 0.)</li><li><code>max_val::Number</code>: the upper bound of the distribution range (default = 1.)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.readOceanGridNetCDF-Tuple{String}" href="#Granular.readOceanGridNetCDF-Tuple{String}"><code>Granular.readOceanGridNetCDF</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Read NetCDF file with ocean <em>supergrid</em> information generated by MOM6 (e.g.   <code>ocean_hrid.nc</code>) from disk and return as <code>Ocean</code> data structure.  This file is  located in the simulation <code>INPUT/</code> subdirectory.</p><p><strong>Returns</strong></p><ul><li><code>xh::Array{Float64, 2}</code>: Longitude for cell centers [deg]</li><li><code>yh::Array{Float64, 2}</code>: Latitude for cell centers [deg]</li><li><code>xq::Array{Float64, 2}</code>: Longitude for cell corners [deg]</li><li><code>yq::Array{Float64, 2}</code>: Latitude for cell corners [deg]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.readOceanNetCDF-Tuple{String,String}" href="#Granular.readOceanNetCDF-Tuple{String,String}"><code>Granular.readOceanNetCDF</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Read ocean NetCDF files generated by MOM6 from disk and return as <code>Ocean</code> data  structure.</p><p><strong>Arguments</strong></p><ul><li><code>velocity_file::String</code>: path to NetCDF file containing ocean velocities,    etc., (e.g. <code>prog__####_###.nc</code>).</li><li><code>grid_file::String</code>: path to NetCDF file containing ocean super-grid    information (typically <code>INPUT/ocean_hgrid.nc</code>).</li><li><code>regular_grid::Bool=false</code>: <code>true</code> if the grid is regular (all cells   equal and grid is Cartesian) or <code>false</code> (default).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.readOceanStateNetCDF-Tuple{String}" href="#Granular.readOceanStateNetCDF-Tuple{String}"><code>Granular.readOceanStateNetCDF</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Read NetCDF file with ocean state generated by MOM6 (e.g.  <code>prog__####_###.nc</code>  or <code>########.ocean_month.nc</code>) from disk and return time stamps, velocity fields,  layer thicknesses, interface heights, and vertical coordinates.</p><p><strong>Returns</strong></p><ul><li><code>time::Vector{Float64}</code>: Time [s]</li><li><code>u::Array{Float64, 2}</code>: Cell corner zonal velocity [m/s],   dimensions correspond to placement in <code>[xq, yq, zl, time]</code></li><li><code>v::Array{Float64, 2}</code>: Cell corner meridional velocity [m/s],   dimensions correspond to placement in <code>[xq, yq, zl, time]</code></li><li><code>h::Array{Float64, 2}</code>: layer thickness [m], dimensions correspond to    placement in <code>[xh, yh, zl, time]</code></li><li><code>e::Array{Float64, 2}</code>: interface height relative to mean sea level [m],     dimensions correspond to placement in <code>[xh, yh, zi, time]</code></li><li><code>zl::Vector{Float64}</code>: layer target potential density [kg m^-3]</li><li><code>zi::Vector{Float64}</code>: interface target potential density [kg m^-3]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.readSimulation-Tuple{Granular.Simulation}" href="#Granular.readSimulation-Tuple{Granular.Simulation}"><code>Granular.readSimulation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">readSimulation(simulation::Simulation;
               step::Integer = -1,
               verbose::Bool = true)</code></pre><p>Read the simulation state from disk and return as new simulation object.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: use the <code>simulation.id</code> to determine the file name   to read from, and read information from the file into this object.</li><li><code>step::Integer=-1</code>: attempt to read this output file step. At its default   value (<code>-1</code>), the function will try to read the latest file, determined by   calling <a href="#Granular.readSimulationStatus-Tuple{String}"><code>readSimulationStatus</code></a>.</li><li><code>verbose::Bool=true</code>: confirm to console that the file has been read.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.readSimulation-Tuple{String}" href="#Granular.readSimulation-Tuple{String}"><code>Granular.readSimulation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">readSimulation(filename::String=&quot;&quot;;
               verbose::Bool=true)</code></pre><p>Return <code>Simulation</code> content read from disk using the JLD2 format.</p><p><strong>Arguments</strong></p><ul><li><code>filename::String</code>: path to file on disk containing the simulation   information.</li><li><code>verbose::Bool=true</code>: confirm to console that the file has been read.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.readSimulationStatus-Tuple{String}" href="#Granular.readSimulationStatus-Tuple{String}"><code>Granular.readSimulationStatus</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">readSimulationStatus(simulation_id[, folder, verbose])</code></pre><p>Read the current simulation status from disk (<code>&lt;sim.id&gt;/&lt;sim.id&gt;.status.txt</code>) and return the last output file number.</p><p><strong>Arguments</strong></p><ul><li><code>simulation_id::String</code>: the simulation identifying string.</li><li><code>folder::String=&quot;.&quot;</code>: the folder in which to search for the status file.</li><li><code>verbose::Bool=true</code>: show simulation status in console.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.reflectGrainsFromImpermeableBoundaries!-Tuple{Granular.Simulation}" href="#Granular.reflectGrainsFromImpermeableBoundaries!-Tuple{Granular.Simulation}"><code>Granular.reflectGrainsFromImpermeableBoundaries!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">reflectGrainsFromImpermeableBoundaries!(simulation::Simulation)</code></pre><p>If the ocean or atmosphere grids are impermeable, reflect grain trajectories by reversing the velocity vectors normal to the boundary.  This function is to be called after temporal integration of the grain positions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.regularPacking!-Tuple{Granular.Simulation,Array{Int64,1},Real,Real}" href="#Granular.regularPacking!-Tuple{Granular.Simulation,Array{Int64,1},Real,Real}"><code>Granular.regularPacking!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">regularPacking!(simulation, n, r_min, r_max[, tiling, padding_factor,
                size_distribution, size_distribution_parameter, seed])</code></pre><p>Create a grid-based regular packing with grain numbers along each axis specified by the <code>n</code> vector.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: simulation object where the grains are inserted,   preferably not containing prior grains.</li><li><code>n::Vector{Integer}</code>: 2-element vector determining number of grains along the   <code>x</code> and <code>y</code> axes.</li><li><code>r_min::Real</code>: minimum desired grain radius.</li><li><code>r_max::Real</code>: maximum desired grain radius.</li><li><code>tiling::String</code>: the packing method to use, valid values are <code>&quot;square&quot;</code>   (default) and <code>&quot;triangular&quot;</code> (see   <a href="https://en.wikipedia.org/wiki/Circle_packing#Uniform_packings">Wikipedia</a>).</li><li><code>padding_factor::Real</code>: percentage-wise padding around each grain to allow for   random perturbations to grain position (default = 0.0).</li><li><code>origo::Vector{Real}</code>: spatial offset for the packing (default <code>[0.0, 0.0]</code>).</li><li><code>size_distribution::String</code>: grain-size distribution to sample. Valid values   are &quot;powerlaw&quot; and &quot;uniform&quot;.</li><li><code>size_distribution_parameter::Real</code>: parameter to pass to the grain-size   distribution generating function.</li><li><code>seed::Integer</code>: seed value to the pseudo-random number generator.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.removeSimulationFiles-Tuple{Granular.Simulation}" href="#Granular.removeSimulationFiles-Tuple{Granular.Simulation}"><code>Granular.removeSimulationFiles</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">removeSimulationFiles(simulation[, folder])</code></pre><p>Remove all simulation output files from the specified folder.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.render-Tuple{Granular.Simulation}" href="#Granular.render-Tuple{Granular.Simulation}"><code>Granular.render</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">render(simulation[, pvpython, images, animation])</code></pre><p>Wrapper function which calls <code>writeParaviewPythonScript(...)</code> and executes it from the shell using the supplied <code>pvpython</code> argument.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: simulation object containing the grain data.</li><li><code>pvpython::String</code>: path to the <code>pvpython</code> executable to use.  By default, the   script uses the pvpython in the system PATH.</li><li><code>images::Bool</code>: render images to disk (default: true)</li><li><code>gif::Bool</code>: merge images as GIF and save to disk (default: false, requires   <code>images=true</code>)</li><li><code>animation::Bool</code>: render animation as movie to disk (default: false). If   ffmpeg is available on the system, the <code>.avi</code> file is converted to <code>.mp4</code>.</li><li><code>trim::Bool</code>: trim images in animated sequence (default: true)</li><li><code>reverse::Bool</code>: if <code>images=true</code> additionally render reverse-animated gif   (default: false)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.reportGridBoundaryConditions-Tuple{Any}" href="#Granular.reportGridBoundaryConditions-Tuple{Any}"><code>Granular.reportGridBoundaryConditions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">reportGridBoundaryConditions(grid)</code></pre><p>Report the boundary conditions for the grid to the console.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.reportSimulationTimeToStdout-Tuple{Granular.Simulation}" href="#Granular.reportSimulationTimeToStdout-Tuple{Granular.Simulation}"><code>Granular.reportSimulationTimeToStdout</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Prints the current simulation time and total time to standard out</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.resetTime!-Tuple{Granular.Simulation}" href="#Granular.resetTime!-Tuple{Granular.Simulation}"><code>Granular.resetTime!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">resetTime!(simulation)</code></pre><p>Reset the current time to zero, and reset output file counters in order to restart a simulation.  This function does not overwrite the time step (<code>Simulation.time_step</code>), the output file interval (<code>Simulation.file_time_step</code>), or the total simulation time (<code>Simulation.time_total</code>).</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation object for which to reset the   temporal parameters.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.run!-Tuple{Granular.Simulation}" href="#Granular.run!-Tuple{Granular.Simulation}"><code>Granular.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run!(simulation[,
     verbose::Bool = true,
     status_interval = 100.,
     show_file_output = true,
     single_step = false,
     temporal_integration_method = &quot;Three-term Taylor&quot;],
     write_jld2 = false)</code></pre><p>Run the <code>simulation</code> through time until <code>simulation.time</code> equals or exceeds  <code>simulatim.time_total</code>.  This function requires that all grains are added to  the simulation and that the length of the computational time step is adjusted  accordingly.</p><p>The function will search for contacts, determine the force balance on each ice  floe, and integrate all kinematic degrees of freedom accordingly.  The temporal  integration is explicit and of length <code>simulation.time_step</code>.  This function  will write VTK files to disk in the intervals <code>simulation.file_time_step</code> by the  function <code>writeVTK</code>.  If this value is negative, no output files will be written  to disk.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation to run (object is modified)</li><li><code>verbose::Bool=true</code>: show verbose information during the time loop</li><li><code>status_interval::Bool=true</code>: show verbose information during the time loop</li><li><code>show_file_output::Bool=true</code>: report to stdout when output file is written</li><li><code>single_step::Bool=false</code>: run simulation for a single time step only.  If    this causes <code>simulation.time</code> to exceed <code>simulation.time_total</code>, the latter    is increased accordingly.</li><li><code>temporal_integration_method::String=&quot;Three-term Taylor&quot;</code>: type of integration    method to use.  See <code>updateGrainKinematics</code> for details.</li><li><code>write_jld2::Bool=false</code>: write simulation state to disk as JLD2 files (see    <code>Granular.writeSimulation(...)</code> whenever saving VTK output.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.setBodyForce!-Tuple{Granular.GrainCylindrical,Array{Float64,1}}" href="#Granular.setBodyForce!-Tuple{Granular.GrainCylindrical,Array{Float64,1}}"><code>Granular.setBodyForce!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setBodyForce!(grain, force)</code></pre><p>Set the value of the external body force on a grain.</p><p><strong>Arguments</strong></p><ul><li><code>grain::GrainCylindrical</code>: the grain to set the body force for.</li><li><code>force::Vector{Float64}</code>: a vector of force [N]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.setCurrentTime!-Tuple{Granular.Simulation,Float64}" href="#Granular.setCurrentTime!-Tuple{Granular.Simulation,Float64}"><code>Granular.setCurrentTime!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setCurrentTime!(simulation::Simulation, t::Float64)</code></pre><p>Sets the current simulation time of the <code>simulation</code> object to <code>t</code>, with  parameter value checks.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.setGridBoundaryConditions!" href="#Granular.setGridBoundaryConditions!"><code>Granular.setGridBoundaryConditions!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setGridBoundaryConditions!(grid, grid_face, mode)</code></pre><p>Set boundary conditions for the granular phase at the edges of <code>Ocean</code> or <code>Atmosphere</code> grids.  The target boundary can be selected through the <code>grid_face</code> argument, or the same boundary condition can be applied to all grid boundaries at once.</p><p>When the center coordinate of grains crosses an inactive boundary (<code>mode = &quot;inactive&quot;</code>), the grain is disabled (<code>GrainCylindrical.enabled = false</code>).  This keeps the grain in memory, but stops it from moving or interacting with other grains.  <em>By default, all boundaries are inactive</em>.</p><p>If the center coordinate of a grain crosses a periodic boundary (<code>mode = periodic</code>), the grain is repositioned to the opposite side of the model domain. Grains can interact mechanically across the periodic boundary.</p><p><strong>Arguments</strong></p><ul><li><code>grid::Any</code>: <code>Ocean</code> or <code>Atmosphere</code> grid to apply the boundary condition to.</li><li><code>grid_face::String</code>: Grid face to apply the boundary condition to.  Valid   values are any combination and sequence of <code>&quot;west&quot;</code> (-x), <code>&quot;south&quot;</code> (-y),   <code>&quot;east&quot;</code> (+x), <code>&quot;north&quot;</code> (+y), or simply any combination of <code>&quot;-x&quot;</code>, <code>&quot;+x&quot;</code>,   <code>&quot;-y&quot;</code>, and <code>&quot;+y&quot;</code>.  The specifiers may be delimited in any way.   Also, and by default, all boundaries can be selected with <code>&quot;all&quot;</code> (-x, -y,   +x, +y), which overrides any other face selection.</li><li><code>mode::String</code>: Boundary behavior, accepted values are <code>&quot;inactive&quot;</code>,   <code>&quot;periodic&quot;</code>, and <code>&quot;impermeable&quot;</code>.  You cannot specify more than one mode at   a time, so if several modes are desired as boundary conditions for the grid,   several calls to this function should be made.</li><li><code>verbose::Bool</code>: Confirm boundary conditions by reporting values to console.</li></ul><p><strong>Examples</strong></p><p>Set all boundaries for the ocean grid to be periodic:</p><pre><code class="language-none">setGridBoundaryConditions!(ocean, &quot;periodic&quot;, &quot;all&quot;)</code></pre><p>Set the south-north boundaries to be inactive, but the west-east boundaries to be periodic:</p><pre><code class="language-none">setGridBoundaryConditions!(ocean, &quot;inactive&quot;, &quot;south north&quot;)
setGridBoundaryConditions!(ocean, &quot;periodic&quot;, &quot;west east&quot;)</code></pre><p>or specify the conditions from the coordinate system axes:</p><pre><code class="language-none">setGridBoundaryConditions!(ocean, &quot;inactive&quot;, &quot;-y +y&quot;)
setGridBoundaryConditions!(ocean, &quot;periodic&quot;, &quot;-x +x&quot;)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.setMaximumNumberOfContactsPerGrain!-Tuple{Granular.Simulation,Int64}" href="#Granular.setMaximumNumberOfContactsPerGrain!-Tuple{Granular.Simulation,Int64}"><code>Granular.setMaximumNumberOfContactsPerGrain!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setMaximumNumberOfContactsPerGrain!(simulation, number_of_contacts)</code></pre><p>Change the maximum number of contacts per grain, which changes simulation.Nc_max and reallocates memory for each grain. Larger values require more memory, but allow simulation of wider grain-size distributions. The default value is a maximum of 32 contacts per grain, which is sufficient for most practical purposes.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the Simulation object to modify</li><li><code>number_of_contacts::Int</code>: the maximum number of contacts per grain to allow.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.setOutputFileInterval!-Tuple{Granular.Simulation,Float64}" href="#Granular.setOutputFileInterval!-Tuple{Granular.Simulation,Float64}"><code>Granular.setOutputFileInterval!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>setOutputFileInterval!(simulation::Simulation, t::Float64)</p><p>Sets the simulation-time interval between output files are written to disk.  If  this value is zero or negative, no output files will be written.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.setTimeStep!-Tuple{Granular.Simulation}" href="#Granular.setTimeStep!-Tuple{Granular.Simulation}"><code>Granular.setTimeStep!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setTimeStep!(simulation[, epsilon, verbose])</code></pre><p>Find the computational time step length suitable given the grain radii, contact stiffnesses, and grain density. Uses the scheme by Radjaii et al. 2011.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: the simulation object to modify.</li><li><code>epsilon::Float64=0.07</code>: safety factor in the time step scheme. Larger values   are more likely to cause unstable behavior than smaller values.</li><li><code>verbose::Bool=true</code>: display the resultant time step in the console.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.setTotalTime!-Tuple{Granular.Simulation,Float64}" href="#Granular.setTotalTime!-Tuple{Granular.Simulation,Float64}"><code>Granular.setTotalTime!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setTotalTime!(simulation::Simulation, t::Float64)</code></pre><p>Sets the total simulation time of the <code>simulation</code> object to <code>t</code>, with parameter  value checks.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.sortGrainsInGrid!-Tuple{Granular.Simulation,Any}" href="#Granular.sortGrainsInGrid!-Tuple{Granular.Simulation,Any}"><code>Granular.sortGrainsInGrid!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Find grain positions in grid, based on their center positions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.status" href="#Granular.status"><code>Granular.status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">status(folder[, loop, t_int, colored_output, write_header, render)</code></pre><p>Shows the status of all simulations with output files written under the  specified <code>folder</code>, which is the current working directory by default.</p><p><strong>Arguments</strong></p><p><code>folder::String=&quot;.&quot;</code>: directory (including subdirectories) to scan for     simulation output. <code>loop::Bool=false</code>: continue printing the status every <code>t_int</code> seconds. <code>t_int::Int=10</code>: interval between status updates when <code>loop=true</code>. <code>colored_output::Bool=true</code>: display output with colors. <code>write_header::Bool=true</code>: write header line explaining the data. visualize::Bool=false<code>: render the simulation output. Does not work well when</code>loop=true`, as the script regenerates (and overwrites)  all output graphics     on every call.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.totalGrainKineticRotationalEnergy-Tuple{Granular.Simulation}" href="#Granular.totalGrainKineticRotationalEnergy-Tuple{Granular.Simulation}"><code>Granular.totalGrainKineticRotationalEnergy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">totalGrainKineticRotationalEnergy(simulation)</code></pre><p>Returns the sum of rotational kinetic energies of all grains in a simulation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.totalGrainKineticTranslationalEnergy-Tuple{Granular.Simulation}" href="#Granular.totalGrainKineticTranslationalEnergy-Tuple{Granular.Simulation}"><code>Granular.totalGrainKineticTranslationalEnergy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">totalGrainKineticTranslationalEnergy(simulation)</code></pre><p>Returns the sum of translational kinetic energies of all grains in a  simulation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.totalGrainThermalEnergy-Tuple{Granular.Simulation}" href="#Granular.totalGrainThermalEnergy-Tuple{Granular.Simulation}"><code>Granular.totalGrainThermalEnergy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">totalGrainKineticTranslationalEnergy(simulation)</code></pre><p>Returns the sum of thermal energy of all grains in a simulation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.updateGrainKinematics!-Tuple{Granular.Simulation}" href="#Granular.updateGrainKinematics!-Tuple{Granular.Simulation}"><code>Granular.updateGrainKinematics!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">updateGrainKinematics!(simulation::Simulation[,
                         method::String = &quot;Three-term Taylor&quot;])</code></pre><p>Update the grain kinematic parameters using a temporal integration scheme, the current force and torque balance, and gravitational acceleration.  If the simulation contains a grid with periodic boundaries, affected grain positions are adjusted accordingly.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: update the grain positions in this object    according to temporal integration of length <code>simulation.time_step</code>.</li><li><code>method::String = &quot;Three-term Taylor&quot;</code>: the integration method to use.     Available methods are &quot;Two-term Taylor&quot; and &quot;Three-term Taylor&quot;.  The    three-term Taylor expansion is slightly more computationally expensive than    the two-term Taylor expansion, but offers an order-of-magnitude increase in    precision of grain positions.  The two-term expansion can obtain similar    precision if the time step is 1/10 the length.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.updateGrainKinematicsThreeTermTaylor!-Tuple{Granular.GrainCylindrical,Granular.Simulation}" href="#Granular.updateGrainKinematicsThreeTermTaylor!-Tuple{Granular.GrainCylindrical,Granular.Simulation}"><code>Granular.updateGrainKinematicsThreeTermTaylor!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Use a three-term Taylor expansion for integrating the kinematic degrees of  freedom for a <code>grain</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.updateGrainKinematicsTwoTermTaylor!-Tuple{Granular.GrainCylindrical,Granular.Simulation}" href="#Granular.updateGrainKinematicsTwoTermTaylor!-Tuple{Granular.GrainCylindrical,Granular.Simulation}"><code>Granular.updateGrainKinematicsTwoTermTaylor!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Use a two-term Taylor expansion for integrating the kinematic degrees of freedom  for a <code>grain</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.updateWallKinematics!-Tuple{Granular.Simulation}" href="#Granular.updateWallKinematics!-Tuple{Granular.Simulation}"><code>Granular.updateWallKinematics!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">updateWallKinematics!(simulation::Simulation[,
                      method::String = &quot;Three-term Taylor&quot;])</code></pre><p>Update the wall kinematic parameters using a temporal integration scheme, the current force and torque balance, and gravitational acceleration.  If the simulation contains a grid with periodic boundaries, affected wall positions are adjusted accordingly.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: update the wall positions in this object    according to temporal integration of length <code>simulation.time_step</code>.</li><li><code>method::String = &quot;Three-term Taylor&quot;</code>: the integration method to use.     Available methods are &quot;Two-term Taylor&quot; and &quot;Three-term Taylor&quot;.  The    three-term Taylor expansion is slightly more computationally expensive than    the two-term Taylor expansion, but offers an order-of-magnitude increase in    precision of wall positions.  The two-term expansion can obtain similar    precision if the time step is 1/10 the length.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.updateWallKinematicsThreeTermTaylor!-Tuple{Granular.WallLinearFrictionless,Granular.Simulation}" href="#Granular.updateWallKinematicsThreeTermTaylor!-Tuple{Granular.WallLinearFrictionless,Granular.Simulation}"><code>Granular.updateWallKinematicsThreeTermTaylor!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">updateWallKinematicsThreeTermTaylor!(wall, simulation)</code></pre><p>Use a two-term Taylor expansion for integrating the kinematic degrees of freedom  for a <code>wall</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.updateWallKinematicsTwoTermTaylor!-Tuple{Granular.WallLinearFrictionless,Granular.Simulation}" href="#Granular.updateWallKinematicsTwoTermTaylor!-Tuple{Granular.WallLinearFrictionless,Granular.Simulation}"><code>Granular.updateWallKinematicsTwoTermTaylor!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">updateWallKinematicsTwoTermTaylor!(wall, simulation)</code></pre><p>Use a two-term Taylor expansion for integrating the kinematic degrees of freedom  for a <code>wall</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.vecTo3d-Tuple{Any}" href="#Granular.vecTo3d-Tuple{Any}"><code>Granular.vecTo3d</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function vecTo3d(input, fill)</code></pre><p>Convert a scalar or 2d vector to 3d by filling the missing component with the value <code>fill</code>. The returned 3-component vector is a Vector (or 1d Array) of the same type as the input.</p><p><strong>Arguments</strong></p><ul><li><code>input</code>: a scalar or two-component vector.</li><li><code>fill::Real</code>: value to use for third</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.writeGrainInteractionVTK-Tuple{Granular.Simulation,String}" href="#Granular.writeGrainInteractionVTK-Tuple{Granular.Simulation,String}"><code>Granular.writeGrainInteractionVTK</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">writeGrainInteractionVTK(simulation::Simulation,
                           filename::String;
                           verbose::Bool=false)</code></pre><p>Saves grain interactions to <code>.vtp</code> files for visualization with VTK, for  example in Paraview.  Convert Cell Data to Point Data and use with Tube filter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.writeGrainVTK-Tuple{Granular.Simulation,String}" href="#Granular.writeGrainVTK-Tuple{Granular.Simulation,String}"><code>Granular.writeGrainVTK</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Write a VTK file to disk containing all grains in the <code>simulation</code> in an  unstructured mesh (file type <code>.vtu</code>).  These files can be read by ParaView and  can be visualized by applying a <em>Glyph</em> filter.  This function is called by  <code>writeVTK()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.writeParaviewPythonScript-Tuple{Granular.Simulation}" href="#Granular.writeParaviewPythonScript-Tuple{Granular.Simulation}"><code>Granular.writeParaviewPythonScript</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>function writeParaviewPythonScript(simulation,                                    [filename, folder, vtk_folder, verbose])</p><p>Create a <code>&quot;.py&quot;</code> script for visualizing the simulation VTK files in Paraview. The script can be run from the command line with <code>pvpython</code> (bundled with Paraview), or from the interactive Python shell inside Paraview.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: input simulation file containing the data.</li><li><code>filename::String</code>: output file name for the Python script. At its default   (blank) value, the script is named after the simulation id (<code>simulation.id</code>).</li><li><code>folder::String</code>: output directory, current directory the default.</li><li><code>vtk_folder::String</code>: directory containing the VTK output files, by default   points to the full system path equivalent to <code>&quot;./&lt;simulation.id&gt;/&quot;</code>.</li><li><code>save_animation::Bool</code>: make the generated script immediately save a rendered   animation to disk when the <code>&quot;.py&quot;</code> script is called.</li><li><code>verbose::Bool</code>: show diagnostic information during</li></ul><p>function call, on by     default.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.writeSimulation-Tuple{Granular.Simulation}" href="#Granular.writeSimulation-Tuple{Granular.Simulation}"><code>Granular.writeSimulation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">writeSimulation(simulation::Simulation;
                     filename::String=&quot;&quot;,
                     folder::String=&quot;.&quot;,
                     verbose::Bool=true)</code></pre><p>Write all content from <code>Simulation</code> to disk in JLD2 format.  If the <code>filename</code>  parameter is not specified, it will be saved to a subdirectory under the current  directory named after the simulation identifier <code>simulation.id</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.writeSimulationStatus-Tuple{Granular.Simulation}" href="#Granular.writeSimulationStatus-Tuple{Granular.Simulation}"><code>Granular.writeSimulationStatus</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">writeSimulationStatus(simulation::Simulation;
                      folder::String=&quot;.&quot;,
                      verbose::Bool=false)</code></pre><p>Write current simulation status to disk in a minimal txt file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.writeVTK-Tuple{Granular.Simulation}" href="#Granular.writeVTK-Tuple{Granular.Simulation}"><code>Granular.writeVTK</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Write a VTK file to disk containing all grains in the <code>simulation</code> in an  unstructured mesh (file type <code>.vtu</code>).  These files can be read by ParaView and  can be visualized by applying a <em>Glyph</em> filter.</p><p>If the simulation contains an <code>Ocean</code> data structure, it&#39;s contents will be  written to separate <code>.vtu</code> files.  This can be disabled by setting the argument  <code>ocean=false</code>.  The same is true for the atmosphere.</p><p>The VTK files will be saved in a subfolder named after the simulation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.zeroForcesAndTorques!-Tuple{Granular.Simulation}" href="#Granular.zeroForcesAndTorques!-Tuple{Granular.Simulation}"><code>Granular.zeroForcesAndTorques!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Sets the <code>force</code> and <code>torque</code> values of all grains and dynamic walls to zero.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Granular.zeroKinematics!-Tuple{Granular.Simulation}" href="#Granular.zeroKinematics!-Tuple{Granular.Simulation}"><code>Granular.zeroKinematics!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">zeroKinematics!(simulation)</code></pre><p>Set all grain forces, torques, accelerations, and velocities (linear and rotational) to zero in order to get rid of all kinetic energy.</p></div></div></section><footer><hr/><a class="previous" href="../../man/getting_started/"><span class="direction">Previous</span><span class="title">Getting started</span></a><a class="next" href="../internals/"><span class="direction">Next</span><span class="title">Internals</span></a></footer></article></body></html>
