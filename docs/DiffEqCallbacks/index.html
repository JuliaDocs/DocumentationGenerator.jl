<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · DiffEqCallbacks.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DiffEqCallbacks.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Usage-1">Usage</a></li><li><a class="toctext" href="#ManifoldProjection-1">ManifoldProjection</a></li><li><a class="toctext" href="#AutoAbstol-1">AutoAbstol</a></li><li><a class="toctext" href="#Domain-Controls-1">Domain Controls</a></li><li><a class="toctext" href="#StepsizeLimiter-1">StepsizeLimiter</a></li><li><a class="toctext" href="#FunctionCallingCallback-1">FunctionCallingCallback</a></li><li><a class="toctext" href="#SavingCallback-1">SavingCallback</a></li><li><a class="toctext" href="#IterativeCallback-1">IterativeCallback</a></li><li><a class="toctext" href="#PeriodicCallback-1">PeriodicCallback</a></li><li><a class="toctext" href="#TerminateSteadyState-1">TerminateSteadyState</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DiffEqCallbacks.jl-1" href="#DiffEqCallbacks.jl-1">DiffEqCallbacks.jl</a></h1><p><a href="https://gitter.im/JuliaDiffEq/Lobby?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/JuliaDiffEq/Lobby.svg" alt="Join the chat at https://gitter.im/JuliaDiffEq/Lobby"/></a></p><p><a href="https://travis-ci.org/JuliaDiffEq/DiffEqCallbacks.jl"><img src="https://travis-ci.org/JuliaDiffEq/DiffEqCallbacks.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/ChrisRackauckas/diffeqcallbacks-jl-ufx45"><img src="https://ci.appveyor.com/api/projects/status/a3o1a4l4xqcwuw86?svg=true" alt="Build status"/></a> <a href="https://coveralls.io/github/JuliaDiffEq/DiffEqCallbacks.jl?branch=master"><img src="https://coveralls.io/repos/JuliaDiffEq/DiffEqCallbacks.jl/badge.svg?branch=master&amp;service=github" alt="Coverage Status"/></a> <a href="http://codecov.io/github/JuliaDiffEq/DiffEqCallbacks.jl?branch=master"><img src="http://codecov.io/github/JuliaDiffEq/DiffEqCallbacks.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p><a href="http://pkg.julialang.org/?pkg=DiffEqCallbacks"><img src="http://pkg.julialang.org/badges/DiffEqCallbacks_0.5.svg" alt="DiffEqCallbacks"/></a> <a href="http://pkg.julialang.org/?pkg=DiffEqCallbacks"><img src="http://pkg.julialang.org/badges/DiffEqCallbacks_0.6.svg" alt="DiffEqCallbacks"/></a></p><p>This is a library of callbacks for extending the solvers of DifferentialEquations.jl.</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><p>To use the callbacks provided in this library with DifferentialEquations.jl solvers, just pass it to the solver via the <code>callback</code> keyword argument:</p><pre><code class="language-julia">sol = solve(prob,alg;callback=cb)</code></pre><p>For more information on using callbacks, <a href="http://docs.juliadiffeq.org/latest/features/callback_functions.html">see the manual page</a>.</p><h2><a class="nav-anchor" id="ManifoldProjection-1" href="#ManifoldProjection-1">ManifoldProjection</a></h2><p>This projects the solution to a manifold, conserving a property while conserving the order.</p><pre><code class="language-julia">ManifoldProjection(g;nlsolve=NLSOLVEJL_SETUP(),save=true)</code></pre><ul><li><code>g</code>: The residual function for the manifold: <code>g(resid,u)</code>. This is an inplace function which writes to the residual the difference from the manifold components.</li><li><code>nlsolve</code>: A nonlinear solver as defined <a href="linear_nonlinear.html">in the nlsolve format</a></li><li><code>save</code>: Whether to do the standard saving (applied after the callback)</li></ul><h2><a class="nav-anchor" id="AutoAbstol-1" href="#AutoAbstol-1">AutoAbstol</a></h2><p>Many problem solving environments <a href="https://www.mathworks.com/help/simulink/gui/absolute-tolerance.html">such as MATLAB</a> provide a way to automatically adapt the absolute tolerance to the problem. This helps the solvers automatically &quot;learn&quot; what appropriate limits are. Via the callback interface, DiffEqCallbacks.jl implements a callback <code>AutoAbstol</code> which has the same behavior as the MATLAB implementation, that is the absolute tolerance starts at <code>init_curmax</code> (default <code>1-e6</code>), and at each iteration it is set to the maximum value that the state has thus far reached times the relative tolerance.</p><p>To generate the callback, use the constructor:</p><pre><code class="language-julia">AutoAbstol(save=true;init_curmax=1e-6)</code></pre><p><code>save</code> determines whether this callback has saving enabled, and <code>init_curmax</code> is the initial <code>abstol</code>. If this callback is used in isolation, <code>save=true</code> is required for normal saving behavior. Otherwise, <code>save=false</code> should be set to ensure extra saves do not occur.</p><h2><a class="nav-anchor" id="Domain-Controls-1" href="#Domain-Controls-1">Domain Controls</a></h2><p>The domain controls are efficient methods for preserving a domain relation for the solution value <code>u</code>. Unlike the <code>isoutofdomain</code> method, these methods use interpolations and extrapolations to more efficiently choose stepsizes, but require that the solution is well defined slightly outside of the domain.</p><h3><a class="nav-anchor" id="PositiveDomain-1" href="#PositiveDomain-1">PositiveDomain</a></h3><pre><code class="language-julia">PositiveDomain(u=nothing; save=true, abstol=nothing, scalefactor=nothing)</code></pre><h3><a class="nav-anchor" id="GeneralDomain-1" href="#GeneralDomain-1">GeneralDomain</a></h3><pre><code class="language-julia">GeneralDomain(g, u=nothing; nlsolve=NLSOLVEJL_SETUP(), save=true,
                       abstol=nothing, scalefactor=nothing, autonomous=numargs(g)==2,
                       nlopts=Dict(:ftol =&gt; 10*eps()))</code></pre><h2><a class="nav-anchor" id="StepsizeLimiter-1" href="#StepsizeLimiter-1">StepsizeLimiter</a></h2><p>The stepsize limiter lets you define a function <code>dtFE(u,p,t)</code> which changes the allowed maximal stepsize throughout the computation. The constructor is:</p><pre><code class="language-julia">StepsizeLimiter(dtFE;safety_factor=9//10,max_step=false,cached_dtcache=0.0)</code></pre><p><code>dtFE</code> is the maximal timestep and is calculated using the previous <code>t</code> and <code>u</code>. <code>safety_factor</code> is the factor below the true maximum that will be stepped to which defaults to <code>9//10</code>. <code>max_step=true</code> makes every step equal to <code>safety_factor*dtFE(u,p,t)</code> when the solver is set to <code>adaptive=false</code>. <code>cached_dtcache</code> should be set to match the type for time when not using Float64 values.</p><h2><a class="nav-anchor" id="FunctionCallingCallback-1" href="#FunctionCallingCallback-1">FunctionCallingCallback</a></h2><p>The function calling callback lets you define a function <code>func(u,t,integrator)</code> which gets calls at the time points of interest. The constructor is:</p><pre><code class="language-julia">FunctionCallingCallback(func;
               funcat=Vector{Float64}(),
               func_everystep=isempty(funcat),
               func_start = true
               tdir=1)</code></pre><ul><li><code>func(t, u, integrator)</code> is the function to be called.</li><li><code>funcat</code> values that the function is sure to be evaluated at.</li><li><code>func_everystep</code> whether to call the function after each integrator step.</li><li><code>func_start</code> whether the function is called the initial condition.</li><li><code>tdir</code> should be <code>sign(tspan[end]-tspan[1])</code>. It defaults to <code>1</code> and should be adapted if <code>tspan[1] &gt; tspan[end]</code>.</li></ul><h2><a class="nav-anchor" id="SavingCallback-1" href="#SavingCallback-1">SavingCallback</a></h2><p>The saving callback lets you define a function <code>save_func(u, t, integrator)</code> which returns quantities of interest that shall be saved. The constructor is:</p><pre><code class="language-julia">SavingCallback(save_func, saved_values::SavedValues;
               saveat=Vector{eltype(saved_values.t)}(),
               save_everystep=isempty(saveat),
               save_start = true,
               tdir=1)</code></pre><ul><li><code>save_func(u, t, integrator)</code> returns the quantities which shall be saved. Note that this should allocate the output (not as a view to <code>u</code>).</li><li><code>saved_values::SavedValues</code> is the types that <code>save_func</code> will return, i.e. <code>save_func(t, u, integrator)::savevalType</code>. It&#39;s specified via <code>SavedValues(typeof(t),savevalType)</code>, i.e. give the type for time and the type that <code>save_func</code> will output (or higher compatible type).</li><li><code>saveat</code> mimics <code>saveat</code> in <code>solve</code> from <code>solve</code>.</li><li><code>save_everystep</code> mimics <code>save_everystep</code> from <code>solve</code>.</li><li><code>save_start</code> mimics <code>save_start</code> from <code>solve</code>.</li><li><code>tdir</code> should be <code>sign(tspan[end]-tspan[1])</code>. It defaults to <code>1</code> and should be adapted if <code>tspan[1] &gt; tspan[end]</code>.</li></ul><p>The outputted values are saved into <code>saved_values</code>. Time points are found via <code>saved_values.t</code> and the values are <code>saved_values.saveval</code>.</p><h2><a class="nav-anchor" id="IterativeCallback-1" href="#IterativeCallback-1">IterativeCallback</a></h2><p><code>IterativeCallback</code> is a callback to be used to iteratively apply some affect. For example, if given the first effect at <code>t₁</code>, you can define <code>t₂</code> to apply the next effect.</p><p>A <code>IterativeCallback</code> is constructed as follows:</p><pre><code class="language-julia">function IterativeCallback(time_choice, user_affect!,tType = Float64;
                           initialize = DiffEqBase.INITIALIZE_DEFAULT,
                           initial_affect = false, kwargs...)</code></pre><p>where <code>time_choice(integrator)</code> determines the time of the next callback and <code>user_affect!</code> is the effect applied to the integrator at the stopping points. If <code>nothing</code> is returned for the time choice then the iterator ends.</p><h2><a class="nav-anchor" id="PeriodicCallback-1" href="#PeriodicCallback-1">PeriodicCallback</a></h2><p><code>PeriodicCallback</code> can be used when a function should be called periodically in terms of integration time (as opposed to wall time), i.e. at <code>t = tspan[1]</code>, <code>t = tspan[1] + Δt</code>, <code>t = tspan[1] + 2Δt</code>, and so on. This callback can, for example, be used to model a digital controller for an analog system, running at a fixed rate.</p><p>A <code>PeriodicCallback</code> can be constructed as follows:</p><pre><code class="language-julia">PeriodicCallback(f, Δt::Number; kwargs...)</code></pre><p>where <code>f</code> is the function to be called periodically, <code>Δt</code> is the period, and <code>kwargs</code> are keyword arguments accepted by the <code>DiscreteCallback</code> constructor.</p><h2><a class="nav-anchor" id="TerminateSteadyState-1" href="#TerminateSteadyState-1">TerminateSteadyState</a></h2><p><code>TerminateSteadyState</code> can be used to solve the problem for the steady-state by running the solver until the derivatives of the problem converge to 0 or <code>tspan[2]</code> is reached. This is an alternative approach to root finding (see the <a href="@ref">Steady State Solvers</a> section). The constructor of this callback is:</p><pre><code class="language-julia">TerminateSteadyState(abstol = 1e-8, reltol = 1e-6, test = allDerivPass)</code></pre><p>where <code>abstol</code> and <code>reltol</code> are the absolute and relative tolerance, respectively. These tolerances may be specified as scalars or as arrays of the same length as the states of the problem. <code>test</code> represents the function that evaluates the condition for termination. The default condition is that all derivatives should become smaller than <code>abstol</code> and the states times <code>reltol</code>. The user can pass any other function to implement a different termination condition. Such function should take four arguments: <code>integrator</code> (see <a href="@ref">Integrator Interface</a> for details), <code>abstol</code> and <code>reltol</code>.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
