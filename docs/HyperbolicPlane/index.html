<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · HyperbolicPlane.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>HyperbolicPlane.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HCircle" href="#HyperbolicPlane.HCircle"><code>HyperbolicPlane.HCircle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HCircle(P::HPoint,r::Real)</code> creates a new hyperbolic circle centered at <code>P</code> with radius <code>r</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HCircle-Tuple{HPoint,HPoint,HPoint}" href="#HyperbolicPlane.HCircle-Tuple{HPoint,HPoint,HPoint}"><code>HyperbolicPlane.HCircle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>HCircle(A,B,C)</code> creates a circle that includes the three given points.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HContainer" href="#HyperbolicPlane.HContainer"><code>HyperbolicPlane.HContainer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HContainer</code> is a device for holding a collection of hyperbolic objects. It is like a set, but we have to do a lot of work before adding a new element because equal hyperbolic objects might differ a tiny amount and that would mess up hashing.</p><ul><li><code>C = HContainer()</code> creates a new container.</li><li><code>C = HContainer(items...)</code> creates a new container with the items.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HLine-Tuple{HPoint,HPoint}" href="#HyperbolicPlane.HLine-Tuple{HPoint,HPoint}"><code>HyperbolicPlane.HLine</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>HLine(P,Q)</code> creates a new line from the given two points.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HLine-Tuple{HSegment}" href="#HyperbolicPlane.HLine-Tuple{HSegment}"><code>HyperbolicPlane.HLine</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>HLine(S::HSegment)</code> extends the segment <code>S</code> to give a (new) line.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HPoint" href="#HyperbolicPlane.HPoint"><code>HyperbolicPlane.HPoint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HPoint(z::Complex)</code> creates a new point in the hyperbolic plane. The argument <code>z</code> must have absolute value less than 1.</p><p><code>HPoint(r,theta)</code> creates a new point with polar coordinates <code>(r,theta)</code>. See also: <code>polar</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HPolygon" href="#HyperbolicPlane.HPolygon"><code>HyperbolicPlane.HPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HPolygon()</code> creates a new polygon (with no points).</p><p><code>HPolygon(list)</code> creates a polygon whose points are specified in <code>list</code>.</p><p>See: <code>add_point!</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HRay" href="#HyperbolicPlane.HRay"><code>HyperbolicPlane.HRay</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HRay(P::HPoint, t::Real)</code> returns a ray with vertex <code>P</code> pointing to <code>exp(im*t)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HRay-Tuple{HPoint,HPoint}" href="#HyperbolicPlane.HRay-Tuple{HPoint,HPoint}"><code>HyperbolicPlane.HRay</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>HRay(A,B)</code> where <code>A</code> and <code>B</code> are points creates the ray with vertex <code>A</code> passing through <code>B</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HSegment" href="#HyperbolicPlane.HSegment"><code>HyperbolicPlane.HSegment</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HSegment(A,B)</code> creates a new line segment with endpoints <code>A</code> and <code>B</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HTriangle" href="#HyperbolicPlane.HTriangle"><code>HyperbolicPlane.HTriangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HTriangle(A,B,C)</code> creates a new hyperbolic triangle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.Horocycle" href="#HyperbolicPlane.Horocycle"><code>HyperbolicPlane.Horocycle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Horocycle(P::HPoint, theta::Real)</code> create the horocycle containing the point <code>P</code> and the ideal point at <code>exp(im*theta)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractLattices.dist-Tuple{HPoint,HLine}" href="#AbstractLattices.dist-Tuple{HPoint,HLine}"><code>AbstractLattices.dist</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>dist(P::HPoint,L::HLine)</code> is the distance from <code>P</code> to the nearest point on <code>L</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractLattices.dist-Tuple{HPoint,HPoint}" href="#AbstractLattices.dist-Tuple{HPoint,HPoint}"><code>AbstractLattices.dist</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>dist(P,Q)</code> gives the distance betwen two points in the hyperbolic plane. If <code>Q</code> is omitted, give the distance from <code>P</code> to <code>HPoint(0)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.angle-Tuple{HPoint,HPoint,HPoint}" href="#Base.angle-Tuple{HPoint,HPoint,HPoint}"><code>Base.angle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>angle(A,B,C)</code> finds the angle betwen <code>BA</code> and <code>BC</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHCircle-Tuple{}" href="#HyperbolicPlane.RandomHCircle-Tuple{}"><code>HyperbolicPlane.RandomHCircle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>RandomHCircle()</code> creates a random circle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHLine-Tuple{}" href="#HyperbolicPlane.RandomHLine-Tuple{}"><code>HyperbolicPlane.RandomHLine</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>RandomHLine()</code> returns a random line in the hyperbolic plane.</p><p>Algorithm: choose two values <code>s,t</code> in <code>[0,2pi)</code> uniformly at random and then make the line from <code>exp(s*im)</code> to <code>exp(t*im)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHPoint-Tuple{}" href="#HyperbolicPlane.RandomHPoint-Tuple{}"><code>HyperbolicPlane.RandomHPoint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>RandomHPoint()</code> generates a point at random in the hyperbolic plane.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHPolygon" href="#HyperbolicPlane.RandomHPolygon"><code>HyperbolicPlane.RandomHPolygon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomHPolygon(n::Int,simple::Bool=false)</code> create a new <code>HPolygon</code> with <code>n</code> points chosen at random. With <code>simple</code> set to <code>true</code>, return a polygon that does not self-intersect.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHRay-Tuple{HPoint}" href="#HyperbolicPlane.RandomHRay-Tuple{HPoint}"><code>HyperbolicPlane.RandomHRay</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>RandomHRay()</code> creates a random ray. <code>RandomRay(P::HPoint)</code> creates a random ray with vertex <code>P</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHTriangle-Tuple{}" href="#HyperbolicPlane.RandomHTriangle-Tuple{}"><code>HyperbolicPlane.RandomHTriangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>RandomHTriangle()</code> creates a random triangle via three calls to <code>RandomHPoint()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHorocycle-Tuple{}" href="#HyperbolicPlane.RandomHorocycle-Tuple{}"><code>HyperbolicPlane.RandomHorocycle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>RandomHorocycle()</code> creates a random horocycle by choosing a point at random by <code>RandomHPoint</code> and a random ideal point (uniformly between 0 and 2π).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.add_object!-Tuple{HContainer,HObject}" href="#HyperbolicPlane.add_object!-Tuple{HContainer,HObject}"><code>HyperbolicPlane.add_object!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>add_object!(C::HContainer, X::HObject)</code> adds <code>X</code> to the container <code>C</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.add_point!-Tuple{HPolygon,HPoint}" href="#HyperbolicPlane.add_point!-Tuple{HPolygon,HPoint}"><code>HyperbolicPlane.add_point!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>add_point!(X::HPolygon, P::HPoint)</code> adds the point <code>P</code> as the last point of the polygon <code>X</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.angles-Tuple{HPolygon}" href="#HyperbolicPlane.angles-Tuple{HPolygon}"><code>HyperbolicPlane.angles</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>angles(P::HPolygon)</code> returns a list of the angles at the vertices of <code>P</code>.</p><ul><li>The results are always in the interval <code>[0,pi]</code>.</li><li>The order of the angles is the order of the vertices in <code>P.plist</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.angles-Tuple{HTriangle}" href="#HyperbolicPlane.angles-Tuple{HTriangle}"><code>HyperbolicPlane.angles</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>angles(T::HTriangle)</code> returns a <em>sorted</em> triple containing the angles at the three corners of the triangle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.area-Tuple{HCircle}" href="#HyperbolicPlane.area-Tuple{HCircle}"><code>HyperbolicPlane.area</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>area(C::HCircle)</code> returns the area of the circle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.area-Tuple{HPolygon}" href="#HyperbolicPlane.area-Tuple{HPolygon}"><code>HyperbolicPlane.area</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>area(X::HPolygon)</code> returns the area of the polygon, but is only reliable if <code>X</code> does not self-intersect. See <code>is_simple</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.area-Tuple{HTriangle}" href="#HyperbolicPlane.area-Tuple{HTriangle}"><code>HyperbolicPlane.area</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>area(T::HTriangle)</code> returns the area of the triangle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.between-Tuple{HPoint,HPoint,HPoint}" href="#HyperbolicPlane.between-Tuple{HPoint,HPoint,HPoint}"><code>HyperbolicPlane.between</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>between(a,b,c)</code> determines if the hyperbolic point <code>b</code> lies on the segment from <code>a</code> to <code>c</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.bisector-Tuple{HSegment}" href="#HyperbolicPlane.bisector-Tuple{HSegment}"><code>HyperbolicPlane.bisector</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>bisector(S::HSegment)</code> yields an <code>HLine</code> that&#39;s the perpendicular bisector of the segment <code>S</code>. May also be invoked <code>bisector(A,B)</code> where <code>A</code> and <code>B</code> are points.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.circumference-Tuple{HCircle}" href="#HyperbolicPlane.circumference-Tuple{HCircle}"><code>HyperbolicPlane.circumference</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>circumference(C::HCircle)</code> returns the circumference of the circle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.collinear-Tuple{HPoint,HPoint,HPoint}" href="#HyperbolicPlane.collinear-Tuple{HPoint,HPoint,HPoint}"><code>HyperbolicPlane.collinear</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>collinear</code> checks if the arguments are collinear. Arguments are:</p><ul><li><code>a,b,c</code>: three points</li><li><code>a,L</code>: point and segment (in either order)</li><li><code>L,LL</code>: two segments</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.copy_attr-Tuple{HObject,HObject}" href="#HyperbolicPlane.copy_attr-Tuple{HObject,HObject}"><code>HyperbolicPlane.copy_attr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>copy_attr(A,B)</code> copies the attributes assigned to <code>B</code> into <code>A</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.endpoints-Tuple{HPolygon}" href="#HyperbolicPlane.endpoints-Tuple{HPolygon}"><code>HyperbolicPlane.endpoints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>endpoints(X::HPolygon)</code> returns the list of vertices (in order) of the polygon.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.endpoints-Tuple{HTriangle}" href="#HyperbolicPlane.endpoints-Tuple{HTriangle}"><code>HyperbolicPlane.endpoints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>endpoints(T::HTriangle)</code> returns the corner points of the triangle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.equality_threshold-Tuple{}" href="#HyperbolicPlane.equality_threshold-Tuple{}"><code>HyperbolicPlane.equality_threshold</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>equality_threshold(val)</code> sets the &quot;sloppiness&quot; for equality checking. The default value is 100. In general, two objects are equal if their stored values are within <code>val * eps(1.0)</code>.</p><p>Calling <code>equality_threshold()</code> with no arguments returns the current value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.equiangular-Tuple{Int64,Real}" href="#HyperbolicPlane.equiangular-Tuple{Int64,Real}"><code>HyperbolicPlane.equiangular</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>equiangular(n,theta)</code> creates a regular <code>n</code>-gon where the vertex angles equal <code>theta</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.equilateral-Tuple{Int64,Real}" href="#HyperbolicPlane.equilateral-Tuple{Int64,Real}"><code>HyperbolicPlane.equilateral</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>equilateral(n,s)</code> creates a regular <code>n</code>-gon with side lengths <code>s</code> centered at the origin. First point is on the positive x-axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.get_center-Tuple{HCircle}" href="#HyperbolicPlane.get_center-Tuple{HCircle}"><code>HyperbolicPlane.get_center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>get_center(C::HCircle)</code> returns the center of the circle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.get_radius-Tuple{HCircle}" href="#HyperbolicPlane.get_radius-Tuple{HCircle}"><code>HyperbolicPlane.get_radius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>get_radius(C::HCircle)</code> returns the radius of the circle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.get_vertex-Tuple{HRay}" href="#HyperbolicPlane.get_vertex-Tuple{HRay}"><code>HyperbolicPlane.get_vertex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>get_vertex(R::HRay)</code> returns the vertex (end point) of the ray.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.getz-Tuple{HPoint}" href="#HyperbolicPlane.getz-Tuple{HPoint}"><code>HyperbolicPlane.getz</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>getz(P::HPoint)</code> returns the point (complex number) in the interior of the unit disc that represents <code>P</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.interior_point-Tuple{HTriangle}" href="#HyperbolicPlane.interior_point-Tuple{HTriangle}"><code>HyperbolicPlane.interior_point</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>interior_point(T::HTriangle)</code> returns a point in the interior of the triangle. The interior point is the intersection of the triangle&#39;s medians (the centroid).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.is_simple-Tuple{HPolygon}" href="#HyperbolicPlane.is_simple-Tuple{HPolygon}"><code>HyperbolicPlane.is_simple</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>is_simple(X::HPolygon)</code> determines if the polygon edges do not self-intersect. Be sure the polygon is legit using <code>polygon_check</code> first.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.meet-Tuple{HLine,HLine}" href="#HyperbolicPlane.meet-Tuple{HLine,HLine}"><code>HyperbolicPlane.meet</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>meet(L,LL)</code> finds a point on lines <code>L</code> and <code>LL</code> or throws an error if they don&#39;t intersect.  Also for a line and a segment, or two segments.</p><p>See <code>meet_check</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.meet_check-Tuple{HLine,HLine}" href="#HyperbolicPlane.meet_check-Tuple{HLine,HLine}"><code>HyperbolicPlane.meet_check</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>meet_check(L::HLine,LL::HLine)</code> determines if two lines intersect. Also for any combination of lines, segments, or rays.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.midpoint-Tuple{HPoint,HPoint}" href="#HyperbolicPlane.midpoint-Tuple{HPoint,HPoint}"><code>HyperbolicPlane.midpoint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>midpoint(p,q)</code> finds the mid point of the line segment from <code>p</code> to <code>q</code>. Also <code>midpoint(L::HSegment)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.move2xplus-Tuple{Complex}" href="#HyperbolicPlane.move2xplus-Tuple{Complex}"><code>HyperbolicPlane.move2xplus</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>move2xplus(P::HPoint)</code> returns an isometry of H^2 that maps <code>P</code> onto the positive real axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.move2xplus-Tuple{HLine}" href="#HyperbolicPlane.move2xplus-Tuple{HLine}"><code>HyperbolicPlane.move2xplus</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>move2xplus(L::HLine)</code> returns a linear fractional transformation that maps points on <code>L</code> to the positive x-axis but is <em>not</em> an isometry of the hyperbolic plane.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.move2xplus-Tuple{HPoint,HPoint}" href="#HyperbolicPlane.move2xplus-Tuple{HPoint,HPoint}"><code>HyperbolicPlane.move2xplus</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>move2xplus(A,B)</code> or <code>move2xplus(L::HSegment)</code> gives an isometry <code>f</code> so that <code>f(A)</code> is 0 and <code>f(B)</code> is on the positive real axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.move2zero-Tuple{Complex}" href="#HyperbolicPlane.move2zero-Tuple{Complex}"><code>HyperbolicPlane.move2zero</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>move2zero(P::Hpoint)</code> returns a <code>LFT</code> that&#39;s an isometry of H^2 that maps <code>P</code> to the origin.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.npoints-Tuple{HPolygon}" href="#HyperbolicPlane.npoints-Tuple{HPolygon}"><code>HyperbolicPlane.npoints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>npoints(X::HPolygon)</code> returns the number of points on the polygon.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.perimeter-Tuple{HTriangle}" href="#HyperbolicPlane.perimeter-Tuple{HTriangle}"><code>HyperbolicPlane.perimeter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>perimeter(T::HTriangle)</code> or <code>perimeter(P::HPolygon)</code> returns the perimeter of the figure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.perpendicular-Tuple{HLine,HPoint}" href="#HyperbolicPlane.perpendicular-Tuple{HLine,HPoint}"><code>HyperbolicPlane.perpendicular</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>perpendicular(L::HLine, P::HPoint)</code> returns a line that is perpendicular to <code>L</code> and contains <code>P</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.perpendicular-Tuple{HLine}" href="#HyperbolicPlane.perpendicular-Tuple{HLine}"><code>HyperbolicPlane.perpendicular</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>perpendicular(L)</code> returns an arbitrary line that is perpendicular to <code>L</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.point_on_line-Tuple{HLine}" href="#HyperbolicPlane.point_on_line-Tuple{HLine}"><code>HyperbolicPlane.point_on_line</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>point_on_line(L)</code> returns a point on the hyperbolic line <code>L</code>.</p><p>See also: <code>points_on_line</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.point_on_ray-Tuple{HRay}" href="#HyperbolicPlane.point_on_ray-Tuple{HRay}"><code>HyperbolicPlane.point_on_ray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>point_on_ray(R::HRay)</code> returns a point in the interior of the ray.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.points_on_circle-Tuple{HCircle}" href="#HyperbolicPlane.points_on_circle-Tuple{HCircle}"><code>HyperbolicPlane.points_on_circle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>points_on_circle(C::HCircle)</code> returns a 3-tuple of points that lie on the circle <code>C</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.points_on_line" href="#HyperbolicPlane.points_on_line"><code>HyperbolicPlane.points_on_line</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>points_on_line(L,n)</code> returns a list of <code>n</code> distinct points on the line <code>L</code>.</p><p>See also: <code>point_on_line</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.polar-Tuple{HPoint}" href="#HyperbolicPlane.polar-Tuple{HPoint}"><code>HyperbolicPlane.polar</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>polar(P::HPoint)</code> gives the polar coordinates of <code>P</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.polygon_check" href="#HyperbolicPlane.polygon_check"><code>HyperbolicPlane.polygon_check</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>polygon_check(X::HPolygon,quiet=true)</code> checks that the polygon is nondegenerate. Possible degeneracies are:</p><ul><li>Repeated vertices</li><li>Fewer than three distinct vertices</li><li>Angles that are either 0 degrees or 180 degrees</li></ul><p>If <code>quiet</code> is <code>false</code>, then a reason for the failed check is printed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.reflect_across-Tuple{HPoint,Union{HLine, HSegment}}" href="#HyperbolicPlane.reflect_across-Tuple{HPoint,Union{HLine, HSegment}}"><code>HyperbolicPlane.reflect_across</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>reflect_across(X::HObject,L::HSegment/HLine)</code> returns the object formed by refecting <code>X across the line segment/line</code>L`.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.rotation-Tuple{Real}" href="#HyperbolicPlane.rotation-Tuple{Real}"><code>HyperbolicPlane.rotation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>rotation(theta)</code> is an isometry of H^2 corresponding to a rotation about the origin of the amount <code>theta</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.same_side-Tuple{HPoint,HPoint,HLine}" href="#HyperbolicPlane.same_side-Tuple{HPoint,HPoint,HLine}"><code>HyperbolicPlane.same_side</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>same_side(P,Q,L)</code> determines if the points <code>P</code> and <code>Q</code> lie in the same (closed) halfplane as determined by <code>L</code>. If either point is on <code>L</code> then the result is <code>true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_color" href="#HyperbolicPlane.set_color"><code>HyperbolicPlane.set_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_color(X,col)</code> sets the color of the hyperbolic object <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_fill_alpha" href="#HyperbolicPlane.set_fill_alpha"><code>HyperbolicPlane.set_fill_alpha</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_fill_alpha(X,alpha)</code> sets the alpha value for the object&#39;s fill. Only works for <code>HPlane</code> and <code>HCircle</code>. Default value is 1 (not transparent)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_fill_color" href="#HyperbolicPlane.set_fill_color"><code>HyperbolicPlane.set_fill_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_fill_color(X,col)</code> sets the color used to fill <code>X</code>. Works for <code>HPlane</code> and <code>HCircle</code>. Default is <code>:yellow</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_line_style" href="#HyperbolicPlane.set_line_style"><code>HyperbolicPlane.set_line_style</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_line_style(X,style)</code> sets the line style for drawing <code>X</code>. Default is <code>:solid</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_no_fill-Tuple{Union{HCircle, HPlane, Horocycle}}" href="#HyperbolicPlane.set_no_fill-Tuple{Union{HCircle, HPlane, Horocycle}}"><code>HyperbolicPlane.set_no_fill</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>set_no_fill(X)</code> removes fill from the <code>HObject</code>. It now draws as unfilled.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_radius" href="#HyperbolicPlane.set_radius"><code>HyperbolicPlane.set_radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_radius(P,rad)</code> sets the radius for an <code>HPoint</code>. The default is 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_thickness" href="#HyperbolicPlane.set_thickness"><code>HyperbolicPlane.set_thickness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_thickness(X,thk)</code> sets the thickness of the line used to draw the hyperbolic object <code>X</code>. Default is 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.sides-Tuple{HPolygon}" href="#HyperbolicPlane.sides-Tuple{HPolygon}"><code>HyperbolicPlane.sides</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>sides(P:::HPolygon/HTriangle)</code> returns a list of the line segments that are the sides of the polygon.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.stab_count-Union{Tuple{T}, Tuple{S}, Tuple{S,Array{T,1}}} where T&lt;:Union{HLine, HRay, HSegment} where S&lt;:Union{HLine, HRay, HSegment}" href="#HyperbolicPlane.stab_count-Union{Tuple{T}, Tuple{S}, Tuple{S,Array{T,1}}} where T&lt;:Union{HLine, HRay, HSegment} where S&lt;:Union{HLine, HRay, HSegment}"><code>HyperbolicPlane.stab_count</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>stab_count(R,targets)</code> is used to count how many items in <code>targets</code> are intersected by <code>R</code> where <code>targets</code> is a list of <code>HLinear</code> objects and <code>R</code> is an <code>HLinear</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.tesselation" href="#HyperbolicPlane.tesselation"><code>HyperbolicPlane.tesselation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>tesselation(n,k,deep)</code>: Tesselate the hyperbolic plane by regular <code>n</code>-gons in which each vertex is a corner of <code>k</code> polygons. <code>deep</code> controls how many layers. The center of the first <code>k</code>-gon is placed at the origin.</p><p>May also be called <code>tesselation(n,k,deep,true)</code> in which case a vertex of the first <code>k</code>-gon is placed at the origin and the tesselation is seeded by copies of this first polygon around the origin.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.triangulate-Tuple{HPolygon}" href="#HyperbolicPlane.triangulate-Tuple{HPolygon}"><code>HyperbolicPlane.triangulate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>triangulate(X::HPolygon)</code> returns a list of triangles that triangulate <code>X</code>. The polygon should have at least three sides, and have no bad angles, and not self-intersect.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDrawing.draw-Tuple{HPoint}" href="#SimpleDrawing.draw-Tuple{HPoint}"><code>SimpleDrawing.draw</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>draw(X)</code> draws the hyperbolic object <code>X</code> in a graphics window.</p><p><code>draw</code> may be applied to a list of hyperbolic objects.</p><p>The typical sequence of drawing starts by clearing the screen with the <code>plot()</code> function (from the <code>Plots</code> module), then various to calls to <code>draw</code> and then concludes with a call to <code>finish()</code> (see the help message for that function).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{HPlane}" href="#Base.:--Tuple{HPlane}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>-X</code> where <code>X</code> is a hyperbolic object is a new object reflected through the origin.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.adjoint-Tuple{HPlane}" href="#Base.adjoint-Tuple{HPlane}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>adjoint(X::HObject)</code> (that is, <code>X&#39;</code>) returns a new <code>X</code> that is reflected across the <code>x</code>-axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!-Tuple{HContainer,HObject}" href="#Base.delete!-Tuple{HContainer,HObject}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>delete!(C::HContainer, X::HObject)</code> deletes <code>X</code> from the container <code>C</code> returning <code>true</code> if successful (or <code>false</code> if <code>X</code> was not in the container).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.in-Tuple{HPoint,HPolygon}" href="#Base.in-Tuple{HPoint,HPolygon}"><code>Base.in</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>in(p::HPoint, X::HPolygon)</code> determines if the point lies on the boundary or, or is interior to, the polygon. Be sure that <code>polygon_check(X)</code> and <code>is_simple(X)</code> both return <code>true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.in-Tuple{HPoint,HRay}" href="#Base.in-Tuple{HPoint,HRay}"><code>Base.in</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>in(P::HPoint, R::HRay)</code> determine if <code>P</code> lies on the ray <code>R</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.in-Tuple{HPoint,HTriangle}" href="#Base.in-Tuple{HPoint,HTriangle}"><code>Base.in</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>in(P::HPoint, T::HTriangle)</code> determines if <code>P</code> is in the triangle <code>T</code>, either in one of its sides or in its interior.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane._cycle-Union{Tuple{T}, Tuple{Array{T,1},Int64}} where T" href="#HyperbolicPlane._cycle-Union{Tuple{T}, Tuple{Array{T,1},Int64}} where T"><code>HyperbolicPlane._cycle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>_cycle(A,k)</code> returns a <code>k</code>-step shift of <code>A</code>. We require <code>k</code> to be in the interval <code>[0,n-1]</code> where <code>n=length(A)</code>. No checking is done.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane._cyclic_equal-Union{Tuple{T}, Tuple{S}, Tuple{Array{S,1},Array{T,1}}} where T where S" href="#HyperbolicPlane._cyclic_equal-Union{Tuple{T}, Tuple{S}, Tuple{Array{S,1},Array{T,1}}} where T where S"><code>HyperbolicPlane._cyclic_equal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>_cyclic_equal(A,B)</code> checks if some cyclic shift of one list equals the other.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane._solver-Tuple{Function,Real,Real,Real}" href="#HyperbolicPlane._solver-Tuple{Function,Real,Real,Real}"><code>HyperbolicPlane._solver</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>_solver(f,goal,lo,hi)</code> assumes <code>f</code> is increasing on the interval <code>[lo,hi]</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane._solver-Tuple{Function,Real}" href="#HyperbolicPlane._solver-Tuple{Function,Real}"><code>HyperbolicPlane._solver</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>_solver(f,goal)</code> assumes that <code>f</code> is increasing and there is a nonnegative <code>x</code> so that <code>f(x)==goal</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.alt_mod-Tuple{Int64,Int64}" href="#HyperbolicPlane.alt_mod-Tuple{Int64,Int64}"><code>HyperbolicPlane.alt_mod</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>alt_mod(k,n)</code> is <code>mod(k,n)</code> unless the result is zero, in which case we return <code>n</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.check_diagonal-Tuple{HPolygon,Int64}" href="#HyperbolicPlane.check_diagonal-Tuple{HPolygon,Int64}"><code>HyperbolicPlane.check_diagonal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>check_diagonal(X::HPolygon, k::Int)</code> checks to see if the diagonal between vertices <code>k-1</code> and <code>k+1</code> (a) does not intersect the boundary of <code>X</code> and (b) goes through the interior of <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.expander-Tuple{HPolygon}" href="#HyperbolicPlane.expander-Tuple{HPolygon}"><code>HyperbolicPlane.expander</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>expander(P::HPolygon)</code> returns a list of polygons formed by reflecting <code>P</code> across each of its sides.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.find_ear_diagonal-Tuple{HPolygon}" href="#HyperbolicPlane.find_ear_diagonal-Tuple{HPolygon}"><code>HyperbolicPlane.find_ear_diagonal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>find_ear_diagonal(X::HPolygon)</code> returns an index <code>k</code> such that the diagonal from <code>k-1</code> to <code>k+1</code> passes <code>check_diagonal</code>. Returns <code>0</code> if no ear diagonal is found.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.solve_dist-Tuple{Real}" href="#HyperbolicPlane.solve_dist-Tuple{Real}"><code>HyperbolicPlane.solve_dist</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>solve_dist(d)</code> is the inverse of <code>_dist()</code></p></div></div></section><footer><hr/></footer></article></body></html>
