<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · CrossMappings.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CrossMappings.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CrossMappings.ccm-Tuple{Any,Any,Any}" href="#CrossMappings.ccm-Tuple{Any,Any,Any}"><code>CrossMappings.ccm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ccm(driver,
        response,
        timeseries_lengths;
        kwargs...) -&gt; Vector{Vector{Float64}}</code></pre><p><strong>Algorithm</strong></p><p>Compute the cross mapping between a <code>driver</code> series and a <code>response</code> series over different <code>timeseries_lengths</code>.</p><p><strong>Arguments</strong></p><ul><li><strong><code>driver</code></strong>: The data series representing the putative driver process.</li><li><strong><code>response</code></strong>: The data series representing the putative response process.</li><li><strong><code>timeseries_lengths</code></strong>: Time series length(s) for which to compute the   cross mapping(s).</li></ul><p><strong>Keyword arguments to <code>crossmap</code></strong></p><ul><li><strong><code>dim</code></strong>: The dimension of the state space reconstruction (delay embedding)   constructed from the <code>response</code> series. Default is <code>dim = 3</code>.</li><li><strong><code>τ</code></strong>: The embedding lag for the delay embedding constructed from <code>response</code>.   Default is <code>τ = 1</code>.</li><li><strong><code>ν</code></strong>: The prediction lag to use when predicting scalar values of <code>driver</code>   fromthe delay embedding of <code>response</code>.   <code>ν &gt; 0</code> are forward lags (causal; <code>driver</code>&#39;s past influences <code>response</code>&#39;s future),   and <code>ν &lt; 0</code> are backwards lags (non-causal; <code>driver</code>&#39;s&#39; future influences   <code>response</code>&#39;s past). Adjust the prediction lag if you   want to performed lagged ccm   <a href="https://www.nature.com/articles/srep14750">(Ye et al., 2015)</a>.   Default is <code>ν = 0</code>, as in   <a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">Sugihara et al. (2012)</a>.   <em>Note: The sign of the lag <code>ν</code> is organized to conform with the conventions in   <a href=".">TransferEntropy.jl</a>, and is opposite to the convention used in the   <a href="https://cran.r-project.org/web/packages/rEDM/index.html"><code>rEDM</code></a> package   (<a href="https://cran.r-project.org/web/packages/rEDM/index.html">Ye et al., 2016</a>).</em></li><li><strong><code>libsize</code></strong>: Among how many delay embedding points should we sample time indices   and look for nearest neighbours at each cross mapping realization (of which there   are <code>n_reps</code>)?</li><li><strong><code>n_reps</code></strong>: The number of times we draw a library of <code>libsize</code> points from the   delay embedding of <code>response</code> and try to predict <code>driver</code> values. Equivalently,   how many times do we cross map for this value of <code>libsize</code>?   Default is <code>n_reps = 100</code>.</li><li><strong><code>replace</code></strong>: Sample delay embedding points with replacement? Default is <code>replace = true</code>.</li><li><strong><code>exclusion_radius</code></strong>: How many temporal neighbors of the delay embedding   point <code>response_embedding(t)</code> to exclude when searching for neighbors to   determine weights for predicting the scalar point <code>driver(t + ν)</code>.   Default is <code>exclusion_radius = 0</code>.</li><li><strong><code>which_is_surr</code></strong>: Which data series should be replaced by a surrogate   realization of the type given by <code>surr_type</code>? Must be one of the   following: <code>:response</code>, <code>:driver</code>, <code>:none</code>, <code>:both</code>.   Default is <code>:none</code>.</li><li><strong><code>surr_func</code></strong>: A valid surrogate function from TimeseriesSurrogates.jl.</li><li><strong><code>tree_type</code></strong>: The type of tree to build when looking for nearest neighbors.   Must be a tree type from NearestNeighbors.jl. For now, this is either   <code>BruteTree</code>, <code>KDTree</code> or <code>BallTree</code>.</li><li><strong><code>distance_metric</code></strong>: An instance of a <code>Metric</code> from Distances.jl. <code>BallTree</code> and <code>BruteTree</code> work with any <code>Metric</code>.   <code>KDTree</code> only works with the axis aligned metrics <code>Euclidean</code>, <code>Chebyshev</code>,   <code>Minkowski</code> and <code>Cityblock</code>. Default is <code>metric = Euclidean()</code> <em>(note the instantiation of the metric)</em>.</li><li><strong><code>correspondence_measure</code></strong>: The function that computes the correspondence   between actual values of <code>driver</code> and predicted values. Can be any   function returning a similarity measure between two vectors of values.   Default is <code>correspondence_measure = StatsBase.cor</code>, which returns values on <span>$[-1, 1]$</span>.   In this case, any negative values are usually filtered out (interpreted as zero coupling) and   a value of <span>$1$</span> means perfect prediction.   <a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">Sugihara et al. (2012)</a>   also proposes to use the root mean square deviation, for which a value of <span>$0$</span> would   be perfect prediction.</li></ul><p><strong>References</strong></p><p>Sugihara, George, et al. &quot;Detecting causality in complex ecosystems.&quot; Science (2012): 1227079. <a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">http://science.sciencemag.org/content/early/2012/09/19/science.1227079</a></p><p>Ye, Hao, et al. &quot;Distinguishing time-delayed causal interactions using convergent cross mapping.&quot; Scientific Reports 5 (2015): 14750. <a href="https://www.nature.com/articles/srep14750">https://www.nature.com/articles/srep14750</a></p><p>Ye, H., et al. &quot;rEDM: Applications of empirical dynamic modeling from time series.&quot; R Package Version 0.4 7 (2016). <a href="https://cran.r-project.org/web/packages/rEDM/index.html">https://cran.r-project.org/web/packages/rEDM/index.html</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CrossMappings.ccm_with_summary-Tuple{Any,Any,Any}" href="#CrossMappings.ccm_with_summary-Tuple{Any,Any,Any}"><code>CrossMappings.ccm_with_summary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ccm_with_summary(driver,
        response,
        timeseries_lengths;
        average_measure::Symbol = :median,
        uncertainty_measure::Symbol = :quantile,
        quantiles = [0.327, 0.673],
        kwargs...)</code></pre><p><strong>Algorithm</strong></p><p>Compute the cross mapping between a <code>driver</code> series and a <code>response</code> series over different <code>timeseries_lengths</code> and return summary statistics of the results.</p><p><strong>Arguments</strong></p><ul><li><strong><code>driver</code></strong>: The data series representing the putative driver process.</li><li><strong><code>response</code></strong>: The data series representing the putative response process.</li><li><strong><code>timeseries_lengths</code></strong>: Time series length(s) for which to compute the   cross mapping(s).</li></ul><p><strong>Summary keyword arguments</strong></p><ul><li><strong><code>average_measure</code></strong>: Either <code>:median</code> or <code>:mean</code>. Default is <code>:median</code>.</li><li><strong><code>uncertainty_measure</code></strong>: Either <code>:quantile</code> or <code>:std</code>. Default is <code>:quantile</code>.</li><li><strong><code>quantiles</code></strong>: Compute uncertainty over quantile(s) if <code>uncertainty_measure</code>   is <code>:quantile</code>. Default is <code>[0.327, 0.673]</code>, roughly corresponding to 1s for   normally distributed data.</li></ul><p><strong>Keyword arguments to <code>crossmap</code></strong></p><ul><li><strong><code>dim</code></strong>: The dimension of the state space reconstruction (delay embedding)   constructed from the <code>response</code> series. Default is <code>dim = 3</code>.</li><li><strong><code>τ</code></strong>: The embedding lag for the delay embedding constructed from <code>response</code>.   Default is <code>τ = 1</code>.</li><li><strong><code>ν</code></strong>: The prediction lag to use when predicting scalar values of <code>driver</code>   fromthe delay embedding of <code>response</code>.   <code>ν &gt; 0</code> are forward lags (causal; <code>driver</code>&#39;s past influences <code>response</code>&#39;s future),   and <code>ν &lt; 0</code> are backwards lags (non-causal; <code>driver</code>&#39;s&#39; future influences   <code>response</code>&#39;s past). Adjust the prediction lag if you   want to performed lagged ccm   <a href="https://www.nature.com/articles/srep14750">(Ye et al., 2015)</a>.   Default is <code>ν = 0</code>, as in   <a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">Sugihara et al. (2012)</a>.   <em>Note: The sign of the lag <code>ν</code> is organized to conform with the conventions in   <a href=".">TransferEntropy.jl</a>, and is opposite to the convention used in the   <a href="https://cran.r-project.org/web/packages/rEDM/index.html"><code>rEDM</code></a> package   (<a href="https://cran.r-project.org/web/packages/rEDM/index.html">Ye et al., 2016</a>).</em></li><li><strong><code>libsize</code></strong>: Among how many delay embedding points should we sample time indices   and look for nearest neighbours at each cross mapping realization (of which there   are <code>n_reps</code>)?</li><li><strong><code>n_reps</code></strong>: The number of times we draw a library of <code>libsize</code> points from the   delay embedding of <code>response</code> and try to predict <code>driver</code> values. Equivalently,   how many times do we cross map for this value of <code>libsize</code>?   Default is <code>n_reps = 100</code>.</li><li><strong><code>replace</code></strong>: Sample delay embedding points with replacement? Default is <code>replace = true</code>.</li><li><strong><code>exclusion_radius</code></strong>: How many temporal neighbors of the delay embedding   point <code>response_embedding(t)</code> to exclude when searching for neighbors to   determine weights for predicting the scalar point <code>driver(t + ν)</code>.   Default is <code>exclusion_radius = 0</code>.</li><li><strong><code>which_is_surr</code></strong>: Which data series should be replaced by a surrogate   realization of the type given by <code>surr_type</code>? Must be one of the   following: <code>:response</code>, <code>:driver</code>, <code>:none</code>, <code>:both</code>.   Default is <code>:none</code>.</li><li><strong><code>surr_func</code></strong>: A valid surrogate function from TimeseriesSurrogates.jl.</li><li><strong><code>tree_type</code></strong>: The type of tree to build when looking for nearest neighbors.   Must be a tree type from NearestNeighbors.jl. For now, this is either   <code>BruteTree</code>, <code>KDTree</code> or <code>BallTree</code>.</li><li><strong><code>distance_metric</code></strong>: An instance of a <code>Metric</code> from Distances.jl. <code>BallTree</code> and <code>BruteTree</code> work with any <code>Metric</code>.   <code>KDTree</code> only works with the axis aligned metrics <code>Euclidean</code>, <code>Chebyshev</code>,   <code>Minkowski</code> and <code>Cityblock</code>. Default is <code>metric = Euclidean()</code> <em>(note the instantiation of the metric)</em>.</li><li><strong><code>correspondence_measure</code></strong>: The function that computes the correspondence   between actual values of <code>driver</code> and predicted values. Can be any   function returning a similarity measure between two vectors of values.   Default is <code>correspondence_measure = StatsBase.cor</code>, which returns values on <span>$[-1, 1]$</span>.   In this case, any negative values are usually filtered out (interpreted as zero coupling) and   a value of <span>$1$</span> means perfect prediction.   <a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">Sugihara et al. (2012)</a>   also proposes to use the root mean square deviation, for which a value of <span>$0$</span> would   be perfect prediction.</li></ul><p><strong>References</strong></p><p>Sugihara, George, et al. &quot;Detecting causality in complex ecosystems.&quot; Science (2012): 1227079. <a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">http://science.sciencemag.org/content/early/2012/09/19/science.1227079</a></p><p>Ye, Hao, et al. &quot;Distinguishing time-delayed causal interactions using convergent cross mapping.&quot; Scientific Reports 5 (2015): 14750. <a href="https://www.nature.com/articles/srep14750">https://www.nature.com/articles/srep14750</a></p><p>Ye, H., et al. &quot;rEDM: Applications of empirical dynamic modeling from time series.&quot; R Package Version 0.4 7 (2016). <a href="https://cran.r-project.org/web/packages/rEDM/index.html">https://cran.r-project.org/web/packages/rEDM/index.html</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CrossMappings.convergentcrossmap-Tuple{Any,Any,Any}" href="#CrossMappings.convergentcrossmap-Tuple{Any,Any,Any}"><code>CrossMappings.convergentcrossmap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convergentcrossmap(driver,
        response,
        timeseries_lengths;
        summarise::Bool = true,
        average_measure::Symbol = :median,
        uncertainty_measure::Symbol = :quantile,
        quantiles = [0.327, 0.673],
        kwargs...)</code></pre><p><strong>Algorithm</strong></p><p>Compute the cross mapping between a <code>driver</code> series and a <code>response</code> series over different <code>timeseries_lengths</code>. If <code>summarise = true</code>, then call <code>ccm_with_summary</code>. If <code>summarise = false</code>, then call <code>ccm</code> (returns raw crossmap skills).</p><p><strong>Arguments</strong></p><ul><li><strong><code>driver</code></strong>: The data series representing the putative driver process.</li><li><strong><code>response</code></strong>: The data series representing the putative response process.</li><li><strong><code>timeseries_lengths</code></strong>: Time series length(s) for which to compute the   cross mapping(s).</li></ul><p><strong>Summary keyword arguments</strong></p><ul><li><strong><code>summarise</code></strong>: Should cross map skills be summarised for each time series length?   Default is <code>summarise = true</code>.</li><li><strong><code>average_measure</code></strong>: Either <code>:median</code> or <code>:mean</code>. Default is <code>:median</code>.</li><li><strong><code>uncertainty_measure</code></strong>: Either <code>:quantile</code> or <code>:std</code>. Default is <code>:quantile</code>.</li><li><strong><code>quantiles</code></strong>: Compute uncertainty over quantile(s) if <code>uncertainty_measure</code>   is <code>:quantile</code>. Default is <code>[0.327, 0.673]</code>, roughly corresponding to 1s for   normally distributed data.</li></ul><p><strong>Keyword arguments to <code>crossmap</code></strong></p><ul><li><strong><code>dim</code></strong>: The dimension of the state space reconstruction (delay embedding)   constructed from the <code>response</code> series. Default is <code>dim = 3</code>.</li><li><strong><code>τ</code></strong>: The embedding lag for the delay embedding constructed from <code>response</code>.   Default is <code>τ = 1</code>.</li><li><strong><code>ν</code></strong>: The prediction lag to use when predicting scalar values of <code>driver</code>   fromthe delay embedding of <code>response</code>.   <code>ν &gt; 0</code> are forward lags (causal; <code>driver</code>&#39;s past influences <code>response</code>&#39;s future),   and <code>ν &lt; 0</code> are backwards lags (non-causal; <code>driver</code>&#39;s&#39; future influences   <code>response</code>&#39;s past). Adjust the prediction lag if you   want to performed lagged ccm   <a href="https://www.nature.com/articles/srep14750">(Ye et al., 2015)</a>.   Default is <code>ν = 0</code>, as in   <a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">Sugihara et al. (2012)</a>.   <em>Note: The sign of the lag <code>ν</code> is organized to conform with the conventions in   <a href=".">TransferEntropy.jl</a>, and is opposite to the convention used in the   <a href="https://cran.r-project.org/web/packages/rEDM/index.html"><code>rEDM</code></a> package   (<a href="https://cran.r-project.org/web/packages/rEDM/index.html">Ye et al., 2016</a>).</em></li><li><strong><code>libsize</code></strong>: Among how many delay embedding points should we sample time indices   and look for nearest neighbours at each cross mapping realization (of which there   are <code>n_reps</code>)?</li><li><strong><code>n_reps</code></strong>: The number of times we draw a library of <code>libsize</code> points from the   delay embedding of <code>response</code> and try to predict <code>driver</code> values. Equivalently,   how many times do we cross map for this value of <code>libsize</code>?   Default is <code>n_reps = 100</code>.</li><li><strong><code>replace</code></strong>: Sample delay embedding points with replacement? Default is <code>replace = true</code>.</li><li><strong><code>exclusion_radius</code></strong>: How many temporal neighbors of the delay embedding   point <code>response_embedding(t)</code> to exclude when searching for neighbors to   determine weights for predicting the scalar point <code>driver(t + ν)</code>.   Default is <code>exclusion_radius = 0</code>.</li><li><strong><code>which_is_surr</code></strong>: Which data series should be replaced by a surrogate   realization of the type given by <code>surr_type</code>? Must be one of the   following: <code>:response</code>, <code>:driver</code>, <code>:none</code>, <code>:both</code>.   Default is <code>:none</code>.</li><li><strong><code>surr_func</code></strong>: A valid surrogate function from TimeseriesSurrogates.jl.</li><li><strong><code>tree_type</code></strong>: The type of tree to build when looking for nearest neighbors.   Must be a tree type from NearestNeighbors.jl. For now, this is either   <code>BruteTree</code>, <code>KDTree</code> or <code>BallTree</code>.</li><li><strong><code>distance_metric</code></strong>: An instance of a <code>Metric</code> from Distances.jl. <code>BallTree</code> and <code>BruteTree</code> work with any <code>Metric</code>.   <code>KDTree</code> only works with the axis aligned metrics <code>Euclidean</code>, <code>Chebyshev</code>,   <code>Minkowski</code> and <code>Cityblock</code>. Default is <code>metric = Euclidean()</code> <em>(note the instantiation of the metric)</em>.</li><li><strong><code>correspondence_measure</code></strong>: The function that computes the correspondence   between actual values of <code>driver</code> and predicted values. Can be any   function returning a similarity measure between two vectors of values.   Default is <code>correspondence_measure = StatsBase.cor</code>, which returns values on <span>$[-1, 1]$</span>.   In this case, any negative values are usually filtered out (interpreted as zero coupling) and   a value of <span>$1$</span> means perfect prediction.   <a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">Sugihara et al. (2012)</a>   also proposes to use the root mean square deviation, for which a value of <span>$0$</span> would   be perfect prediction.</li></ul><p><strong>References</strong></p><p>Sugihara, George, et al. &quot;Detecting causality in complex ecosystems.&quot; Science (2012): 1227079. <a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">http://science.sciencemag.org/content/early/2012/09/19/science.1227079</a></p><p>Ye, Hao, et al. &quot;Distinguishing time-delayed causal interactions using convergent cross mapping.&quot; Scientific Reports 5 (2015): 14750. <a href="https://www.nature.com/articles/srep14750">https://www.nature.com/articles/srep14750</a></p><p>Ye, H., et al. &quot;rEDM: Applications of empirical dynamic modeling from time series.&quot; R Package Version 0.4 7 (2016). <a href="https://cran.r-project.org/web/packages/rEDM/index.html">https://cran.r-project.org/web/packages/rEDM/index.html</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CrossMappings.crossmap-Tuple{Any,Any}" href="#CrossMappings.crossmap-Tuple{Any,Any}"><code>CrossMappings.crossmap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">crossmap(driver, response;
    dim::Int = 3,
    τ::Int = 1,
    libsize::Int = 10,
    replace::Bool = false,
    n_reps::Int = 100,
    surr_func::Function = randomshuffle,
    which_is_surr::Symbol = :none,
    exclusion_radius::Int = 0,
    tree_type = NearestNeighbors.KDTree,
    distance_metric = Distances.Euclidean(),
    correspondence_measure = StatsBase.cor,
    ν::Int = 0)</code></pre><p><strong>Algorithm</strong></p><p>Compute the cross mapping between a <code>driver</code> series and a <code>response</code> series.</p><p><strong>Arguments</strong></p><ul><li><strong><code>driver</code></strong>: The data series representing the putative driver process.</li><li><strong><code>response</code></strong>: The data series representing the putative response process.</li><li><strong><code>dim</code></strong>: The dimension of the state space reconstruction (delay embedding)   constructed from the <code>response</code> series. Default is <code>dim = 3</code>.</li><li><strong><code>τ</code></strong>: The embedding lag for the delay embedding constructed from <code>response</code>.   Default is <code>τ = 1</code>.</li><li><strong><code>ν</code></strong>: The prediction lag to use when predicting scalar values of <code>driver</code>   fromthe delay embedding of <code>response</code>.   <code>ν &gt; 0</code> are forward lags (causal; <code>driver</code>&#39;s past influences <code>response</code>&#39;s future),   and <code>ν &lt; 0</code> are backwards lags (non-causal; <code>driver</code>&#39;s&#39; future influences   <code>response</code>&#39;s past). Adjust the prediction lag if you   want to performed lagged ccm   <a href="https://www.nature.com/articles/srep14750">(Ye et al., 2015)</a>.   Default is <code>ν = 0</code>, as in   <a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">Sugihara et al. (2012)</a>.   <em>Note: The sign of the lag <code>ν</code> is organized to conform with the conventions in   <a href=".">TransferEntropy.jl</a>, and is opposite to the convention used in the   <a href="https://cran.r-project.org/web/packages/rEDM/index.html"><code>rEDM</code></a> package   (<a href="https://cran.r-project.org/web/packages/rEDM/index.html">Ye et al., 2016</a>).</em></li><li><strong><code>libsize</code></strong>: Among how many delay embedding points should we sample time indices   and look for nearest neighbours at each cross mapping realization (of which there   are <code>n_reps</code>)?</li><li><strong><code>n_reps</code></strong>: The number of times we draw a library of <code>libsize</code> points from the   delay embedding of <code>response</code> and try to predict <code>driver</code> values. Equivalently,   how many times do we cross map for this value of <code>libsize</code>?   Default is <code>n_reps = 100</code>.</li><li><strong><code>replace</code></strong>: Sample delay embedding points with replacement? Default is <code>replace = true</code>.</li><li><strong><code>exclusion_radius</code></strong>: How many temporal neighbors of the delay embedding   point <code>response_embedding(t)</code> to exclude when searching for neighbors to   determine weights for predicting the scalar point <code>driver(t + ν)</code>.   Default is <code>exclusion_radius = 0</code>.</li><li><strong><code>which_is_surr</code></strong>: Which data series should be replaced by a surrogate   realization of the type given by <code>surr_type</code>? Must be one of the   following: <code>:response</code>, <code>:driver</code>, <code>:none</code>, <code>:both</code>.   Default is <code>:none</code>.</li><li><strong><code>surr_func</code></strong>: A valid surrogate function from TimeseriesSurrogates.jl.</li><li><strong><code>tree_type</code></strong>: The type of tree to build when looking for nearest neighbors.   Must be a tree type from NearestNeighbors.jl. For now, this is either   <code>BruteTree</code>, <code>KDTree</code> or <code>BallTree</code>.</li><li><strong><code>distance_metric</code></strong>: An instance of a <code>Metric</code> from Distances.jl. <code>BallTree</code> and <code>BruteTree</code> work with any <code>Metric</code>.   <code>KDTree</code> only works with the axis aligned metrics <code>Euclidean</code>, <code>Chebyshev</code>,   <code>Minkowski</code> and <code>Cityblock</code>. Default is <code>metric = Euclidean()</code> <em>(note the instantiation of the metric)</em>.</li><li><strong><code>correspondence_measure</code></strong>: The function that computes the correspondence   between actual values of <code>driver</code> and predicted values. Can be any   function returning a similarity measure between two vectors of values.   Default is <code>correspondence_measure = StatsBase.cor</code>, which returns values on <span>$[-1, 1]$</span>.   In this case, any negative values are usually filtered out (interpreted as zero coupling) and   a value of <span>$1$</span> means perfect prediction.   <a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">Sugihara et al. (2012)</a>   also proposes to use the root mean square deviation, for which a value of <span>$0$</span> would   be perfect prediction.</li></ul><p><strong>References</strong></p><p>Sugihara, George, et al. &quot;Detecting causality in complex ecosystems.&quot; Science (2012): 1227079. <a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">http://science.sciencemag.org/content/early/2012/09/19/science.1227079</a></p><p>Ye, Hao, et al. &quot;Distinguishing time-delayed causal interactions using convergent cross mapping.&quot; Scientific Reports 5 (2015): 14750. <a href="https://www.nature.com/articles/srep14750">https://www.nature.com/articles/srep14750</a></p><p>Ye, H., et al. &quot;rEDM: Applications of empirical dynamic modeling from time series.&quot; R Package Version 0.4 7 (2016). <a href="https://cran.r-project.org/web/packages/rEDM/index.html">https://cran.r-project.org/web/packages/rEDM/index.html</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CrossMappings.predict_point!-NTuple{7,Any}" href="#CrossMappings.predict_point!-NTuple{7,Any}"><code>CrossMappings.predict_point!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">predict_point!(predictions, i, driver_values, u, w, dists, dim)</code></pre><p>The prediction part of the convergent cross mapping algorithm.</p><p><strong>Algorithm</strong></p><p>Consider the point in the delay embedding of <code>response</code> point with time index <code>i</code>. Denote the time indices of its nearest neighbors <span>$t_1, t_2, \ldots, t_{dim+1}$</span>. Denote the scalar values of <code>driver</code> at those time indices <span>$y_1, y_2, \ldots, y_{dim+1}$</span>.</p><p>Given <code>distances</code> <span>$d_1, d_2, \ldots, d_{dim+1}$</span> from the <code>i</code>-th point to its nearest neighbors, we compute the weights <code>w</code> from the cross mapping algorithm (<a href="http://science.sciencemag.org/content/sci/suppl/2012/09/19/science.1227079.DC1/Sugihara.SM.pdf">Sugihara et al, 2012; supplementary material, page 4</a>). The weights <code>w</code> and coefficients <code>u</code> are stored in pre-allocated vectors.</p><p>A prediction for the observation with time index <code>i</code> in the <code>driver</code> timeseries, call it <span>$\hat{y}(i)$</span>, is computed as the sum</p><div>\[\hat{y}(i) = \sum_{j=1}^{dim+1} w_j y_j.\]</div><p>We store the prediction <span>$\hat{y}(i)$</span> in position <code>i</code> of the pre-allocated vector <code>predictions</code>.</p><p><strong>Arguments</strong></p><ul><li><strong><code>predictions</code></strong>: A pre-allocated vector in which to store the   prediction for the scalar value of the <code>driver</code> series.</li><li><strong><code>i</code></strong>: The time index of the point of the <code>driver</code> series being   predicted. The prediction is stored in <code>predictions[i]</code>.</li><li><strong><code>driver_values</code></strong>: Let <span>$t_1, t_2, \ldots, t_{dim + 1}$</span> be   the time indices of   the nearest neighbors to the delay embedding point with time   index <code>i</code>. <code>driver_values</code> contains the scalar values of the   <code>driver</code> series at those time indices.</li><li><strong><code>u</code></strong>: A pre-allocated vector of length <code>dim + 1</code> that holds the   normalisation coefficients for computing the weights in the   cross mapping algorithm.</li><li><strong><code>w</code></strong>: A pre-allocated vector of length <code>dim + 1</code> that holds   the computed weights for the cross mapping algorithm.</li><li><strong><code>dists</code></strong>: The distances from delay embedding point with time index   <code>i</code> to its <code>dim + 1</code> nearest neighbors, in order of increasing   distances.</li><li><strong><code>dim</code></strong>: The dimension of the delay embedding.</li></ul><p><strong>References</strong></p><p>Sugihara, George, et al. &quot;Detecting causality in complex ecosystems.&quot; Science (2012): 1227079. <a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">http://science.sciencemag.org/content/early/2012/09/19/science.1227079</a></p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
