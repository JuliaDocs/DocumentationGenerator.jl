<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Low-level building blocks · DynamicHMC.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DynamicHMC.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Overview</a></li><li><a class="toctext" href="../api/">High-level API</a></li><li class="current"><a class="toctext" href>Low-level building blocks</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Low-level-building-blocks-1">Low-level building blocks</a></li><li><a class="toctext" href="#Hamiltonian-and-leapfrog-1">Hamiltonian and leapfrog</a></li><li><a class="toctext" href="#Finding-initial-stepsize-\\epsilon-1">Finding initial stepsize <span>$\epsilon$</span></a></li><li><a class="toctext" href="#Dual-averaging-1">Dual averaging</a></li><li><a class="toctext" href="#Abstract-trajectory-interface-1">Abstract trajectory interface</a></li><li><a class="toctext" href="#Proposals-1">Proposals</a></li><li><a class="toctext" href="#Divergence-statistics-1">Divergence statistics</a></li><li><a class="toctext" href="#Turn-analysis-1">Turn analysis</a></li><li><a class="toctext" href="#Sampling-1">Sampling</a></li><li><a class="toctext" href="#Tuning-1">Tuning</a></li><li><a class="toctext" href="#diagnostics_lowlevel-1">Diagnostics</a></li><li><a class="toctext" href="#Reporting-information-during-runs-1">Reporting information during runs</a></li><li><a class="toctext" href="#Utilities-and-miscellanea-1">Utilities and miscellanea</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Low-level building blocks</a></li></ul></nav><hr/><div id="topbar"><span>Low-level building blocks</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Notation-1" href="#Notation-1">Notation</a></h1><p>Notation follows <a href="https://arxiv.org/abs/1701.02434">Betancourt (2017)</a>, with some differences.</p><p>Instead of energies, <em>negative</em> energies are used in the code.</p><p>The following are used consistently for variables:</p><ul><li><code>ℓ</code>: log density we sample from, supports the interface of <a href="https://github.com/tpapp/LogDensityProblems.jl">LogDensityProblems.AbstractLogDensityProblem</a></li><li><code>κ</code>: distribution/density that corresponds to kinetic energy</li><li><code>H</code>: Hamiltonian</li><li><code>q</code>: position</li><li><code>p</code>: momentum</li><li><code>z</code>: point in phase space (q,p)</li><li><code>ϵ</code>: stepsize</li><li><code>a</code>: acceptance rate</li><li><code>A</code>: acceptance tuning state</li><li><code>ζ</code>: proposal from trajectory (phase point and weight)</li><li><code>τ</code>: turn statistic</li><li><code>d</code>: divergence statistic</li><li><code>π</code>: log density (<strong>different from papers</strong>)</li><li><code>Δ</code>: logdensity relative to initial point of trajectory</li></ul><h1><a class="nav-anchor" id="Low-level-building-blocks-1" href="#Low-level-building-blocks-1">Low-level building blocks</a></h1><p>This is documented only for developers. These are not part of the public API, if you are using them you should reconsider or file an issue.</p><h2><a class="nav-anchor" id="Hamiltonian-and-leapfrog-1" href="#Hamiltonian-and-leapfrog-1">Hamiltonian and leapfrog</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.Hamiltonian" href="#DynamicHMC.Hamiltonian"><code>DynamicHMC.Hamiltonian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Hamiltonian(ℓ, κ)</code></pre><p>Construct a Hamiltonian from the log density <code>ℓ</code>, and the kinetic energy specification <code>κ</code>. Calls of <code>ℓ</code> with a vector are expected to return a value that supports <code>DiffResults.value</code> and <code>DiffResults.gradient</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.PhasePoint" href="#DynamicHMC.PhasePoint"><code>DynamicHMC.PhasePoint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct PhasePoint{T, S&lt;:LogDensityProblems.ValueGradient}</code></pre><p>A point in phase space, consists of a position and a momentum.</p><p>Log densities and gradients are saved for speed gains, so that the gradient of ℓ at q is not calculated twice for every leapfrog step (both as start- and endpoints).</p><p>Because of caching, a <code>PhasePoint</code> should only be used with a specific Hamiltonian.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.phasepoint_in" href="#DynamicHMC.phasepoint_in"><code>DynamicHMC.phasepoint_in</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phasepoint_in(H::Hamiltonian, q, p)</code></pre><p>The recommended interface for creating a phase point in a Hamiltonian. Computes cached values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.rand_phasepoint" href="#DynamicHMC.rand_phasepoint"><code>DynamicHMC.rand_phasepoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rand_phasepoint(rng, H, q)
</code></pre><p>Extend a position <code>q</code> to a phasepoint with a random momentum according to the kinetic energy of <code>H</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.neg_energy" href="#DynamicHMC.neg_energy"><code>DynamicHMC.neg_energy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">neg_energy(κ, p)
neg_energy(κ, p, q)
</code></pre><p>Return the log density of kinetic energy <code>κ</code>, at momentum <code>p</code>. Some kinetic energies (eg Riemannian geometry) will need <code>q</code>, too.</p></div></div><div><div><pre><code class="language-julia">neg_energy(H, z)
</code></pre><p>Log density for Hamiltonian <code>H</code> at point <code>z</code>.</p><p>If <code>ℓ(q) == -Inf</code> (rejected), ignores the kinetic energy.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.get_p♯" href="#DynamicHMC.get_p♯"><code>DynamicHMC.get_p♯</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">get_p♯(κ, p)
get_p♯(κ, p, q)
</code></pre><p>Return <span>$p♯$</span>, used for turn diagnostics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.loggradient" href="#DynamicHMC.loggradient"><code>DynamicHMC.loggradient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">loggradient(κ, p)
loggradient(κ, p, q)
</code></pre><p>Calculate the gradient of the logarithm of kinetic energy at momentum <code>p</code> and position <code>q</code>; the latter is ignored for Gaussian kinetic energies.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.leapfrog" href="#DynamicHMC.leapfrog"><code>DynamicHMC.leapfrog</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">leapfrog(H, z, ϵ)</code></pre><p>Take a leapfrog step of length <code>ϵ</code> from <code>z</code> along the Hamiltonian <code>H</code>.</p><p>Return the new position.</p><p>The leapfrog algorithm uses the gradient of the next position to evolve the momentum. If this is not finite, the momentum won&#39;t be either. Since the constructor <code>PhasePoint</code> validates its arguments, this can only happen for divergent points anyway, and should not cause a problem.</p></div></div></section><h2><a class="nav-anchor" id="Finding-initial-stepsize-\\epsilon-1" href="#Finding-initial-stepsize-\\epsilon-1">Finding initial stepsize <span>$\epsilon$</span></a></h2><p>Local stepsize tuning.</p><p>The local acceptance ratio is technically a probability, but for finding the initial stepsize, it is not capped at <span>$1$</span>.</p><p>Also, the values are cached as this is assumed to be moderately expensive to calculate.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.find_initial_stepsize" href="#DynamicHMC.find_initial_stepsize"><code>DynamicHMC.find_initial_stepsize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">find_initial_stepsize(parameters, A)
</code></pre><p>Find an initial stepsize that matches the conditions of <code>parameters</code> (see <a href="#DynamicHMC.InitialStepsizeSearch"><code>InitialStepsizeSearch</code></a>).</p><p><code>A</code> is the local acceptance ratio (uncapped). When given a Hamiltonian <code>H</code> and a phasepoint <code>z</code>, it will be calculated using <a href="#DynamicHMC.local_acceptance_ratio"><code>local_acceptance_ratio</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.InitialStepsizeSearch" href="#DynamicHMC.InitialStepsizeSearch"><code>DynamicHMC.InitialStepsizeSearch</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct InitialStepsizeSearch</code></pre><p>Parameters for the search algorithm for the initial stepsize.</p><p>The algorithm finds an initial stepsize <span>$ϵ$</span> so that the local acceptance ratio <span>$A(ϵ)$</span> satisfies</p><div>\[a_\text{min} ≤ A(ϵ) ≤ a_\text{max}\]</div><p>This is achieved by an initial bracketing, then bisection.</p><ul><li><p><code>a_min</code></p><p>Lowest local acceptance rate.</p></li><li><p><code>a_max</code></p><p>Highest local acceptance rate.</p></li><li><p><code>ϵ₀</code></p><p>Initial stepsize.</p></li><li><p><code>C</code></p><p>Scale factor for initial bracketing, &gt; 1. <em>Default</em>: <code>2.0</code>.</p></li><li><p><code>maxiter_crossing</code></p><p>Maximum number of iterations for initial bracketing.</p></li><li><p><code>maxiter_bisect</code></p><p>Maximum number of iterations for bisection.</p></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Cf. Hoffman and Gelman (2014), which does not ensure bounds for the acceptance ratio, just that it has crossed a threshold. This version seems to work better for some tricky posteriors with high curvature.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.find_crossing_stepsize" href="#DynamicHMC.find_crossing_stepsize"><code>DynamicHMC.find_crossing_stepsize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">find_crossing_stepsize(parameters, A, ϵ₀)
find_crossing_stepsize(parameters, A, ϵ₀, Aϵ₀)
</code></pre><p>Find the stepsize for which the local acceptance rate <code>A(ϵ)</code> crosses <code>a</code>.</p><p>Return <code>ϵ₀, A(ϵ₀), ϵ₁</code>, A(ϵ₁)<code>, where</code>ϵ₀<code>and</code>ϵ₁<code>are stepsizes before and after crossing</code>a<code>with</code>A(ϵ)`, respectively.</p><p>Assumes that <span>$A(ϵ₀) ∉ (a_\text{min}, a_\text{max})$</span>, where the latter are defined in <code>parameters</code>.</p><ul><li><p><code>parameters</code>: parameters for the iteration.</p></li><li><p><code>A</code>: local acceptance ratio (uncapped), a function of stepsize <code>ϵ</code></p></li><li><p><code>ϵ₀</code>, <code>Aϵ₀</code>: initial value of <code>ϵ</code>, and <code>A(ϵ₀)</code></p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.bisect_stepsize" href="#DynamicHMC.bisect_stepsize"><code>DynamicHMC.bisect_stepsize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bisect_stepsize(parameters, A, ϵ₀, ϵ₁)
bisect_stepsize(parameters, A, ϵ₀, ϵ₁, Aϵ₀)
bisect_stepsize(parameters, A, ϵ₀, ϵ₁, Aϵ₀, Aϵ₁)
</code></pre><p>Return the desired stepsize <code>ϵ</code> by bisection.</p><ul><li><p><code>parameters</code>: algorithm parameters, see <a href="#DynamicHMC.InitialStepsizeSearch"><code>InitialStepsizeSearch</code></a></p></li><li><p><code>A</code>: local acceptance ratio (uncapped), a function of stepsize <code>ϵ</code></p></li><li><p><code>ϵ₀</code>, <code>ϵ₁</code>, <code>Aϵ₀</code>, <code>Aϵ₁</code>: stepsizes and acceptance rates (latter optional).</p></li></ul><p>This function assumes that <span>$ϵ₀ &lt; ϵ₁$</span>, the stepsize is not yet acceptable, and the cached <code>A</code> values have the correct ordering.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.local_acceptance_ratio" href="#DynamicHMC.local_acceptance_ratio"><code>DynamicHMC.local_acceptance_ratio</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">local_acceptance_ratio(H, z)
</code></pre><p>Return a function of the stepsize (<span>$ϵ$</span>) that calculates the local acceptance ratio for a single leapfrog step around <code>z</code> along the Hamiltonian <code>H</code>. Formally, let</p><div>\[A(ϵ) = \exp(\text{neg_energy}(H, \text{leapfrog}(H, z, ϵ)) - \text{neg_energy}(H, z))\]</div><p>Note that the ratio is not capped by <code>1</code>, so it is not a valid probability <em>per se</em>.</p></div></div></section><h2><a class="nav-anchor" id="Dual-averaging-1" href="#Dual-averaging-1">Dual averaging</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.DualAveragingParameters" href="#DynamicHMC.DualAveragingParameters"><code>DynamicHMC.DualAveragingParameters</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Parameters for the dual averaging algorithm of Gelman and Hoffman (2014, Algorithm 6).</p><p>To get reasonable defaults, initialize with <code>DualAveragingParameters(logϵ₀)</code>. See <a href="#DynamicHMC.adapting_ϵ"><code>adapting_ϵ</code></a> for a joint constructor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.DualAveragingAdaptation" href="#DynamicHMC.DualAveragingAdaptation"><code>DynamicHMC.DualAveragingAdaptation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Current state of adaptation for <code>ϵ</code>. Use <code>DualAverageingAdaptation(logϵ₀)</code> to get an initial value. See <a href="#DynamicHMC.adapting_ϵ"><code>adapting_ϵ</code></a> for a joint constructor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.get_ϵ" href="#DynamicHMC.get_ϵ"><code>DynamicHMC.get_ϵ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">get_ϵ(A)
get_ϵ(A, tuning)
</code></pre><p>When <code>tuning</code>, return the stepsize <code>ϵ</code> for the next HMC step. Otherwise return the tuned <code>ϵ</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.adapting_ϵ" href="#DynamicHMC.adapting_ϵ"><code>DynamicHMC.adapting_ϵ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">DA_params, A =</code></pre><pre><code class="language-julia">adapting_ϵ(ϵ; args...)
</code></pre><p>Constructor for both the adaptation parameters and the initial state.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.adapt_stepsize" href="#DynamicHMC.adapt_stepsize"><code>DynamicHMC.adapt_stepsize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">A′ =</code></pre><pre><code class="language-julia">adapt_stepsize(parameters, A, a)
</code></pre><p>Update the adaptation <code>A</code> of log stepsize <code>logϵ</code> with average Metropolis acceptance rate <code>a</code> over the whole visited trajectory, using the dual averaging algorithm of Gelman and Hoffman (2014, Algorithm 6). Return the new adaptation.</p></div></div></section><h2><a class="nav-anchor" id="Abstract-trajectory-interface-1" href="#Abstract-trajectory-interface-1">Abstract trajectory interface</a></h2><p>In contrast to other reference implementations, the algorithm is implemented in a functional style using immutable values. The intention is to provide more transparency and facilitate fine-grained unit testing.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.adjacent_tree" href="#DynamicHMC.adjacent_tree"><code>DynamicHMC.adjacent_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ζ, τ, d, z = adjacent_tree(rng, trajectory, z, depth, fwd)</code></pre><p>Traverse the tree of given <code>depth</code> adjacent to point <code>z</code> in <code>trajectory</code>.</p><p><code>fwd</code> specifies the direction, <code>rng</code> is used for random numbers.</p><p>Return:</p><ul><li><p><code>ζ</code>: the proposal from the tree. Only valid when <code>!isdivergent(d) &amp;&amp; !isturning(τ)</code>, otherwise the value should not be used.</p></li><li><p><code>τ</code>: turn statistics. Only valid when <code>!isdivergent(d)</code>.</p></li><li><p><code>d</code>: divergence statistics, always valid.</p></li><li><p><code>z</code>: the point at the end of the tree.</p></li></ul><p><code>trajectory</code> should support the following interface:</p><ul><li><p>Starting from leaves: <code>ζ, τ, d = leaf(trajectory, z, isinitial)</code></p></li><li><p>Moving along the trajectory: <code>z = move(trajectory, z, fwd)</code></p></li><li><p>Testing for turning and divergence: <code>isturning(τ)</code>, <code>isdivergent(d)</code></p></li><li><p>Combination of return values: <code>combine_proposals(ζ₁, ζ₂, bias)</code>, <code>combine_turnstats(τ₁, τ₂)</code>, and <code>combine_divstats(d₁, d₂)</code></p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.Termination" href="#DynamicHMC.Termination"><code>DynamicHMC.Termination</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Reason for terminating a trajectory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.sample_trajectory" href="#DynamicHMC.sample_trajectory"><code>DynamicHMC.sample_trajectory</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ζ, d, termination, depth = sample_trajectory(rng, trajectory, z, max_depth)</code></pre><p>Sample a <code>trajectory</code> starting at <code>z</code>.</p><p>Return:</p><ul><li><p><code>ζ</code>: proposal from the tree</p></li><li><p><code>d</code>: divergence statistics</p></li><li><p><code>termination</code>: reason for termination (see <a href="#DynamicHMC.Termination"><code>Termination</code></a>)</p></li><li><p><code>depth</code>: the depth of the tree that as sampled from. Doubling steps that lead to an invalid tree do not contribute to <code>depth</code>.</p></li></ul><p>See <a href="#DynamicHMC.adjacent_tree"><code>adjacent_tree</code></a> for the interface that needs to be supported by <code>trajectory</code>.</p></div></div></section><h2><a class="nav-anchor" id="Proposals-1" href="#Proposals-1">Proposals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.Proposal" href="#DynamicHMC.Proposal"><code>DynamicHMC.Proposal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Proposal that is propagated through by sampling recursively when building the trees.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.combined_logprob_logweight" href="#DynamicHMC.combined_logprob_logweight"><code>DynamicHMC.combined_logprob_logweight</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">logprob, ω = combined_logprob_logweight(ω₁, ω₂, bias)</code></pre><p>Given (relative) log probabilities <code>ω₁</code> and <code>ω₂</code>, return the log probabiliy of drawing a sampel from the second (<code>logprob</code>) and the combined (relative) log probability (<code>ω</code>).</p><p>When <code>bias</code>, biases towards the second argument, introducing anti-correlations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.combine_proposals" href="#DynamicHMC.combine_proposals"><code>DynamicHMC.combine_proposals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">combine_proposals(rng, ζ₁, ζ₂, bias)</code></pre><p>Combine proposals from two trajectories, using their weights.</p><p>When <code>bias</code>, biases towards the second proposal, introducing anti-correlations.</p></div></div></section><h2><a class="nav-anchor" id="Divergence-statistics-1" href="#Divergence-statistics-1">Divergence statistics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.DivergenceStatistic" href="#DynamicHMC.DivergenceStatistic"><code>DynamicHMC.DivergenceStatistic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Divergence and acceptance statistics.</p><p>Calculated over all visited phase points (not just the tree that is sampled from).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.divergence_statistic" href="#DynamicHMC.divergence_statistic"><code>DynamicHMC.divergence_statistic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">divergence_statistic()</code></pre><p>Empty divergence statistic (for initial node).</p></div></div><div><div><pre><code class="language-none">divergence_statistic(isdivergent, Δ)</code></pre><p>Divergence statistic for leaves. <code>Δ</code> is the log density relative to the initial point.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.isdivergent" href="#DynamicHMC.isdivergent"><code>DynamicHMC.isdivergent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isdivergent(x)</code></pre><p>Test if divergence statistic <code>x</code> indicates divergence.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.combine_divstats" href="#DynamicHMC.combine_divstats"><code>DynamicHMC.combine_divstats</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">combine_divstats(x, y)</code></pre><p>Combine divergence statistics from (subtrees) <code>x</code> and <code>y</code>. A divergent subtree make a subtree divergent.</p></div></div></section><h2><a class="nav-anchor" id="Turn-analysis-1" href="#Turn-analysis-1">Turn analysis</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.TurnStatistic" href="#DynamicHMC.TurnStatistic"><code>DynamicHMC.TurnStatistic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Statistics for the identification of turning points. See Betancourt (2017, appendix).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.combine_turnstats" href="#DynamicHMC.combine_turnstats"><code>DynamicHMC.combine_turnstats</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">combine_turnstats(x, y)</code></pre><p>Combine turn statistics of two trajectories <code>x</code> and <code>y</code>, which are assume to be adjacent and in that order.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.isturning" href="#DynamicHMC.isturning"><code>DynamicHMC.isturning</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isturning(τ)</code></pre><p>Test termination based on turn statistics. Uses the generalized NUTS criterion from Betancourt (2017).</p><p>Note that this function should not be called with turn statistics returned by <a href="#DynamicHMC.leaf"><code>leaf</code></a>, ie <code>depth &gt; 0</code> is required.</p></div></div></section><h2><a class="nav-anchor" id="Sampling-1" href="#Sampling-1">Sampling</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.Trajectory" href="#DynamicHMC.Trajectory"><code>DynamicHMC.Trajectory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Representation of a trajectory, ie a Hamiltonian with a discrete integrator that also checks for divergence.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.leaf" href="#DynamicHMC.leaf"><code>DynamicHMC.leaf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ζ, τ, d = leaf(trajectory, z, isinitial)</code></pre><p>Construct a proposal, turn statistic, and divergence statistic for a single point <code>z</code> in <code>trajectory</code>. When <code>isinitial</code>, <code>z</code> is the initial point in the trajectory.</p><p>Return</p><ul><li><p><code>ζ</code>: the proposal, which should only be used when <code>!isdivergent(d)</code></p></li><li><p><code>τ</code>: the turn statistic, which should only be used when <code>!isdivergent(d)</code></p></li><li><p><code>d</code>: divergence statistic</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.move" href="#DynamicHMC.move"><code>DynamicHMC.move</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">move(trajectory, z, fwd)</code></pre><p>Return next phase point adjacent to <code>z</code> along <code>trajectory</code> in the direction specified by <code>fwd</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.NUTS_transition" href="#DynamicHMC.NUTS_transition"><code>DynamicHMC.NUTS_transition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">NUTS_transition(rng, H, q, ϵ, max_depth; args...)</code></pre><p>No-U-turn Hamiltonian Monte Carlo transition, using Hamiltonian <code>H</code>, starting at position <code>q</code>, using stepsize <code>ϵ</code>. Builds a doubling dynamic tree of maximum depth <code>max_depth</code>. <code>args</code> are passed to the <code>Trajectory</code> constructor. <code>rng</code> is the random number generator used.</p></div></div></section><h2><a class="nav-anchor" id="Tuning-1" href="#Tuning-1">Tuning</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.AbstractTuner" href="#DynamicHMC.AbstractTuner"><code>DynamicHMC.AbstractTuner</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractTuner</code></pre><p>A tuner that adapts the sampler.</p><p>All subtypes support <code>length</code> which returns the number of steps (<em>note</em>: if not in field <code>N</code>, define <code>length</code> accordingly), other parameters vary.</p></div></div></section><h2><a class="nav-anchor" id="diagnostics_lowlevel-1" href="#diagnostics_lowlevel-1">Diagnostics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.NUTS_Statistics" href="#DynamicHMC.NUTS_Statistics"><code>DynamicHMC.NUTS_Statistics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Storing the output of <a href="../api/#DynamicHMC.NUTS_statistics"><code>NUTS_statistics</code></a> in a structured way, for pretty printing. Currently for internal use.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.ACCEPTANCE_QUANTILES" href="#DynamicHMC.ACCEPTANCE_QUANTILES"><code>DynamicHMC.ACCEPTANCE_QUANTILES</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Acceptance quantiles for <a href="#DynamicHMC.NUTS_Statistics"><code>NUTS_Statistics</code></a> diagnostic summary.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.explore_local_acceptance_ratios" href="#DynamicHMC.explore_local_acceptance_ratios"><code>DynamicHMC.explore_local_acceptance_ratios</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">explore_local_acceptance_ratios(H, q, ϵs, ps)
</code></pre><p>Return a matrix of <a href="#DynamicHMC.local_acceptance_ratio"><code>local_acceptance_ratio</code></a> values for stepsizes <code>ϵs</code> and the given momentums <code>ps</code>. The latter is calculated from random values when an integer is given.</p><p>To facilitate plotting, <span>$-∞$</span> values are replaced by <code>NaN</code>.</p></div></div></section><h2><a class="nav-anchor" id="Reporting-information-during-runs-1" href="#Reporting-information-during-runs-1">Reporting information during runs</a></h2><p>Samplers take an <a href="#DynamicHMC.AbstractReport"><code>AbstractReport</code></a> argument, which is then used for reporting. The interface is as follows.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.AbstractReport" href="#DynamicHMC.AbstractReport"><code>DynamicHMC.AbstractReport</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractReport</code></pre><p>Subtypes implement</p><ol><li><p><a href="#DynamicHMC.start_progress!"><code>start_progress!</code></a>, which is used to start a particular iteration,</p></li><li><p><a href="#DynamicHMC.report!"><code>report!</code></a>, which triggers the display of progress,</p></li><li><p><a href="#DynamicHMC.end_progress!"><code>end_progress!</code></a> which &quot;frees&quot; the progress report, which can then be reused.</p></li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.report!" href="#DynamicHMC.report!"><code>DynamicHMC.report!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">report!(report, count)
</code></pre><p>Display <code>report</code> via the appropriate mechanism. <code>count</code> is the index of the current step.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.start_progress!" href="#DynamicHMC.start_progress!"><code>DynamicHMC.start_progress!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">start_progress!(report, msg; total_count)
</code></pre><p>Start a progress meter for an iteration.</p><p><code>total_count</code> can be overwritten by a keyword argument.</p><p>After calling this function, <a href="#DynamicHMC.report!"><code>report!</code></a> should be used at every step with an integer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.end_progress!" href="#DynamicHMC.end_progress!"><code>DynamicHMC.end_progress!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">end_progress!(report)
end_progress!(report, count)
</code></pre><p>Terminate a progress meter.</p></div></div></section><p>The default is</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.ReportIO" href="#DynamicHMC.ReportIO"><code>DynamicHMC.ReportIO</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct ReportIO{TIO&lt;:IO} &lt;: DynamicHMC.AbstractReport</code></pre><p>Display progress by printing lines to <code>io</code> if <code>countΔ</code> iterations <em>and</em> <code>time_nsΔ</code> nanoseconds have passed since the last display.</p><ul><li><p><code>io</code></p><p>IO stream for reporting.</p></li><li><p><code>print_color</code></p><p>Color for report messages.</p></li><li><p><code>total_count</code></p><p>Expected total count. When unknown, set to <code>nothing</code>.</p></li><li><p><code>countΔ</code></p><p>For comparing current count to the count at the last report. Not binding when negative.</p></li><li><p><code>time_nsΔ</code></p><p>For comparing time to the time at the last report (in ns). Not binding when negative.</p></li><li><p><code>start_time_ns</code></p><p>Time of starting the process. <code>nothing</code> unless start_progress! was called.</p></li><li><p><code>last_printed_count</code></p><p>Count when a report was last printed. <code>&lt; 0</code> before <code>start_progress!</code>.</p></li><li><p><code>last_printed_time_ns</code></p><p>Time (in ns) when a report was last printed.</p></li></ul></div></div></section><p>Reporting information can be suppressed with</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.ReportSilent" href="#DynamicHMC.ReportSilent"><code>DynamicHMC.ReportSilent</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A placeholder type for not reporting any information.</p></div></div></section><p>Other interfaces should define similar types.</p><h2><a class="nav-anchor" id="Utilities-and-miscellanea-1" href="#Utilities-and-miscellanea-1">Utilities and miscellanea</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.rand_bool" href="#DynamicHMC.rand_bool"><code>DynamicHMC.rand_bool</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rand_bool(rng, prob)
</code></pre><p>Random boolean which is <code>true</code> with the given probability <code>prob</code>.</p><p><strong>All random numbers in this library are obtained from this function.</strong></p></div></div></section><footer><hr/><a class="previous" href="../api/"><span class="direction">Previous</span><span class="title">High-level API</span></a></footer></article></body></html>
