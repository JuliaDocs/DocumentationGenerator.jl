<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · LinQuadOptInterface.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LinQuadOptInterface.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.CSRMatrix" href="#LinQuadOptInterface.CSRMatrix"><code>LinQuadOptInterface.CSRMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CSRMatrix{T}</code></pre><p>Matrix given in compressed sparse row (CSR) format.</p><p><code>CSRMatrix</code> is analgous to the structure in Julia&#39;s <code>SparseMatrixCSC</code> but with the rows and columns flipped. It contains three vectors:</p><ul><li><code>row_pointers</code> is a vector pointing to the start of each row in  <code>columns</code> and <code>coefficients</code>;</li><li><code>columns</code> is a vector of column numbers; and</li><li><code>coefficients</code> is a vector of corresponding nonzero values.</li></ul><p>The length of <code>row_pointers</code> is the number of rows in the matrix.</p><p>This struct is not a subtype of <code>AbstractSparseMatrix</code> as it is intended to be a collection of the three vectors as they are required by solvers such as Gurobi. It is not intended to be used for general computation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.LinearQuadraticModel" href="#LinQuadOptInterface.LinearQuadraticModel"><code>LinQuadOptInterface.LinearQuadraticModel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">LinearQuadraticModel(M::Type{&lt;:LinQuadOptimizer}, env)</code></pre><p>Initializes a model given a model type <code>M</code> and an <code>env</code> that might be a <code>nothing</code> for some solvers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.__assert_supported_constraint__-Union{Tuple{S}, Tuple{F}, Tuple{LinQuadOptimizer,Type{F},Type{S}}} where S&lt;:MathOptInterface.AbstractSet where F&lt;:MathOptInterface.AbstractFunction" href="#LinQuadOptInterface.__assert_supported_constraint__-Union{Tuple{S}, Tuple{F}, Tuple{LinQuadOptimizer,Type{F},Type{S}}} where S&lt;:MathOptInterface.AbstractSet where F&lt;:MathOptInterface.AbstractFunction"><code>LinQuadOptInterface.__assert_supported_constraint__</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">__assert_supported_constraint__(model::LinQuadOptimizer, ::Type{F}, ::Type{S})</code></pre><p>Throw an <code>UnsupportedConstraint{F, S}</code> error if the model cannot add constraints of type <code>F</code>-in-<code>S</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.__assert_valid__-Tuple{LinQuadOptInterface.LinQuadOptimizer,Union{VariableIndex, ConstraintIndex}}" href="#LinQuadOptInterface.__assert_valid__-Tuple{LinQuadOptInterface.LinQuadOptimizer,Union{VariableIndex, ConstraintIndex}}"><code>LinQuadOptInterface.__assert_valid__</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">__assert_valid__(model::LinQuadOptimizer, index::MOI.Index)</code></pre><p>Throw an MOI.InvalidIndex error if <code>MOI.is_valid(model, index) == false</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface._matching_sparsity_pattern-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Union{ScalarAffineFunction{Float64}, VectorAffineFunction{Float64}}" href="#LinQuadOptInterface._matching_sparsity_pattern-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Union{ScalarAffineFunction{Float64}, VectorAffineFunction{Float64}}"><code>LinQuadOptInterface._matching_sparsity_pattern</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">_matching_sparsity_pattern(f1::T, f2::T) where {T &lt;: Union{Linear, VecLin}}</code></pre><p>Internal function, not intended for external use.</p><p>Determines whether functions <code>f1</code> and <code>f2</code> have the same sparsity pattern w.r.t. their constraint rows and columns. Assumes both functions are already in canonical form.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface._replace_with_different_sparsity!-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.ScalarAffineFunction{Float64},Any}" href="#LinQuadOptInterface._replace_with_different_sparsity!-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.ScalarAffineFunction{Float64},Any}"><code>LinQuadOptInterface._replace_with_different_sparsity!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">_replace_with_different_sparsity!(model::LinQuadOptimizer,
    previous::Linear, replacement::Linear, row)</code></pre><p>Internal function, not intended for external use.</p><p>Change the linear constraint function at index <code>row</code> in <code>model</code> from <code>previous</code> to <code>replacement</code>. This function assumes that <code>previous</code> and <code>replacement</code> may have different sparsity patterns.</p><p>This function (and <code>_replace_with_matching_sparsity!</code> above) are necessary because the LQOI API currently <em>only</em> allows linear constraint modification through the <code>change_matrix_coefficient!</code> and <code>change_matrix_coefficients!</code> functions. In order to fully replace a linear constraint, we have to zero out the current matrix coefficients and then set the new matrix coefficients. When the sparsity patterns match, the zeroing-out step can be skipped.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface._replace_with_different_sparsity!-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.VectorAffineFunction{Float64},Any}" href="#LinQuadOptInterface._replace_with_different_sparsity!-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.VectorAffineFunction{Float64},Any}"><code>LinQuadOptInterface._replace_with_different_sparsity!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">_replace_with_different_sparsity!(model::LinQuadOptimizer,
    previous::VecLin, replacement::VecLin, row)</code></pre><p>Internal function, not intended for external use.</p><p>Change the linear constraint function at index <code>row</code> in <code>model</code> from <code>previous</code> to <code>replacement</code>. This function assumes that <code>previous</code> and <code>replacement</code> may have different sparsity patterns.</p><p>This function (and <code>_replace_with_matching_sparsity!</code> above) are necessary because the LQOI API currently <em>only</em> allows linear constraint modification through the <code>change_matrix_coefficient!</code> and <code>change_matrix_coefficients!</code> functions. In order to fully replace a linear constraint, we have to zero out the current matrix coefficients and then set the new matrix coefficients. When the sparsity patterns match, the zeroing-out step can be skipped.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface._replace_with_matching_sparsity!-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.ScalarAffineFunction{Float64},Any}" href="#LinQuadOptInterface._replace_with_matching_sparsity!-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.ScalarAffineFunction{Float64},Any}"><code>LinQuadOptInterface._replace_with_matching_sparsity!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">_replace_with_matching_sparsity!(model::LinQuadOptimizer,
    previous::Linear, replacement::Linear, row)</code></pre><p>Internal function, not intended for external use.</p><p>Change the linear constraint function at index <code>row</code> in <code>model</code> from <code>previous</code> to <code>replacement</code>. This function assumes that <code>previous</code> and <code>replacement</code> have exactly the same sparsity pattern w.r.t. which variables they include and that both constraint functions are in canonical form (as returned by <code>MOIU.canonical()</code>. Neither assumption is checked within the body of this function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface._replace_with_matching_sparsity!-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.VectorAffineFunction{Float64},Any}" href="#LinQuadOptInterface._replace_with_matching_sparsity!-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.VectorAffineFunction{Float64},Any}"><code>LinQuadOptInterface._replace_with_matching_sparsity!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">_replace_with_matching_sparsity!(model::LinQuadOptimizer,
    previous::VecLin, replacement::VecLin, row)</code></pre><p>Internal function, not intended for external use.</p><p>Change the linear constraint function at index <code>row</code> in <code>model</code> from <code>previous</code> to <code>replacement</code>. This function assumes that <code>previous</code> and <code>replacement</code> have exactly the same sparsity pattern w.r.t. which variables they include and that both constraint functions are in canonical form (as returned by <code>MOIU.canonical()</code>. Neither assumption is checked within the body of this function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.add_linear_constraint-Union{Tuple{S}, Tuple{LinQuadOptimizer,ScalarAffineFunction{Float64},S}} where S&lt;:Union{EqualTo{Float64}, GreaterThan{Float64}, LessThan{Float64}}" href="#LinQuadOptInterface.add_linear_constraint-Union{Tuple{S}, Tuple{LinQuadOptimizer,ScalarAffineFunction{Float64},S}} where S&lt;:Union{EqualTo{Float64}, GreaterThan{Float64}, LessThan{Float64}}"><code>LinQuadOptInterface.add_linear_constraint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">add_linear_constraint(model::LinQuadOptimizer, func::Linear, set::S)</code></pre><p>Add a constraint of type <code>func</code>-in-<code>set</code> to <code>model</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.add_linear_constraints!" href="#LinQuadOptInterface.add_linear_constraints!"><code>LinQuadOptInterface.add_linear_constraints!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_linear_constraints!(m, A::CSRMatrix{Float64},
    sense::Vector{Cchar}, rhs::Vector{Float64})::Nothing</code></pre><p>Adds linear constraints of the form <code>Ax (sense) rhs</code> to the model <code>m</code>.</p><p><code>sense</code> and <code>rhs</code> contain one element for each row in <code>A</code>. The <code>sense</code> is given by <code>backend_type(m, set)</code>.</p><p>Ranged constraints (<code>set=MOI.Interval</code>) should be added via <code>add_ranged_constraint!</code> instead.</p><p>See also: <code>LinQuadOptInterface.CSRMatrix</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.add_mip_starts!" href="#LinQuadOptInterface.add_mip_starts!"><code>LinQuadOptInterface.add_mip_starts!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_mip_starts!(model::M, cols::Vector{Int}, x::Vector{Float64})::Nothing</code></pre><p>Add a primal start <code>x</code> for the variables in the columns <code>cols</code> of <code>model</code>.</p><p>Note that if this method is implemented, solvers of type <code>M</code> must also declare that they support VariablePrimalStarts by overloading the following method:</p><pre><code class="language-none">function MOI.supports(model::M,
                      ::MOI.VariablePrimalStart,
                      ::Type{MOI.VariableIndex})
    return true
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.add_quadratic_constraint!" href="#LinQuadOptInterface.add_quadratic_constraint!"><code>LinQuadOptInterface.add_quadratic_constraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_quadratic_constraint!(m, cols::Vector{Int}, coefs::Vector{Float64}, rhs::Float64,
    sense, I::Vector{Int}, J::Vector{Int}, V::Vector{Float64})::Nothing</code></pre><p>Add a quadratic constraint <code>a&#39;x + 0.5 x&#39; Q x</code>. See <code>add_linear_constraints!</code> for information of linear component. Arguments <code>(I,J,V)</code> given in triplet form for the Q matrix in <code>0.5 x&#39; Q x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.add_ranged_constraints!" href="#LinQuadOptInterface.add_ranged_constraints!"><code>LinQuadOptInterface.add_ranged_constraints!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_ranged_constraints!(m, A::CSRMatrix{Float64},
    lowerbound::Vector{Float64}, upperbound::Vector{Float64})</code></pre><p>Adds linear constraints of the form <code>lowerbound &lt;= Ax &lt;= upperbound</code> to the model <code>m</code>.</p><p>This is a special case compared to standard <code>add_linear_constraints!</code> since it is often implemented via multiple API calls.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.add_sos_constraint!" href="#LinQuadOptInterface.add_sos_constraint!"><code>LinQuadOptInterface.add_sos_constraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_sos_constraint!(m, cols::Vector{Int}, vals::Vector{Float64}, typ::Symbol)::Nothing</code></pre><p>Add the SOS constraint to the model <code>m</code>. <code>typ</code> is either <code>:SOS1</code> or <code>:SOS2</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.add_variables!" href="#LinQuadOptInterface.add_variables!"><code>LinQuadOptInterface.add_variables!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_variables!(m, n::Int)::Nothing</code></pre><p>Add <code>n</code> new variables to the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.backend_type-Union{Tuple{T}, Tuple{LinQuadOptimizer,GreaterThan{T}}} where T" href="#LinQuadOptInterface.backend_type-Union{Tuple{T}, Tuple{LinQuadOptimizer,GreaterThan{T}}} where T"><code>LinQuadOptInterface.backend_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">backend_type(m, ::MOI.AbstractSet)::CChar</code></pre><p>An overloadable type for dispatching the appropriate types to the backends.</p><p>For example, GLPK.jl uses <code>&#39;E&#39;</code> for <code>a&#39;x=b</code> constraints, where as Gurobi.jl uses <code>==</code>.</p><p>Three are special cases:</p><ul><li><code>Val{:Continuous}</code>: for the type of a continuous variable</li><li><code>Val{:Upperbound}</code>: for the upper bound of a variable</li><li><code>Val{:Lowerbound}</code>: for the lower bound of a variable</li></ul><p><strong>Defaults</strong></p><pre><code class="language-none">MOI.GreaterThan  - &#39;G&#39;
MOI.LessThan     - &#39;L&#39;
MOI.EqualTo      - &#39;E&#39;

MOI.Zeros        - &#39;E&#39;
MOI.Nonpositives - &#39;L&#39;
MOI.Nonnegatives - &#39;G&#39;

MOI.ZeroOne        - &#39;B&#39;
MOI.Integer        - &#39;I&#39;
MOI.Semicontinuous - &#39;S&#39;
MOI.Semiinteger    - &#39;N&#39;

MOI.SOS1 - :SOS1  # &#39;1&#39;
MOI.SOS2 - :SOS2  # &#39;2&#39;

Val{:Continuous} - &#39;C&#39;
Val{:Upperbound} - &#39;U&#39;
Val{:Lowerbound} - &#39;L&#39;</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.canonical_reduction-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.ScalarQuadraticFunction{Float64}}" href="#LinQuadOptInterface.canonical_reduction-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.ScalarQuadraticFunction{Float64}}"><code>LinQuadOptInterface.canonical_reduction</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">canonical_reduction(model::LinQuadOptimizer, func::Quad)</code></pre><p>Reduce a ScalarQuadraticFunction into five arrays, returned in the following order:</p><ol><li>a vector of affine column indices</li><li>a vector of affine coefficients</li><li>a vector of quadratic row indices</li><li>a vector of quadratic column indices</li><li>a vector of quadratic coefficients</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.change_both_variable_bounds!-Tuple{LinQuadOptInterface.LinQuadOptimizer,Array{Int64,1},Array{Float64,1},Array{Float64,1}}" href="#LinQuadOptInterface.change_both_variable_bounds!-Tuple{LinQuadOptInterface.LinQuadOptimizer,Array{Int64,1},Array{Float64,1},Array{Float64,1}}"><code>LinQuadOptInterface.change_both_variable_bounds!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">change_both_variable_bounds!(model::LinQuadOptimizer, columns::Vector{Int},
    lower_bounds::Vector{Float64}, upper_bounds::Vector{Float64})</code></pre><p>Set the lower bound of column <code>columns[i]</code> to <code>lower_bounds[i]</code> and the upper bound to <code>upper_bounds[i]</code>. Alternatively, the lower or upper bound can be left blank by passing an array of length 0 instead.</p><p>Examples:     change<em>both</em>variable<em>bounds!(model, [1, 2], [-0.5, 0.0], [1.0, 2.0])     change</em>both<em>variable</em>bounds!(model, [1, 2], [-0.5, 0.0], Float64[])     change<em>both</em>variable_bounds!(model, [1, 2], Float64[], [1.0, 2.0])</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.change_linear_constraint_sense!" href="#LinQuadOptInterface.change_linear_constraint_sense!"><code>LinQuadOptInterface.change_linear_constraint_sense!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">change_linear_constraint_sense!(m, rows::Vector{Int}, sense::Vector{Symbol})::Nothing</code></pre><p>Change the sense of the linear constraints in <code>rows</code> to <code>sense</code>.</p><p><code>sense</code> is the output of <code>backend_type(m, set)</code>, where <code>set</code> is the corresponding set for the row <code>rows[i]</code>.</p><p><code>Interval</code> constraints require a call to <code>change_range_value!</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.change_matrix_coefficient!" href="#LinQuadOptInterface.change_matrix_coefficient!"><code>LinQuadOptInterface.change_matrix_coefficient!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">change_matrix_coefficient!(m, row, col, coef)</code></pre><p>Set the linear coefficient of the variable in column <code>col</code>, constraint <code>row</code> to <code>coef</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.change_matrix_coefficients!-NTuple{4,Any}" href="#LinQuadOptInterface.change_matrix_coefficients!-NTuple{4,Any}"><code>LinQuadOptInterface.change_matrix_coefficients!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">change_matrix_coefficients!(m, rows, cols, coefs)</code></pre><p>Change multiple linear coefficients simultaneously. Sets the linear coefficient of the variable at column <code>cols[i]</code> in constraint <code>rows[i]</code> to <code>coefs[i]</code> for <code>i in 1:length(rows)</code>. Requires that <code>length(rows) == length(cols) == length(coefs)</code>.</p><p>By default, this method just calls <code>change_matrix_coefficient!(m, rows[i], cols[i], coefs[i])</code> repeatedly, but some solver interfaces may offer more efficient implementations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.change_objective_coefficient!" href="#LinQuadOptInterface.change_objective_coefficient!"><code>LinQuadOptInterface.change_objective_coefficient!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>change<em>objective</em>coefficient!(m, col, coef)</p><p>Set the linear coefficient of the variable in column <code>col</code> to <code>coef</code> in the objective function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.change_objective_sense!" href="#LinQuadOptInterface.change_objective_sense!"><code>LinQuadOptInterface.change_objective_sense!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">change_objective_sense!(m, sense::Symbol)::Nothing</code></pre><p>Change the optimization sense of the model <code>m</code> to <code>sense</code>. <code>sense</code> must be <code>:min</code> or <code>:max</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.change_rhs_coefficient!" href="#LinQuadOptInterface.change_rhs_coefficient!"><code>LinQuadOptInterface.change_rhs_coefficient!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>change<em>rhs</em>coefficient!(m, row, coef)</p><p>Set the rhs of the constraint in row <code>row</code> to <code>coef</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.change_variable_bounds!" href="#LinQuadOptInterface.change_variable_bounds!"><code>LinQuadOptInterface.change_variable_bounds!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">change_variable_bounds!(m, cols::Vector{Int}, values::Vector{Float64}, senses::Vector)</code></pre><p>Change the bounds of the variable. The sense of the upperbound is given by <code>backend_type(m, Val{:Upperbound}())</code>. The sense of the lowerbound is given by <code>backend_type(m, Val{:Lowerbound}())</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.change_variable_types!" href="#LinQuadOptInterface.change_variable_types!"><code>LinQuadOptInterface.change_variable_types!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">change_variable_types(m, cols::Vector{Int}, types):Nothing</code></pre><p>Change the variable types. Type is the output of one of:</p><ul><li><code>backend_type(m, ::ZeroOne)</code>, for binary variables;</li><li><code>backend_type(m, ::Integer)</code>, for integer variables; and</li><li><code>backend_type(m, Val{:Continuous}())</code>, for continuous variables.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.delete_from_dictionary_by_value-Union{Tuple{V}, Tuple{K}, Tuple{Dict{K,V},V}} where V where K" href="#LinQuadOptInterface.delete_from_dictionary_by_value-Union{Tuple{V}, Tuple{K}, Tuple{Dict{K,V},V}} where V where K"><code>LinQuadOptInterface.delete_from_dictionary_by_value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">delete_from_dictionary_by_value(dict::Dict{K, V}, index::V)</code></pre><p>Delete the entries of a dictionary where the value of a <code>key=&gt;value</code> pair is equal to <code>index</code>.</p><p>This is used to remove bounds when deleting a variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.delete_linear_constraints!" href="#LinQuadOptInterface.delete_linear_constraints!"><code>LinQuadOptInterface.delete_linear_constraints!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">delete_linear_constraints!(m, start_row::Int, end_row::Int)::Nothing</code></pre><p>Delete the linear constraints <code>start_row</code>, <code>start_row+1</code>, ..., <code>end_row</code> from the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.delete_quadratic_constraints!" href="#LinQuadOptInterface.delete_quadratic_constraints!"><code>LinQuadOptInterface.delete_quadratic_constraints!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">delete_quadratic_constraints!(m, start_row::Int, end_row::Int)::Nothing</code></pre><p>Delete the quadratic constraints <code>start_row</code>, <code>start_row+1</code>, ..., <code>end_row</code> from the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.delete_sos!" href="#LinQuadOptInterface.delete_sos!"><code>LinQuadOptInterface.delete_sos!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">delete_sos!(m, start_idx::Int, end_idx::Int)::Nothing</code></pre><p>Delete the SOS constraints <code>start_idx</code>, <code>start_idx+1</code>, ..., <code>end_idx</code> from the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.delete_variables!" href="#LinQuadOptInterface.delete_variables!"><code>LinQuadOptInterface.delete_variables!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">delete_variables!(m, start_col::Int, end_col::Int)::Nothing</code></pre><p>Delete the columns <code>start_col</code>, <code>start_col+1</code>, ..., <code>end_col</code> from the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.fakesolve-Tuple{LinQuadOptInterface.MockLinQuadOptimizer}" href="#LinQuadOptInterface.fakesolve-Tuple{LinQuadOptInterface.MockLinQuadOptimizer}"><code>LinQuadOptInterface.fakesolve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fakesolve(instance::MockLinQuadOptimizer)</code></pre><p>Set solutions upon solve calls. Data held in <code>MockLinQuadOptimizer</code> stored data is passed to the low-level emulator <code>MockLinQuadModel</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.functions_to_CSRMatrix-Tuple{LinQuadOptInterface.LinQuadOptimizer,Array{MathOptInterface.ScalarAffineFunction{Float64},1},Int64}" href="#LinQuadOptInterface.functions_to_CSRMatrix-Tuple{LinQuadOptInterface.LinQuadOptimizer,Array{MathOptInterface.ScalarAffineFunction{Float64},1},Int64}"><code>LinQuadOptInterface.functions_to_CSRMatrix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">functions_to_CSRMatrix(model::LinQuadOptimizer, functions::Vector{Linear}, num_non_zeros::Int)</code></pre><p>Convert a vector of ScalarAffineFunctions into a CSRMatrix with <code>num_non_zeros</code> non-zero coefficients.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_barrier_iterations" href="#LinQuadOptInterface.get_barrier_iterations"><code>LinQuadOptInterface.get_barrier_iterations</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_barrier_iterations(m)</code></pre><p>Get the number of barrier iterations performed during the most recent optimization of the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_column-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.SingleVariable}" href="#LinQuadOptInterface.get_column-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.SingleVariable}"><code>LinQuadOptInterface.get_column</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_column(model::LinQuadOptimizer, variable::MOI.SingleVariable)</code></pre><p>Return the column of the variable inside a <code>MOI.SingleVariable</code> function in <code>model</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_column-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.VariableIndex}" href="#LinQuadOptInterface.get_column-Tuple{LinQuadOptInterface.LinQuadOptimizer,MathOptInterface.VariableIndex}"><code>LinQuadOptInterface.get_column</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_column(model::LinQuadOptimizer, index::MOI.VariableIndex)</code></pre><p>Return the column of the variable <code>index</code> in <code>model</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_constant_objective-Tuple{LinQuadOptInterface.LinQuadOptimizer}" href="#LinQuadOptInterface.get_constant_objective-Tuple{LinQuadOptInterface.LinQuadOptimizer}"><code>LinQuadOptInterface.get_constant_objective</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_constant_objective(m)::Float64</code></pre><p>Return the constant (i.e. offset) component of the objective.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_dual_status" href="#LinQuadOptInterface.get_dual_status"><code>LinQuadOptInterface.get_dual_status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_dual_status(m)</code></pre><p>Get the dual status of the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_farkas_dual!" href="#LinQuadOptInterface.get_farkas_dual!"><code>LinQuadOptInterface.get_farkas_dual!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_farkas_dual!(m, x::Vector{Float64})</code></pre><p>Get the farkas dual (certificate of primal infeasiblility) for the linear constraints in the model <code>m</code>, and store in <code>x</code>. <code>x</code>must have one element for each linear constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_farkas_dual_bounds!-Tuple{LinQuadOptInterface.LinQuadOptimizer,Any}" href="#LinQuadOptInterface.get_farkas_dual_bounds!-Tuple{LinQuadOptInterface.LinQuadOptimizer,Any}"><code>LinQuadOptInterface.get_farkas_dual_bounds!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_farkas_dual_bounds!(model, dest::Vector{Float64})</code></pre><p>Get the farkas dual (certificate of primal infeasibility) for the variable bounds in the model <code>model</code>, and store in <code>dest</code>. <code>dest</code> must have one element for each variable.</p><p>Since most solvers do not have this feature, this function has a default fallback that does nothing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_iteration_count" href="#LinQuadOptInterface.get_iteration_count"><code>LinQuadOptInterface.get_iteration_count</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_iteration_count(m)</code></pre><p>Get the number of simplex iterations performed during the most recent optimization of the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_linear_constraint" href="#LinQuadOptInterface.get_linear_constraint"><code>LinQuadOptInterface.get_linear_constraint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_linear_constraint(m, row::Int)::Tuple{Vector{Int}, Vector{Float64}}</code></pre><p>Get the linear component of the constraint in the 1-indexed row <code>row</code> in the model <code>m</code>. Returns a tuple of <code>(cols, vals)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_linear_dual_solution!" href="#LinQuadOptInterface.get_linear_dual_solution!"><code>LinQuadOptInterface.get_linear_dual_solution!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_linear_dual_solution!(m, x::Vector{Float64})</code></pre><p>Get the dual solution for the linear constraints in the model <code>m</code>, and store in <code>x</code>. <code>x</code>must have one element for each linear constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_linear_objective!" href="#LinQuadOptInterface.get_linear_objective!"><code>LinQuadOptInterface.get_linear_objective!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_linear_objective!(m, x::Vector{Float64})</code></pre><p>Get the linear coefficients of the objective and store in <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_linear_primal_solution!" href="#LinQuadOptInterface.get_linear_primal_solution!"><code>LinQuadOptInterface.get_linear_primal_solution!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_linear_primal_solution!(m, x::Vector{Float64})</code></pre><p>Given a set of linear constraints <code>l &lt;= a&#39;x &lt;= b</code> in the model <code>m</code>, get the constraint primal <code>a&#39;x</code> for each constraint, and store in <code>x</code>. <code>x</code> must have one element for each linear constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_node_count" href="#LinQuadOptInterface.get_node_count"><code>LinQuadOptInterface.get_node_count</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_node_count(m)</code></pre><p>Get the number of branch-and-cut nodes expolored during the most recent optimization of the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_number_linear_constraints" href="#LinQuadOptInterface.get_number_linear_constraints"><code>LinQuadOptInterface.get_number_linear_constraints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_number_linear_constraints(m)::Int</code></pre><p>Get the number of linear constraints in the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_number_quadratic_constraints" href="#LinQuadOptInterface.get_number_quadratic_constraints"><code>LinQuadOptInterface.get_number_quadratic_constraints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_number_quadratic_constraints(m)::Int</code></pre><p>Get the number of quadratic constraints in the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_number_variables" href="#LinQuadOptInterface.get_number_variables"><code>LinQuadOptInterface.get_number_variables</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_number_variables(m)::Int</code></pre><p>Get the number of variables in the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_objective_bound" href="#LinQuadOptInterface.get_objective_bound"><code>LinQuadOptInterface.get_objective_bound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_objective_bound(m)</code></pre><p>Get the objective bound of the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_objective_value" href="#LinQuadOptInterface.get_objective_value"><code>LinQuadOptInterface.get_objective_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_objective_value(m)</code></pre><p>Get the objective value of the solved model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_objectivesense" href="#LinQuadOptInterface.get_objectivesense"><code>LinQuadOptInterface.get_objectivesense</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_objectivesense(m)::MOI.OptimizationSense</code></pre><p>Get the optimization sense of the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_primal_status" href="#LinQuadOptInterface.get_primal_status"><code>LinQuadOptInterface.get_primal_status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_primal_status(m)</code></pre><p>Get the primal status of the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_quadratic_constraint" href="#LinQuadOptInterface.get_quadratic_constraint"><code>LinQuadOptInterface.get_quadratic_constraint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_quadratic_constraint(m, row::Int)::Tuple{Vector{Int}, Vector{Float64}, SparseMatrixCSC{Float64,Int64}}</code></pre><p>Get the linear and quadratic components of the constraint in the 1-indexed row <code>row</code> in the model <code>m</code>. Returns a tuple of <code>(lin_cols, lin_vals, Q)</code>. Where <code>Q</code> represents the matrix in CSC format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_quadratic_dual_solution!" href="#LinQuadOptInterface.get_quadratic_dual_solution!"><code>LinQuadOptInterface.get_quadratic_dual_solution!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_quadratic_dual_solution!(m, x::Vector{Float64})</code></pre><p>Get the dual solution for the quadratic constraints in the model <code>m</code>, and store in <code>x</code>. <code>x</code>must have one element for each quadratic constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_quadratic_primal_solution!" href="#LinQuadOptInterface.get_quadratic_primal_solution!"><code>LinQuadOptInterface.get_quadratic_primal_solution!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_quadratic_primal_solution!(m, x::Vector{Float64})</code></pre><p>Given a set of quadratic constraints <code>l &lt;= a&#39;x + x&#39;Qx &lt;= b</code> in the model <code>m</code>, get the constraint primal <code>a&#39;x + x&#39;Qx</code> for each constraint, and store in <code>x</code>. <code>x</code> must have one element for each quadratic constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_quadratic_rhs" href="#LinQuadOptInterface.get_quadratic_rhs"><code>LinQuadOptInterface.get_quadratic_rhs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_quadratic_rhs(m, row::Int)::Float64</code></pre><p>Get the right hand-side term of quadratic constraint in row <code>row</code> in model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_quadratic_terms_objective" href="#LinQuadOptInterface.get_quadratic_terms_objective"><code>LinQuadOptInterface.get_quadratic_terms_objective</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_quadratic_terms_objective(m)::SparseMatrixCSC{Float64,Int64}</code></pre><p>Get quadratic terms of the objective function returned in sparse CSC format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_range" href="#LinQuadOptInterface.get_range"><code>LinQuadOptInterface.get_range</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_range(m, row::Int)::Tuple{Float64,Float64}</code></pre><p>Get the range which the constraint <code>row</code> belongs to. The output of the function is the tuple <code>lowerbound, upperbound</code> of bounds: <code>lowerbound &lt;= a&#39;x &lt; = upperbound</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_relative_mip_gap" href="#LinQuadOptInterface.get_relative_mip_gap"><code>LinQuadOptInterface.get_relative_mip_gap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_relative_mip_gap(m)</code></pre><p>Get the relative MIP gap of the solved model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_rhs" href="#LinQuadOptInterface.get_rhs"><code>LinQuadOptInterface.get_rhs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_rhs(m, row::Int)::Float64</code></pre><p>Get the right-hand side of the linear constraint in the 1-indexed row <code>row</code> in the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_sos_constraint" href="#LinQuadOptInterface.get_sos_constraint"><code>LinQuadOptInterface.get_sos_constraint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_sos_constraint(m, idx::Int)::Tuple{Vector{Int}, Vector{Float64}, Symbol}</code></pre><p>Get the SOS constraint <code>idx</code> from the model <code>m</code>. Returns the triplet     <code>(cols, vals, typ)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_termination_status" href="#LinQuadOptInterface.get_termination_status"><code>LinQuadOptInterface.get_termination_status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_termination_status(m)</code></pre><p>Get the termination status of the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_unbounded_ray!" href="#LinQuadOptInterface.get_unbounded_ray!"><code>LinQuadOptInterface.get_unbounded_ray!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_unbounded_ray!(m, x::Vector{Float64})</code></pre><p>Get the unbounded ray (certificate of dual infeasiblility) for the linear constraints in the model <code>m</code>, and store in <code>x</code>. <code>x</code>must have one element for each variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_variable_dual_solution!" href="#LinQuadOptInterface.get_variable_dual_solution!"><code>LinQuadOptInterface.get_variable_dual_solution!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_variable_dual_solution!(m, x::Vector{Float64})</code></pre><p>Get the dual solution (reduced-costs) for the variables in the model <code>m</code>, and store in <code>x</code>. <code>x</code>must have one element for each variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_variable_lowerbound" href="#LinQuadOptInterface.get_variable_lowerbound"><code>LinQuadOptInterface.get_variable_lowerbound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_variable_lowerbound(m, col::Int)::Float64</code></pre><p>Get the lower bound of the variable in 1-indexed column <code>col</code> of the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_variable_primal_solution!" href="#LinQuadOptInterface.get_variable_primal_solution!"><code>LinQuadOptInterface.get_variable_primal_solution!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_variable_primal_solution!(m, x::Vector{Float64})</code></pre><p>Get the primal solution for the variables in the model <code>m</code>, and store in <code>x</code>. <code>x</code>must have one element for each variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.get_variable_upperbound" href="#LinQuadOptInterface.get_variable_upperbound"><code>LinQuadOptInterface.get_variable_upperbound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_variable_upperbound(m, col::Int)::Float64</code></pre><p>Get the upper bound of the variable in 1-indexed column <code>col</code> of the model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.has_integer-Tuple{LinQuadOptInterface.LinQuadOptimizer}" href="#LinQuadOptInterface.has_integer-Tuple{LinQuadOptInterface.LinQuadOptimizer}"><code>LinQuadOptInterface.has_integer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">has_integer(model::LinQuadOptimizer)::Bool</code></pre><p>A helper function to determine if <code>model</code> has any integer components (i.e. binary, integer, special ordered sets, semicontinuous, or semi-integer variables).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.has_value-Union{Tuple{V}, Tuple{K}, Tuple{Dict{K,V},V}} where V where K" href="#LinQuadOptInterface.has_value-Union{Tuple{V}, Tuple{K}, Tuple{Dict{K,V},V}} where V where K"><code>LinQuadOptInterface.has_value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">has_value(dict::Dict{K, V}, value::V) where {K, V}</code></pre><p>Return true if <code>dict</code> has a <code>key=&gt;value</code> pair with <code>value</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.is_binding-Tuple{MathOptInterface.LessThan{Float64},Float64}" href="#LinQuadOptInterface.is_binding-Tuple{MathOptInterface.LessThan{Float64},Float64}"><code>LinQuadOptInterface.is_binding</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_binding(set, value::Float64)</code></pre><p>Return true if <code>value</code> is an extreme point of the set <code>set</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.make_problem_type_continuous-Tuple{LinQuadOptInterface.LinQuadOptimizer}" href="#LinQuadOptInterface.make_problem_type_continuous-Tuple{LinQuadOptInterface.LinQuadOptimizer}"><code>LinQuadOptInterface.make_problem_type_continuous</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">make_problem_type_continuous(m)::Nothing</code></pre><p>If an explicit call is needed to change the problem type continuous (e.g., CPLEX).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.make_problem_type_integer-Tuple{LinQuadOptInterface.LinQuadOptimizer}" href="#LinQuadOptInterface.make_problem_type_integer-Tuple{LinQuadOptInterface.LinQuadOptimizer}"><code>LinQuadOptInterface.make_problem_type_integer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">make_problem_type_integer(m)::Nothing</code></pre><p>If an explicit call is needed to change the problem type integer (e.g., CPLEX).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.modify_ranged_constraints!" href="#LinQuadOptInterface.modify_ranged_constraints!"><code>LinQuadOptInterface.modify_ranged_constraints!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">modify_ranged_constraints!(m, rows::Vector{Int}, lowerbound::Vector{Float64}, upperbound::Vector{Float64})</code></pre><p>Modify the lower and upperbounds of a ranged constraint in the model <code>m</code>.</p><p>This is a special case compared to standard the <code>change_rhs_coefficient!</code> since it is often implemented via multiple API calls.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.print_low_level_solution-Tuple{Any}" href="#LinQuadOptInterface.print_low_level_solution-Tuple{Any}"><code>LinQuadOptInterface.print_low_level_solution</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Solution builder to create solutions for the mock solver. Should be called inside <code>MOI.optimize!(model::LinQuadOptimizer)</code> right before changing signs. This means that these solutions replicate the low-level solver output. The idea is to run the test with a solver like Xpress, Gurobi, GLPK or CPLEX to obtain the detailed solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.reduce_duplicates!-Union{Tuple{T}, Tuple{S}, Tuple{Array{T,1},Array{T,1},Array{S,1}}} where T where S" href="#LinQuadOptInterface.reduce_duplicates!-Union{Tuple{T}, Tuple{S}, Tuple{Array{T,1},Array{T,1},Array{S,1}}} where T where S"><code>LinQuadOptInterface.reduce_duplicates!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">reduce_duplicates!(rows::Vector{T}, cols::Vector{T}, vals::Vector{S})</code></pre><p>Given a matrix specified by row indices in <code>rows</code>, column indices in <code>cols</code> and coefficients in <code>vals</code>, return new <code>rows</code>, <code>cols</code>, and <code>vals</code> vectors with duplicate elements summed and any coefficients in the lower triangle moved to the upper triangle.</p><p>This function swaps element <code>i</code> in <code>rows</code> and <code>cols</code> if <code>rows[i]&gt;cols[i]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; reduce_duplicates!(
    [1,   2, 2, 2],  # rows
    [1,   1, 2, 2],  # cols
    [1, 0.5, 1, 1]   # vals
    )
([1, 1, 2], [1, 2, 2], [1.0, 0.5, 2.0])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.set_constant_objective!-Tuple{LinQuadOptInterface.LinQuadOptimizer,Any}" href="#LinQuadOptInterface.set_constant_objective!-Tuple{LinQuadOptInterface.LinQuadOptimizer,Any}"><code>LinQuadOptInterface.set_constant_objective!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_constant_objective!(m, value)::Nothing</code></pre><p>Set the constant (i.e. offset) component of the objective function to the given value.</p><p>Solver interfaces that overload this behavior (e.g. to pass that constant objective to the solver itself) must also overload <code>get_constant_objective(m)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.set_linear_objective!" href="#LinQuadOptInterface.set_linear_objective!"><code>LinQuadOptInterface.set_linear_objective!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_linear_objective!(m, cols::Vector{Int}, coefs::Vector{Float64})::Nothing</code></pre><p>Set the linear component of the objective.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.set_quadratic_objective!" href="#LinQuadOptInterface.set_quadratic_objective!"><code>LinQuadOptInterface.set_quadratic_objective!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_quadratic_objective!(m, I::Vector{Int}, J::Vector{Int}, V::Vector{Float64})::Nothing</code></pre><p>Set the quadratic component of the objective. Arguments given in triplet form for the Q matrix in <code>0.5 x&#39; Q x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.shift_references_after_delete_affine!-Tuple{Any,Any}" href="#LinQuadOptInterface.shift_references_after_delete_affine!-Tuple{Any,Any}"><code>LinQuadOptInterface.shift_references_after_delete_affine!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">shift_references_after_delete_affine!(m, row)</code></pre><p>This function updates all of the references in <code>m</code> after we have deleted row <code>row</code> in the affine constraint matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.shift_references_after_delete_quadratic!-Tuple{Any,Any}" href="#LinQuadOptInterface.shift_references_after_delete_quadratic!-Tuple{Any,Any}"><code>LinQuadOptInterface.shift_references_after_delete_quadratic!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">shift_references_after_delete_quadratic!(m, row)</code></pre><p>This function updates all of the references in <code>m</code> after we have deleted row <code>row</code> in the quadratic constraint matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.solve_linear_problem!" href="#LinQuadOptInterface.solve_linear_problem!"><code>LinQuadOptInterface.solve_linear_problem!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solve_linear_problem!(m)::Nothing</code></pre><p>Solve a linear program <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.solve_mip_problem!" href="#LinQuadOptInterface.solve_mip_problem!"><code>LinQuadOptInterface.solve_mip_problem!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solve_mip_problem!(m)::Nothing</code></pre><p>Solve a mixed-integer model <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.solve_quadratic_problem!" href="#LinQuadOptInterface.solve_quadratic_problem!"><code>LinQuadOptInterface.solve_quadratic_problem!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solve_quadratic_problem!(m)::Nothing</code></pre><p>Solve a model <code>m</code> with quadratic components.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.supported_constraints" href="#LinQuadOptInterface.supported_constraints"><code>LinQuadOptInterface.supported_constraints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">supported_constraints(m)::Vector{
    Tuple{MOI.AbstractFunction, MOI.AbstractSet}
}</code></pre><p>Get a list of supported constraint types in the model <code>m</code>.</p><p>For example, <code>[(LQOI.Linear, LQOI.EQ)]</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.supported_objectives" href="#LinQuadOptInterface.supported_objectives"><code>LinQuadOptInterface.supported_objectives</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">supported_objectives(m)::Vector{MOI.AbstractScalarFunction}</code></pre><p>Get a list of supported objective types in the model <code>m</code>.</p><p>For example, <code>[LQOI.Linear, LQOI.Quad]</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.unload" href="#LinQuadOptInterface.unload"><code>LinQuadOptInterface.unload</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unload(from::Vector, to, warn = true)</code></pre><p>Helper function to remove the first element of a vector and return it. If the vector is empty data in <code>default</code> is returned instead. Used in <code>fakesolve</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinQuadOptInterface.unsafe_set!-Union{Tuple{F}, Tuple{LinQuadOptimizer,ObjectiveFunction{F},ScalarAffineFunction{Float64}}} where F" href="#LinQuadOptInterface.unsafe_set!-Union{Tuple{F}, Tuple{LinQuadOptimizer,ObjectiveFunction{F},ScalarAffineFunction{Float64}}} where F"><code>LinQuadOptInterface.unsafe_set!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_set!(m, ::MOI.ObjectiveFunction{F}, objective::Linear) where F</code></pre><p>Sets a linear objective function without cannonicalizing <code>objective</code>.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
