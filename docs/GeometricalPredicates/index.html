<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · GeometricalPredicates.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GeometricalPredicates.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#How-does-it-work?-1">How does it work?</a></li><li><a class="toctext" href="#Current-limitations-1">Current limitations</a></li><li><a class="toctext" href="#How-to-use?-1">How to use?</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="GeometricalPredicates.jl-1" href="#GeometricalPredicates.jl-1">GeometricalPredicates.jl</a></h1><p><a href="https://travis-ci.org/JuliaGeometry/GeometricalPredicates.jl"><img src="https://travis-ci.org/JuliaGeometry/GeometricalPredicates.jl.svg?branch=master" alt="Build Status"/></a> <a href="http://pkg.julialang.org/detail/GeometricalPredicates"><img src="http://pkg.julialang.org/badges/GeometricalPredicates_0.6.svg" alt="GeometricalPredicates"/></a> <a href="https://coveralls.io/r/JuliaGeometry/GeometricalPredicates.jl?branch=master"><img src="https://coveralls.io/repos/JuliaGeometry/GeometricalPredicates.jl/badge.svg?branch=master" alt="Coverage Status"/></a></p><p>Fast, robust 2D and 3D geometrical predicates on generic point types. Implementation follows algorithms described in the <a href="http://arxiv.org/abs/0901.4107">Arepo paper</a> and used (for e.g.) in the <a href="http://www.illustris-project.org/">Illustris Simulation</a>. License: MIT. Bug reports welcome!</p><h2><a class="nav-anchor" id="How-does-it-work?-1" href="#How-does-it-work?-1">How does it work?</a></h2><p>Calculations are initially performed on <code>Float64</code> while bounding max absolute errors. If unable to determine result, fall back to exact calculation using <code>BigInt</code>s. This is a form of floating point filtering. Most calculations are cached for fast repeated testing of incircle/intriangle predicates.</p><h2><a class="nav-anchor" id="Current-limitations-1" href="#Current-limitations-1">Current limitations</a></h2><ul><li>Due to the numerical methods used, all coordinates are internally represented as <code>Float64</code>. In addition all must reside in the range <code>1.0&lt;=x&lt;2.0</code>. In this range, according to IEEE754, <code>Float64</code>s have a constant exponent, hence their mantissa can be used for a one to one mapping to integers, which in turn are used for exact calculations using <code>BigInt</code>s.</li><li>It is assumed that primitive vertices don&#39;t overlap. It is currently the responsibility of the user to make sure this is the case.</li><li>It is assumed tetrahedron vertices don&#39;t all lie in the same line. It is the user&#39;s responsibility to make sure it is so.</li><li>Testing points are assumed not to overlap any vertices. As usual, it is the user&#39;s responsibility to make sure this is the case.</li></ul><p>Except for the 1st restriction, all others could be easily implemented. Currently these features are not needed by me. If you need missing features, please open an issue I may develop it!</p><h2><a class="nav-anchor" id="How-to-use?-1" href="#How-to-use?-1">How to use?</a></h2><h3><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h3><pre><code class="language-julia">Pkg.add(&quot;GeometricalPredicates&quot;)</code></pre><h3><a class="nav-anchor" id="Points-1" href="#Points-1">Points</a></h3><pre><code class="language-julia">using GeometricalPredicates

# create a 2D point in (x, y) = (1.1, 1.9)
mypoint = Point(1.1, 1.9)
typeof(mypoint) # -&gt; Point2D

# create a 3D point in (x, y, z) = (1.1, 1.9, 1.5)
mypoint = Point(1.1, 1.9, 1.5)
typeof(mypoint) # -&gt; Point3D

# getting coordinates:
getx(mypoint) # -&gt; 1.1
gety(mypoint) # -&gt; 1.9
getz(mypoint) # -&gt; 1.5</code></pre><p><code>Point2D</code> inherits from <code>AbstractPoint2D</code>and <code>Point3D</code> inherits from <code>AbstractPoint3D</code>. You can implement custom point types by inheriting from these abstract types. These custom point types can be used with the rest of the package:</p><pre><code class="language-julia">type MyCustomPointType &lt;: AbstractPoint2D
    _x::FLoat64
    _y::Float64
    _mass::Float64
end

getx(p::MyCustomPointType) = p._x
gety(p::MyCustomPointType) = p._y</code></pre><p>implementing <code>getx</code>, <code>gety</code>, and <code>getz</code> for 3D points is necessary as this is the interface the package is expecting. These function should return <code>Float64</code>. Points can be either immutables or types. Default <code>Point2D</code> and <code>Point3D</code> are immutables.</p><p>The point coordinates must reside in a region <code>1.0 &lt;= x &lt; 2.0</code>. Read above on why this limitation is necessary. For convenience there are 2 constants defined, <code>min_coord</code> and <code>max coord</code> representing the minimal and maximal feasible values of coordinates.</p><h3><a class="nav-anchor" id="Triangles-and-Tetrahedrons-(..aka-Primitives)-1" href="#Triangles-and-Tetrahedrons-(..aka-Primitives)-1">Triangles and Tetrahedrons (..aka Primitives)</a></h3><p>A triangle is the 2D primitive, and a tetrahedron is the 3D primitive.</p><pre><code class="language-julia"># create a triangle using 3 points
a = Point(1.1, 1.1)
b = Point(1.9, 1.1)
c = Point(1.1, 1.9)
mytriangle = Primitive(a, b, c)
typeof(mytriangle) # -&gt; UnOrientedTriangle{Point2D}</code></pre><p>The triangle is unoriented in the sense that orientation is not-known in advance, it is not immutable and it could change if points in the triangle are updated. The orientation needs to be calculated when the triangle is created and when points within are updated. Read below for the definition of orientation. The triangle could be created using any points inheriting from <code>AbstractPoint2D</code> which implement <code>getx</code> and <code>gety</code>, or using coordinates directly:</p><pre><code class="language-julia">mytriangle = Primitive(1.1, 1.1, 1.9, 1.1, 1.1, 1.9)

# Getting point `a` in the triangle
geta(mytriangle) # -&gt; Point2D(1.1, 1.1)
getb(mytriangle) # -&gt; Point2D(1.9, 1.1)
getc(mytriangle) # -&gt; Point2D(1.1, 1.9)</code></pre><p>The same goes for tetrahedrons, except we now use 4 3D points instead of 3 2D ones:</p><pre><code class="language-julia"># create a tetrahedron using 4 points
a = Point(1.1, 1.1, 1.1)
b = Point(1.9, 1.1, 1.1)
c = Point(1.1, 1.9, 1.1)
d = Point(1.1, 1.1, 1.9)
mytetraedron = Primitive(a, b, c, d)
typeof(mytetrahedron) # -&gt; UnOrientedTetrahedron{Point3D}</code></pre><p>For certain applications we use primitives with known orientation. In those cases there should be no need to calculate it. This is achieved by passing an <code>orientation</code> flag to the <code>Primitive</code> creation function:</p><pre><code class="language-julia">mytetrahedron = Primitive(a, b, c, d, positivelyoriented)
typeof(mytetrahedron) # -&gt; PositivelyOrientedTetrahedron{Point3D}
orientation(mytetrahedron) # -&gt; constant 1, not calculated
mytetrahedron = Primitive(a, b, c, d, negativelyoriented)
typeof(mytetrahedron) # -&gt; NegativelyOrientedTetrahedron{Point3D}
orientation(mytetrahedron) # -&gt; constant -1, not calculated</code></pre><p>Note that when the primitive is oriented the real orientation is never calculated. It is assumed that the user knows what he&#39;s doing. If in doubt, just use unoriented primitives at the cost of actual calculation.</p><p>Updating points in primitives can be done with <code>seta</code>, <code>setb</code>, etc. methods:</p><pre><code class="language-julia">seta(mytriangle, Point(1.7, 1.7))</code></pre><p>Updating a point in a primitive will fire all relevant pre-calculations. i.e. if the triangle is unoriented then orientation will be calculated. If it is oriented then still a few other pre-calculations will be done, but a few less. If there is need to update a number of points it is thus more efficient to do so in a group update:</p><pre><code class="language-julia">setab(mytriangle, Point(1.7, 1.7), Point(1.3, 1.1))
setbcd(mytetrahedron, Point(1.1, 1.1, 1.2), Point(1.2,1.1,1.3), Point(1.4,1.1,1.2))</code></pre><p>combinations for all points exist. The name always contains the point names in alphabetical order. As long as inner primitive data is not changed manually, it will keep giving correct results for all functions in this package.</p><h3><a class="nav-anchor" id="Predicates-1" href="#Predicates-1">Predicates</a></h3><p><code>incircle</code> is the popular name to test whether a point lies inside of the sphere defined by the primitive points:</p><pre><code class="language-julia">a = Point(1.1, 1.1)
b = Point(1.5, 1.1)
c = Point(1.1, 1.5)
mytriangle = Primitive(a, b, c)
incircle(mytriangle, Point(1.9, 1.9)) # -&gt; -1, i.e. outside
incircle(mytriangle, Point(1.2, 1.2)) # -&gt; +1, i.e. inside
incircle(mytriangle, Point(1.5, 1.5)) # -&gt;  0, i.e. point is exactly on circle</code></pre><p>There is one more possibility. If the circle defined by our primitive has infinite radius then it is impossible to tell whether the point is inside or outside:</p><pre><code class="language-julia">a = Point(1.1, 1.1)
b = Point(1.2, 1.2)
c = Point(1.3, 1.3)
mytriangle = Primitive(a, b, c)
incircle(mytriangle, Point(1.3, 1.4)) # -&gt; +2, i.e. cannot tell</code></pre><p><code>intriangle</code> is a popular name to test whether a point lies inside of the primitive:</p><pre><code class="language-julia">a = Point(1.1, 1.1)
b = Point(1.5, 1.1)
c = Point(1.1, 1.5)
mytriangle = Primitive(a, b, c)
intriangle(mytriangle, Point(1.2, 1.2)) # -&gt; +1, i.e. inside
intriangle(mytriangle, Point(1.6, 1.6)) # -&gt; -1, i.e. outside
intriangle(mytriangle, Point(1.3, 1.1)) # -&gt;  4, i.e. exactly on ab
intriangle(mytriangle, Point(1.1, 1.3)) # -&gt;  3, i.e. exactly on ac
intriangle(mytriangle, Point(1.3, 1.3)) # -&gt;  2, i.e. exactly on bc
</code></pre><p>Here any negative number means outside. The exact value gives some information regarding the direction in which the point lies outside:</p><ul><li><code>-1</code> means the test point is in front of a, and outside of the triangle</li><li><code>-2</code> means the test point is in front of b, and outside of the triangle</li><li><code>-4</code> means the test point is in front of c, and outside of the triangle</li></ul><p>same goes for tetrahedrons. Note that the point could be both in front of a and b. In cases as this one is arbitrarily chosen, all in name of performance.</p><p><code>1</code> means test point is inside. But there are other possible positive values:</p><ul><li><code>1 + 1 = 2</code> means the test point is in front of a, exactly on the triangle</li><li><code>1 + 2 = 3</code> means the test point is in front of b, exactly on the triangle</li><li><code>1 + 3 = 4</code> means the test point is in front of c, exactly on the triangle</li></ul><p>same extends for tetrahedrons.</p><h3><a class="nav-anchor" id="Lines-and-Polygons-1" href="#Lines-and-Polygons-1">Lines and Polygons</a></h3><p><code>orientation</code> tests for the primitive orientation. In 2D this means:</p><ul><li><code>1</code> –&gt; point <code>c</code> is to the left of the line defined by <code>ab</code> (with directionality from <code>a</code> to <code>b</code>)</li><li><code>-1</code> –&gt; point <code>c</code> is to the right</li><li><code>0</code> –&gt; point <code>c</code> is exactly on the line</li></ul><p>in 3D it means:</p><ul><li><code>1</code> –&gt; point <code>d</code> is above the plane defined by <code>abc</code> (note &quot;above&quot; here means the direction of the plane normal, which depends on its orientation)</li><li><code>-1</code> –&gt; point <code>d</code> is below the plane</li><li><code>0</code> –&gt; point <code>c</code> is exactly on the plane</li></ul><p>Another convenience API to test for orientation in 2D is using a line. It has some performance advantages over creating a triangle:</p><pre><code class="language-julia">a = Point(1.1, 1.1)
b = Point(1.5, 1.5)

l = Line(a, b)
println(orientation(l, Point(1.4, 1.6))) # --&gt;  1
println(orientation(l, Point(1.4,1.05))) # --&gt; -1
println(orientation(l, Point(1.4,1.40))) # --&gt;  0</code></pre><p>One can also create simple 2D polygons:</p><pre><code class="language-julia">ll = Point(1.0,1.0)
lr = Point(1.2,1.0)
ur = Point(1.2,1.2)
ul = Point(1.0,1.2)
poly = Polygon(ll, lr, ur, ul)
inpolygon(poly, Point(1.1,1.1))  # assumes it is convex</code></pre><h3><a class="nav-anchor" id="Basic-geometrical-properties-1" href="#Basic-geometrical-properties-1">Basic geometrical properties</a></h3><p><code>orientation</code> gives the primitive orientation. <code>area</code>, <code>volume</code>, <code>centroid</code>, <code>circumcenter</code>, <code>circumradius2</code> are all exported and I hope self descriptive.</p><h3><a class="nav-anchor" id="Spatial-ordering-1" href="#Spatial-ordering-1">Spatial ordering</a></h3><p>Scale and scale-free Peano-Hilbert ordering is available. Look <a href="http://doc.cgal.org/latest/Spatial_sorting/index.html">here</a> for a nice explanation on Hilbert sorting and <a href="http://doc.cgal.org/latest/Spatial_sorting/classCGAL_1_1Multiscale__sort.html">here</a> for a nice explanation of multiscale sort. Both are implemented here:</p><pre><code class="language-julia">p = Point(1.1, 1.2)
peanokey(p, 4) # -&gt; 6, the peano key in a regular grid of 2^4 X 2^4 cells

p = Point(1.1, 1.2, 1.3)
peanokey(p, 4) # -&gt; 94, the peano key in a regular grid of 2^4 X 2^4 X 2^4 cells</code></pre><p>The number of cells doesn&#39;t need to be specified. The default for 2D is <code>2^31 X 2^31</code> and for 3D <code>2^21 X 2^21 X 2^21</code>. You can also do the inverse, and get a point from a key:</p><pre><code class="language-julia">Point2D(6, 4) # -&gt; Point2D(1.0625,1.1875)</code></pre><p>in a finer grid we would get back something more accurate.</p><p>So that was scale-dependent Hilbert stuff, which is good to say balance workload between computing nodes. When you need to order particles spatially it is better to use a scale independent method, like the Hilbert ordering here:</p><pre><code class="language-julia">a = [Point(1.0+rand(), 1.0+rand() for i in 1:1e6]
hilbertsort!(a)</code></pre><p>Here keys are never calculated, and there is no grid, it uses a median policy, adjusting to the actual point distribution. There are a few parameters with good defaults, see links above to understand what they mean. For an algorithm such a Delaunay tesselation it is sometimes better to use a multi-scale sort with a Hilbert sort, like this:</p><pre><code class="language-julia">mssort!(a)</code></pre><p>of course this adds a few more default parameters, again with decent defaults, read above links to understand.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
