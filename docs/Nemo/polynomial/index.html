<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Univariate polynomials · Nemo.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Nemo.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Getting Started</a></li><li><a class="toctext" href="../about/">About Nemo</a></li><li><a class="toctext" href="../types/">Types in Nemo</a></li><li><a class="toctext" href="../constructors/">Constructing mathematical objects in Nemo</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="../integer/">Integers</a></li><li class="current"><a class="toctext" href>Univariate polynomials</a><ul class="internal"><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Polynomial-functionality-1">Polynomial functionality</a></li></ul></li><li><a class="toctext" href="../series/">Power series and Laurent series</a></li><li><a class="toctext" href="../puiseux/">Puiseux series</a></li><li><a class="toctext" href="../residue/">Residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li><a class="toctext" href="../fraction/">Fraction fields</a></li><li><a class="toctext" href="../rational/">Rationals</a></li><li><a class="toctext" href="../arb/">Real balls</a></li><li><a class="toctext" href="../acb/">Complex balls</a></li><li><a class="toctext" href="../gfp/">Galois fields</a></li><li><a class="toctext" href="../finitefield/">Finite fields</a></li><li><a class="toctext" href="../numberfield/">Number field arithmetic</a></li><li><a class="toctext" href="../padic/">Padics</a></li></ul></li><li><a class="toctext" href="../matrix/">Matrices</a></li><li><a class="toctext" href="../factor/">Factorisation</a></li></ul></nav><article id="docs"><header><nav><ul><li>Rings</li><li><a href>Univariate polynomials</a></li></ul></nav><hr/><div id="topbar"><span>Univariate polynomials</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Univariate-polynomials-1" href="#Univariate-polynomials-1">Univariate polynomials</a></h1><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>Nemo allow the creation of dense, univariate polynomials over any computable ring <span>$R$</span>. There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of polynomials over numerous specific rings, usually provided by C/C++ libraries.</p><p>The following table shows each of the polynomial types available in Nemo, the base ring <span>$R$</span>, and the Julia/Nemo types for that kind of polynomial (the type information is mainly of concern to developers).</p><table><tr><th>Base ring</th><th>Library</th><th>Element type</th><th>Parent type</th></tr><tr><td>Generic ring <span>$R$</span></td><td>AbstractAlgebra.jl</td><td><code>Generic.Poly{T}</code></td><td><code>Generic.PolyRing{T}</code></td></tr><tr><td><span>$\mathbb{Z}$</span></td><td>Flint</td><td><code>fmpz_poly</code></td><td><code>FmpzPolyRing</code></td></tr><tr><td><span>$\mathbb{Z}/n\mathbb{Z}$</span> (small <span>$n$</span>)</td><td>Flint</td><td><code>nmod_poly</code></td><td><code>NmodPolyRing</code></td></tr><tr><td><span>$\mathbb{Z}/n\mathbb{Z}$</span> (large <span>$n$</span>)</td><td>Flint</td><td><code>fmpz_mod_poly</code></td><td><code>FmpzModPolyRing</code></td></tr><tr><td><span>$\mathbb{Q}$</span></td><td>Flint</td><td><code>fmpq_poly</code></td><td><code>FmpqPolyRing</code></td></tr><tr><td><span>$\mathbb{Z}/p\mathbb{Z}$</span> (small prime <span>$p$</span>)</td><td>Flint</td><td><code>gfp_poly</code></td><td><code>GFPPolyRing</code></td></tr><tr><td><span>$\mathbb{Z}/p\mathbb{Z}$</span> (large prime <span>$p$</span>)</td><td>Flint</td><td><code>gfp_fmpz_poly</code></td><td><code>GFPFmpzPolyRing</code></td></tr><tr><td><span>$\mathbb{F}_{p^n}$</span> (small <span>$p$</span>)</td><td>Flint</td><td><code>fq_nmod_poly</code></td><td><code>FqNmodPolyRing</code></td></tr><tr><td><span>$\mathbb{F}_{p^n}$</span> (large <span>$p$</span>)</td><td>Flint</td><td><code>fq_poly</code></td><td><code>FqPolyRing</code></td></tr><tr><td><span>$\mathbb{R}$</span></td><td>Arb</td><td><code>arb_poly</code></td><td><code>ArbPolyRing</code></td></tr><tr><td><span>$\mathbb{C}$</span></td><td>Arb</td><td><code>acb_poly</code></td><td><code>AcbPolyRing</code></td></tr></table><p>The string representation of the variable and the base ring <span>$R$</span> of a generic polynomial is stored in its parent object. </p><p>All polynomial element types belong to the abstract type <code>PolyElem</code> and all of the polynomial ring types belong to the abstract type <code>PolyRing</code>. This enables one to write generic functions that can accept any Nemo univariate polynomial type.</p><h2><a class="nav-anchor" id="Polynomial-functionality-1" href="#Polynomial-functionality-1">Polynomial functionality</a></h2><p>All univariate polynomial types in Nemo follow the AbstractAlgebra.jl univariate polynomial interface:</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/polynomial_rings.html">https://nemocas.github.io/AbstractAlgebra.jl/polynomial_rings.html</a></p><p>Generic polynomials are also available, and Nemo univariate polynomial types also implement all of the same functionality.</p><p>We describe here only functions that are in addition to that guaranteed by AbstractAlgebra.jl, for specific coefficient rings.</p><h3><a class="nav-anchor" id="Remove-and-valuation-1" href="#Remove-and-valuation-1">Remove and valuation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.evaluate2-Tuple{arb_poly,Integer}" href="#Nemo.evaluate2-Tuple{arb_poly,Integer}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate2(x::arb_poly, y::Integer)</code></pre><blockquote><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.evaluate2-Tuple{arb_poly,Float64}" href="#Nemo.evaluate2-Tuple{arb_poly,Float64}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate2(x::arb_poly, y::Float64)</code></pre><blockquote><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.evaluate2-Tuple{arb_poly,fmpz}" href="#Nemo.evaluate2-Tuple{arb_poly,fmpz}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate2(x::arb_poly, y::fmpz)</code></pre><blockquote><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.evaluate2-Tuple{arb_poly,fmpq}" href="#Nemo.evaluate2-Tuple{arb_poly,fmpq}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate2(x::arb_poly, y::fmpq)</code></pre><blockquote><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.evaluate2-Tuple{arb_poly,arb}" href="#Nemo.evaluate2-Tuple{arb_poly,arb}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate2(x::arb_poly, y::arb)</code></pre><blockquote><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.evaluate2-Tuple{arb_poly,acb}" href="#Nemo.evaluate2-Tuple{arb_poly,acb}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate2(x::arb_poly, y::acb)</code></pre><blockquote><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.evaluate2-Tuple{acb_poly,Integer}" href="#Nemo.evaluate2-Tuple{acb_poly,Integer}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate2(x::acb_poly, y::Integer)</code></pre><blockquote><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.evaluate2-Tuple{acb_poly,Float64}" href="#Nemo.evaluate2-Tuple{acb_poly,Float64}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate2(x::acb_poly, y::Float64)</code></pre><blockquote><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.evaluate2-Tuple{acb_poly,fmpz}" href="#Nemo.evaluate2-Tuple{acb_poly,fmpz}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate2(x::acb_poly, y::fmpq)</code></pre><blockquote><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.evaluate2-Tuple{acb_poly,fmpq}" href="#Nemo.evaluate2-Tuple{acb_poly,fmpq}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate2(x::acb_poly, y::fmpq)</code></pre><blockquote><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.evaluate2-Tuple{acb_poly,arb}" href="#Nemo.evaluate2-Tuple{acb_poly,arb}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate2(x::acb_poly, y::arb)</code></pre><blockquote><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.evaluate2-Tuple{acb_poly,acb}" href="#Nemo.evaluate2-Tuple{acb_poly,acb}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate2(x::acb_poly, y::acb)</code></pre><blockquote><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">RR = RealField(64)
T, z = PolynomialRing(RR, &quot;z&quot;)
   
h = z^2 + 2z + 1

s, t = evaluate2(h, RR(&quot;2.0 +/- 0.1&quot;))</code></pre><h3><a class="nav-anchor" id="Signature-1" href="#Signature-1">Signature</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.signature-Tuple{fmpz_poly}" href="#Nemo.signature-Tuple{fmpz_poly}"><code>Nemo.signature</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">signature(f::fmpz_poly)</code></pre><blockquote><p>Return the signature of the polynomial <span>$f$</span>, i.e. a tuple <span>$(r, s)$</span> such that <span>$r$</span> is the number of real roots of <span>$f$</span> and <span>$s$</span> is half the number of complex roots.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.signature-Tuple{fmpq_poly}" href="#Nemo.signature-Tuple{fmpq_poly}"><code>Nemo.signature</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">signature(f::fmpq_poly)</code></pre><blockquote><p>Return the signature of <span>$f$</span>, i.e. a tuple <span>$(r, s)$</span> where <span>$r$</span> is the number of real roots of <span>$f$</span> and <span>$s$</span> is half the number of complex roots.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, x = PolynomialRing(ZZ, &quot;x&quot;)

f = x^3 + 3x + 1

(r, s) = signature(f)</code></pre><h3><a class="nav-anchor" id="Root-finding-1" href="#Root-finding-1">Root finding</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.roots-Tuple{acb_poly}" href="#Nemo.roots-Tuple{acb_poly}"><code>Nemo.roots</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">roots(x::acb_poly; target=0, isolate_real=false, initial_prec=0, max_prec=0, max_iter=0)</code></pre><blockquote><p>Attempts to isolate the complex roots of the complex polynomial <span>$x$</span> by iteratively refining balls in which they lie.</p><p>This is done by increasing the working precision, starting at <code>initial_prec</code>. The maximal number of iterations can be set using <code>max_iter</code> and the maximal precision can be set using <code>max_prec</code>.</p><p>If <code>isolate_real</code> is set and <span>$x$</span> is strictly real, then the real roots will be isolated from the non-real roots. Every root will have either zero, positive or negative real part.</p><p>It is assumed that <span>$x$</span> is squarefree.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">CC = ComplexField(64)
C, y = PolynomialRing(CC, &quot;y&quot;)

m = y^2 + 2y + 3
n = m + CC(&quot;0 +/- 0.0001&quot;, &quot;0 +/- 0.0001&quot;)

r = roots(n)

p = y^7 - 1

r = roots(n, isolate_real = true)</code></pre><h3><a class="nav-anchor" id="Construction-from-roots-1" href="#Construction-from-roots-1">Construction from roots</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.from_roots-Tuple{ArbPolyRing,Array{arb,1}}" href="#Nemo.from_roots-Tuple{ArbPolyRing,Array{arb,1}}"><code>Nemo.from_roots</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">from_roots(R::ArbPolyRing, b::Array{arb, 1})</code></pre><blockquote><p>Construct a polynomial in the given polynomial ring from a list of its roots.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.from_roots-Tuple{AcbPolyRing,Array{acb,1}}" href="#Nemo.from_roots-Tuple{AcbPolyRing,Array{acb,1}}"><code>Nemo.from_roots</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">from_roots(R::AcbPolyRing, b::Array{acb, 1})</code></pre><blockquote><p>Construct a polynomial in the given polynomial ring from a list of its roots.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">RR = RealField(64)
R, x = PolynomialRing(RR, &quot;x&quot;)

xs = arb[inv(RR(i)) for i=1:5]
f = from_roots(R, xs)</code></pre><h3><a class="nav-anchor" id="Bounding-absolute-values-of-roots-1" href="#Bounding-absolute-values-of-roots-1">Bounding absolute values of roots</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.roots_upper_bound-Tuple{arb_poly}" href="#Nemo.roots_upper_bound-Tuple{arb_poly}"><code>Nemo.roots_upper_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">roots_upper_bound(f::arb_poly) -&gt; arb</code></pre><blockquote><p>Returns an upper bound for the absolute value of all complex roots of <span>$f$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.roots_upper_bound-Tuple{acb_poly}" href="#Nemo.roots_upper_bound-Tuple{acb_poly}"><code>Nemo.roots_upper_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">roots_upper_bound(f::acb_poly) -&gt; arb</code></pre><blockquote><p>Returns an upper bound for the absolute value of all complex roots of <span>$f$</span>.</p></blockquote></div></section><h3><a class="nav-anchor" id="Lifting-1" href="#Lifting-1">Lifting</a></h3><p>When working over a residue ring it is useful to be able to lift to the base ring of the residue ring, e.g. from <span>$\mathbb{Z}/n\mathbb{Z}$</span> to <span>$\mathbb{Z}$</span>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.lift-Tuple{FmpzPolyRing,nmod_poly}" href="#Nemo.lift-Tuple{FmpzPolyRing,nmod_poly}"><code>Nemo.lift</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function lift(R::FmpzPolyRing, y::nmod_poly)</code></pre><blockquote><p>Lift from a polynomial over <span>$\mathbb{Z}/n\mathbb{Z}$</span> to a polynomial over <span>$\mathbb{Z}$</span> with minimal reduced nonnegative coefficients. The ring <code>R</code> specifies the ring to lift into.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.lift-Tuple{FmpzPolyRing,gfp_poly}" href="#Nemo.lift-Tuple{FmpzPolyRing,gfp_poly}"><code>Nemo.lift</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function lift(R::FmpzPolyRing, y::gfp_poly)</code></pre><blockquote><p>Lift from a polynomial over <span>$\mathbb{Z}/n\mathbb{Z}$</span> to a polynomial over <span>$\mathbb{Z}$</span> with minimal reduced nonnegative coefficients. The ring <code>R</code> specifies the ring to lift into.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.lift-Tuple{FmpzPolyRing,fmpz_mod_poly}" href="#Nemo.lift-Tuple{FmpzPolyRing,fmpz_mod_poly}"><code>Nemo.lift</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function lift(R::FmpzPolyRing, y::fmpz_mod_poly)</code></pre><blockquote><p>Lift from a polynomial over <span>$\mathbb{Z}/n\mathbb{Z}$</span> to a polynomial over <span>$\mathbb{Z}$</span> with minimal reduced nonnegative coefficients. The ring <code>R</code> specifies the ring to lift into.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.lift-Tuple{FmpzPolyRing,gfp_fmpz_poly}" href="#Nemo.lift-Tuple{FmpzPolyRing,gfp_fmpz_poly}"><code>Nemo.lift</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function lift(R::FmpzPolyRing, y::gfp_fmpz_poly)</code></pre><blockquote><p>Lift from a polynomial over <span>$\mathbb{Z}/n\mathbb{Z}$</span> to a polynomial over <span>$\mathbb{Z}$</span> with minimal reduced nonnegative coefficients. The ring <code>R</code> specifies the ring to lift into.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R = ResidueRing(ZZ, 123456789012345678949)
S, x = PolynomialRing(R, &quot;x&quot;)
T, y = PolynomialRing(ZZ, &quot;y&quot;)

f = x^2 + 2x + 1

a = lift(T, f)</code></pre><h3><a class="nav-anchor" id="Overlapping-and-containment-1" href="#Overlapping-and-containment-1">Overlapping and containment</a></h3><p>Occasionally it is useful to be able to tell when inexact polynomials overlap or contain other exact or inexact polynomials. The following functions are provided for this purpose.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.overlaps-Tuple{arb_poly,arb_poly}" href="#Nemo.overlaps-Tuple{arb_poly,arb_poly}"><code>Nemo.overlaps</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">overlaps(x::arb_poly, y::arb_poly)</code></pre><blockquote><p>Return <code>true</code> if the coefficient balls of <span>$x$</span> overlap the coefficient balls of <span>$y$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.overlaps-Tuple{acb_poly,acb_poly}" href="#Nemo.overlaps-Tuple{acb_poly,acb_poly}"><code>Nemo.overlaps</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">overlaps(x::acb_poly, y::acb_poly)</code></pre><blockquote><p>Return <code>true</code> if the coefficient boxes of <span>$x$</span> overlap the coefficient boxes of <span>$y$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.contains-Tuple{arb_poly,arb_poly}" href="#Nemo.contains-Tuple{arb_poly,arb_poly}"><code>Nemo.contains</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">contains(x::arb_poly, y::arb_poly)</code></pre><blockquote><p>Return <code>true</code> if the coefficient balls of <span>$x$</span> contain the corresponding coefficient balls of <span>$y$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.contains-Tuple{acb_poly,acb_poly}" href="#Nemo.contains-Tuple{acb_poly,acb_poly}"><code>Nemo.contains</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">contains(x::acb_poly, y::acb_poly)</code></pre><blockquote><p>Return <code>true</code> if the coefficient boxes of <span>$x$</span> contain the corresponding coefficient boxes of <span>$y$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.contains-Tuple{arb_poly,fmpz_poly}" href="#Nemo.contains-Tuple{arb_poly,fmpz_poly}"><code>Nemo.contains</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">contains(x::arb_poly, y::fmpz_poly)</code></pre><blockquote><p>Return <code>true</code> if the coefficient balls of <span>$x$</span> contain the corresponding exact coefficients of <span>$y$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.contains-Tuple{arb_poly,fmpq_poly}" href="#Nemo.contains-Tuple{arb_poly,fmpq_poly}"><code>Nemo.contains</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">contains(x::arb_poly, y::fmpq_poly)</code></pre><blockquote><p>Return <code>true</code> if the coefficient balls of <span>$x$</span> contain the corresponding exact coefficients of <span>$y$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.contains-Tuple{acb_poly,fmpz_poly}" href="#Nemo.contains-Tuple{acb_poly,fmpz_poly}"><code>Nemo.contains</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">contains(x::acb_poly, y::fmpz_poly)</code></pre><blockquote><p>Return <code>true</code> if the coefficient boxes of <span>$x$</span> contain the corresponding exact coefficients of <span>$y$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.contains-Tuple{acb_poly,fmpq_poly}" href="#Nemo.contains-Tuple{acb_poly,fmpq_poly}"><code>Nemo.contains</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">contains(x::acb_poly, y::fmpq_poly)</code></pre><blockquote><p>Return <code>true</code> if the coefficient boxes of <span>$x$</span> contain the corresponding exact coefficients of <span>$y$</span>, otherwise return <code>false</code>.</p></blockquote></div></section><p>It is sometimes also useful to be able to determine if there is a unique integer contained in the coefficient of an inexact constant polynomial.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.unique_integer-Tuple{arb_poly}" href="#Nemo.unique_integer-Tuple{arb_poly}"><code>Nemo.unique_integer</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">unique_integer(x::arb_poly)</code></pre><blockquote><p>Return a tuple <code>(t, z)</code> where <span>$t$</span> is <code>true</code> if there is a unique integer contained in each of the coefficients of <span>$x$</span>, otherwise sets <span>$t$</span> to <code>false</code>. In the former case, <span>$z$</span> is set to the integer polynomial.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.unique_integer-Tuple{acb_poly}" href="#Nemo.unique_integer-Tuple{acb_poly}"><code>Nemo.unique_integer</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">unique_integer(x::acb_poly)</code></pre><blockquote><p>Return a tuple <code>(t, z)</code> where <span>$t$</span> is <code>true</code> if there is a unique integer contained in the (constant) polynomial <span>$x$</span>, along with that integer <span>$z$</span> in case it is, otherwise sets <span>$t$</span> to <code>false</code>.</p></blockquote></div></section><p>We also have the following functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isreal-Tuple{acb_poly}" href="#Base.isreal-Tuple{acb_poly}"><code>Base.isreal</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isreal(x::acb_poly)</code></pre><blockquote><p>Return <code>true</code> if all the coefficients of <span>$x$</span> are real, i.e. have exact zero imaginary parts.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">RR = RealField(64)
CC = ComplexField(64)
R, x = PolynomialRing(RR, &quot;x&quot;)
C, y = PolynomialRing(CC, &quot;y&quot;)
Zx, zx = PolynomialRing(ZZ, &quot;x&quot;)
Qx, qx = PolynomialRing(QQ, &quot;x&quot;)

f = x^2 + 2x + 1
h = f + RR(&quot;0 +/- 0.0001&quot;)
k = f + RR(&quot;0 +/- 0.0001&quot;) * x^4
m = y^2 + 2y + 1
n = m + CC(&quot;0 +/- 0.0001&quot;, &quot;0 +/- 0.0001&quot;)

contains(h, f)
overlaps(f, k)
contains(n, m)
t, z = unique_integer(k)
isreal(n)</code></pre><h3><a class="nav-anchor" id="Factorisation-1" href="#Factorisation-1">Factorisation</a></h3><p>Polynomials can be factorised over certain rings. In general we use the same format for the output as the Julia factorisation function, namely an associative array with polynomial factors as keys and exponents as values.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.isirreducible-Tuple{nmod_poly}" href="#Nemo.isirreducible-Tuple{nmod_poly}"><code>Nemo.isirreducible</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isirreducible(x::nmod_poly)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is irreducible, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.isirreducible-Tuple{gfp_poly}" href="#Nemo.isirreducible-Tuple{gfp_poly}"><code>Nemo.isirreducible</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isirreducible(x::gfp_poly)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is irreducible, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.isirreducible-Tuple{fmpz_mod_poly}" href="#Nemo.isirreducible-Tuple{fmpz_mod_poly}"><code>Nemo.isirreducible</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isirreducible(x::fmpz_mod_poly)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is irreducible, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.isirreducible-Tuple{gfp_fmpz_poly}" href="#Nemo.isirreducible-Tuple{gfp_fmpz_poly}"><code>Nemo.isirreducible</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isirreducible(x::gfp_fmpz_poly)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is irreducible, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.isirreducible-Tuple{fq_poly}" href="#Nemo.isirreducible-Tuple{fq_poly}"><code>Nemo.isirreducible</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isirreducible(x::fq_poly)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is irreducible, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.isirreducible-Tuple{fq_nmod_poly}" href="#Nemo.isirreducible-Tuple{fq_nmod_poly}"><code>Nemo.isirreducible</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isirreducible(x::fq_nmod_poly)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is irreducible, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.issquarefree-Tuple{nmod_poly}" href="#Nemo.issquarefree-Tuple{nmod_poly}"><code>Nemo.issquarefree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">issquarefree(x::nmod_poly)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is squarefree, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.issquarefree-Tuple{gfp_poly}" href="#Nemo.issquarefree-Tuple{gfp_poly}"><code>Nemo.issquarefree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">issquarefree(x::gfp_poly)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is squarefree, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.issquarefree-Tuple{fmpz_mod_poly}" href="#Nemo.issquarefree-Tuple{fmpz_mod_poly}"><code>Nemo.issquarefree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">issquarefree(x::fmpz_mod_poly)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is squarefree, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.issquarefree-Tuple{gfp_fmpz_poly}" href="#Nemo.issquarefree-Tuple{gfp_fmpz_poly}"><code>Nemo.issquarefree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">issquarefree(x::gfp_fmpz_poly)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is squarefree, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.issquarefree-Tuple{fq_poly}" href="#Nemo.issquarefree-Tuple{fq_poly}"><code>Nemo.issquarefree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">issquarefree(x::fq_poly)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is squarefree, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.issquarefree-Tuple{fq_nmod_poly}" href="#Nemo.issquarefree-Tuple{fq_nmod_poly}"><code>Nemo.issquarefree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">issquarefree(x::fq_nmod_poly)</code></pre><blockquote><p>Return <code>true</code> if <span>$x$</span> is squarefree, otherwise return <code>false</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor-Tuple{fmpz_poly}" href="#Nemo.factor-Tuple{fmpz_poly}"><code>Nemo.factor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor(x::fmpz_poly)</code></pre><blockquote><p>Returns the factorization of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor-Tuple{nmod_poly}" href="#Nemo.factor-Tuple{nmod_poly}"><code>Nemo.factor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor(x::nmod_poly)</code></pre><blockquote><p>Return the factorisation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor-Tuple{gfp_poly}" href="#Nemo.factor-Tuple{gfp_poly}"><code>Nemo.factor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor(x::gfp_poly)</code></pre><blockquote><p>Return the factorisation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor-Tuple{fmpz_mod_poly}" href="#Nemo.factor-Tuple{fmpz_mod_poly}"><code>Nemo.factor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor(x::fmpz_mod_poly)</code></pre><blockquote><p>Return the factorisation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor-Tuple{gfp_fmpz_poly}" href="#Nemo.factor-Tuple{gfp_fmpz_poly}"><code>Nemo.factor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor(x::gfp_fmpz_poly)</code></pre><blockquote><p>Return the factorisation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor-Tuple{fq_poly}" href="#Nemo.factor-Tuple{fq_poly}"><code>Nemo.factor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor(x::fq_poly)</code></pre><blockquote><p>Return the factorisation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor-Tuple{fq_nmod_poly}" href="#Nemo.factor-Tuple{fq_nmod_poly}"><code>Nemo.factor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor(x::fq_nmod_poly)</code></pre><blockquote><p>Return the factorisation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor_squarefree-Tuple{nmod_poly}" href="#Nemo.factor_squarefree-Tuple{nmod_poly}"><code>Nemo.factor_squarefree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_squarefree(x::nmod_poly)</code></pre><blockquote><p>Return the squarefree factorisation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor_squarefree-Tuple{gfp_poly}" href="#Nemo.factor_squarefree-Tuple{gfp_poly}"><code>Nemo.factor_squarefree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_squarefree(x::gfp_poly)</code></pre><blockquote><p>Return the squarefree factorisation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor_squarefree-Tuple{fmpz_mod_poly}" href="#Nemo.factor_squarefree-Tuple{fmpz_mod_poly}"><code>Nemo.factor_squarefree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_squarefree(x::fmpz_mod_poly)</code></pre><blockquote><p>Return the squarefree factorisation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor_squarefree-Tuple{gfp_fmpz_poly}" href="#Nemo.factor_squarefree-Tuple{gfp_fmpz_poly}"><code>Nemo.factor_squarefree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_squarefree(x::gfp_fmpz_poly)</code></pre><blockquote><p>Return the squarefree factorisation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor_squarefree-Tuple{fq_poly}" href="#Nemo.factor_squarefree-Tuple{fq_poly}"><code>Nemo.factor_squarefree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_squarefree(x::fq_poly)</code></pre><blockquote><p>Return the squarefree factorisation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor_squarefree-Tuple{fq_nmod_poly}" href="#Nemo.factor_squarefree-Tuple{fq_nmod_poly}"><code>Nemo.factor_squarefree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_squarefree(x::fq_nmod_poly)</code></pre><blockquote><p>Return the squarefree factorisation of <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor_distinct_deg-Tuple{nmod_poly}" href="#Nemo.factor_distinct_deg-Tuple{nmod_poly}"><code>Nemo.factor_distinct_deg</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_distinct_deg(x::nmod_poly)</code></pre><blockquote><p>Return the distinct degree factorisation of a squarefree polynomial <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor_distinct_deg-Tuple{gfp_poly}" href="#Nemo.factor_distinct_deg-Tuple{gfp_poly}"><code>Nemo.factor_distinct_deg</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_distinct_deg(x::gfp_poly)</code></pre><blockquote><p>Return the distinct degree factorisation of a squarefree polynomial <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor_distinct_deg-Tuple{fmpz_mod_poly}" href="#Nemo.factor_distinct_deg-Tuple{fmpz_mod_poly}"><code>Nemo.factor_distinct_deg</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_distinct_deg(x::fmpz_mod_poly)</code></pre><blockquote><p>Return the distinct degree factorisation of a squarefree polynomial <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor_distinct_deg-Tuple{gfp_fmpz_poly}" href="#Nemo.factor_distinct_deg-Tuple{gfp_fmpz_poly}"><code>Nemo.factor_distinct_deg</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_distinct_deg(x::fmpz_mod_poly)</code></pre><blockquote><p>Return the distinct degree factorisation of a squarefree polynomial <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor_distinct_deg-Tuple{fq_poly}" href="#Nemo.factor_distinct_deg-Tuple{fq_poly}"><code>Nemo.factor_distinct_deg</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_distinct_deg(x::fq_poly)</code></pre><blockquote><p>Return the distinct degree factorisation of a squarefree polynomial <span>$x$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.factor_distinct_deg-Tuple{fq_nmod_poly}" href="#Nemo.factor_distinct_deg-Tuple{fq_nmod_poly}"><code>Nemo.factor_distinct_deg</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_distinct_deg(x::fq_nmod_poly)</code></pre><blockquote><p>Return the distinct degree factorisation of a squarefree polynomial <span>$x$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-none">R = ResidueRing(ZZ, 23)
S, x = PolynomialRing(R, &quot;x&quot;)

f = x^2 + 2x + 1
g = x^3 + 3x + 1

R = factor(f*g)
S = factor_squarefree(f*g)
T = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))</code></pre><h3><a class="nav-anchor" id="Special-functions-1" href="#Special-functions-1">Special functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.cyclotomic-Tuple{Int64,fmpz_poly}" href="#Nemo.cyclotomic-Tuple{Int64,fmpz_poly}"><code>Nemo.cyclotomic</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">cyclotomic(n::Int, x::fmpz_poly)</code></pre><blockquote><p>Return the <span>$n$</span>th cyclotomic polynomial, defined as <span>$\Phi_n(x) = \prod_{\omega} (x-\omega),$</span> where <span>$\omega$</span> runs over all the  <span>$n$</span>th primitive roots of unity.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.swinnerton_dyer-Tuple{Int64,fmpz_poly}" href="#Nemo.swinnerton_dyer-Tuple{Int64,fmpz_poly}"><code>Nemo.swinnerton_dyer</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">swinnerton_dyer(n::Int, x::fmpz_poly)</code></pre><blockquote><p>Return the Swinnerton-Dyer polynomial <span>$S_n$</span>, defined as the integer  polynomial <span>$S_n = \prod (x \pm \sqrt{2} \pm \sqrt{3} \pm \sqrt{5} \pm \ldots \pm \sqrt{p_n})$</span>  where <span>$p_n$</span> denotes the <span>$n$</span>-th prime number and all combinations of signs are taken. This polynomial has degree <span>$2^n$</span> and is irreducible over the integers (it is the minimal polynomial of <span>$\sqrt{2} + \ldots + \sqrt{p_n}$</span>).</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.cos_minpoly-Tuple{Int64,fmpz_poly}" href="#Nemo.cos_minpoly-Tuple{Int64,fmpz_poly}"><code>Nemo.cos_minpoly</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">cos_minpoly(n::Int, x::fmpz_poly)</code></pre><blockquote><p>Return the minimal polynomial of <span>$2 \cos(2 \pi / n)$</span>. For suitable choice of  <span>$n$</span>, this gives the minimal polynomial of <span>$2 \cos(a \pi)$</span> or <span>$2 \sin(a \pi)$</span> for any rational <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.theta_qexp-Tuple{Int64,Int64,fmpz_poly}" href="#Nemo.theta_qexp-Tuple{Int64,Int64,fmpz_poly}"><code>Nemo.theta_qexp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">theta_qexp(e::Int, n::Int, x::fmpz_poly)</code></pre><blockquote><p>Return the <span>$q$</span>-expansion to length <span>$n$</span> of the Jacobi theta function raised to the power <span>$r$</span>, i.e. <span>$\vartheta(q)^r$</span> where  <span>$\vartheta(q) = 1 + \sum_{k=1}^{\infty} q^{k^2}$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.eta_qexp-Tuple{Int64,Int64,fmpz_poly}" href="#Nemo.eta_qexp-Tuple{Int64,Int64,fmpz_poly}"><code>Nemo.eta_qexp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">eta_qexp(e::Int, n::Int, x::fmpz_poly)</code></pre><blockquote><p>Return the <span>$q$</span>-expansion to length <span>$n$</span> of the Dedekind eta function (without  the leading factor <span>$q^{1/24}$</span>) raised to the power <span>$r$</span>, i.e. <span>$(q^{-1/24} \eta(q))^r = \prod_{k=1}^{\infty} (1 - q^k)^r$</span>. In particular, <span>$r = -1$</span> gives the generating function of the partition function <span>$p(k)$</span>, and <span>$r = 24$</span> gives, after multiplication by <span>$q$</span>, the modular discriminant <span>$\Delta(q)$</span> which generates the Ramanujan tau function <span>$\tau(k)$</span>.</p></blockquote></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

h = cyclotomic(120, x)
j = swinnerton_dyer(5, x)
k = cos_minpoly(30, x)
l = theta_qexp(3, 30, x)
m = eta_qexp(24, 30, x)
o = cyclotomic(10, 1 + x + x^2)</code></pre><footer><hr/><a class="previous" href="../integer/"><span class="direction">Previous</span><span class="title">Integers</span></a><a class="next" href="../series/"><span class="direction">Next</span><span class="title">Power series and Laurent series</span></a></footer></article></body></html>
