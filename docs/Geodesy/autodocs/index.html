<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Geodesy.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Geodesy.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.Datum" href="#Geodesy.Datum"><code>Geodesy.Datum</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for geodetic datums</p><p>A datum is a set of reference objects and assigned coordinates, relative to which other objects may be positioned.  We model these in code with subtypes of <code>Datum</code>.  Each geodetic datum has an associated ellipsoid model of the Earth which is required when transforming between coordinate systems.  The ellipsoid can be accessed with the <code>ellipsoid()</code> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.ECEF" href="#Geodesy.ECEF"><code>Geodesy.ECEF</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ECEF(x, y, z)</code></pre><p>Earth-Centered-Earth-Fixed (ECEF) coordinates. A global Cartesian coordinate system rotating with the Earth.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.ECEFfromENU" href="#Geodesy.ECEFfromENU"><code>Geodesy.ECEFfromENU</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ECEFfromENU(origin, datum)
ECEFfromENU(origin::UTM, zone, isnorth, datum)
ECEFfromENU(origin::ECEF, lat, lon)</code></pre><p>Construct a <code>Transformation</code> object to convert from local <code>ENU</code> coordinates centred at <code>origin</code> to global <code>ECEF</code> coodinates. This object pre-caches both the ECEF coordinates and latitude and longitude of the origin for maximal efficiency.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.ECEFfromLLA" href="#Geodesy.ECEFfromLLA"><code>Geodesy.ECEFfromLLA</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ECEFfromLLA(ellipsoid_or_datum)</code></pre><p>Construct a <code>Transformation</code> object to convert from LLA coordinates to ECEF coordinates.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.ENU" href="#Geodesy.ENU"><code>Geodesy.ENU</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ENU(e, n, u = 0.0)</code></pre><p>East-North-Up (ENU) coordinates. A local Cartesian coordinate system, linearized about a reference point.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.ENUfromECEF" href="#Geodesy.ENUfromECEF"><code>Geodesy.ENUfromECEF</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ENUfromECEF(origin, datum)
ENUfromECEF(origin::UTM, zone, isnorth, datum)
ENUfromECEF(origin::ECEF, lat, lon)</code></pre><p>Construct a <code>Transformation</code> object to convert from global <code>ECEF</code> coordinates to local <code>ENU</code> coordinates centered at the <code>origin</code>. This object pre-caches both the ECEF coordinates and latitude and longitude of the origin for maximal efficiency.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.Ellipsoid" href="#Geodesy.Ellipsoid"><code>Geodesy.Ellipsoid</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An ellipsoidal representation of the Earth, for converting between LLA and other co-ordinate systems such as ECEF.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.GDA94" href="#Geodesy.GDA94"><code>Geodesy.GDA94</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>GDA94</code> - Geocentric Datum of Australia, 1994</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.ITRF" href="#Geodesy.ITRF"><code>Geodesy.ITRF</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ITRF{Year}([epoch])</code></pre><p>Construct an object representing the International Terrestrial Reference Frame for the given <code>Year</code> of realization.  ITRF is the standard high accuracy terrestrial reference frame for worldwide use.  An optional <code>epoch</code> parameter defines the time of interest - typically a date at which coordinates were measured, using, eg a GPS device.  Without the <code>epoch</code> parameter, the resulting <code>ITRF{Year}</code> object represents the full dynamic datum.</p><p>A <em>realization</em> is created every few years by computing the position of a large set of ground control stations from satellite and celestial measurements.  The <code>Year</code> parameter represents the last year from which data was used in the frame processing regression problem.  A list of recent realizations is available at http://itrf.ensg.ign.fr/ITRF_solutions; as of 2016-07 valid <code>Year</code>s were 2014 2008 2005 2000 1997 1996 1994 1993 1992 1991 1990 1989 1988.</p><p>See http://itrf.ensg.ign.fr/general.php for a technical overview.  Useful technical papers:</p><ul><li>&quot;IERS Conventions (2010)&quot;, Petit and Luzum (eds.), IERS Technical note No.36,  Chapter 4, https://www.iers.org/IERS/EN/Publications/TechnicalNotes/tn36.html</li><li>&quot;ITRF2008: an improved solution of the international terrestrial reference  frame&quot;, Altamimi et al., J. Geodesy (2011) 85: 457,  http://dx.doi.org/10.1007/s00190-011-0444-4</li><li>&quot;IGS08: the IGS realization of ITRF2008&quot;, Rebischung et al., GPS Solutions  (2012) 16: 483, http://dx.doi.org/10.1007/s10291-011-0248-2,  ftp://igs.org/pub/resource/pubs/IGS08<em>The</em>IGS<em>Realization</em>of_ITRF2008.pdf</li><li>&quot;The IGS contribution to ITRF2014&quot;, Rebischung et al., J. Geodesy (2016) 90:  611, http://dx.doi.org/10.1007/s00190-016-0897-6</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.LLA" href="#Geodesy.LLA"><code>Geodesy.LLA</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LLA(lat, lon, alt = 0.0)
LLA(lat = ϕ, lon = Θ, alt = h)</code></pre><p>Latitude, longitude, and alititude co-ordinates. <em>Note:</em> assumes degrees not radians</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.LLAfromECEF-Tuple{Ellipsoid}" href="#Geodesy.LLAfromECEF-Tuple{Ellipsoid}"><code>Geodesy.LLAfromECEF</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">LLAfromECEF(ellipsoid)</code></pre><p>Construct a <code>Transformation</code> object to convert from ECEF coordinates to LLA coordinates. Pre-caches ellipsoidal parameters for efficiency.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.LLAfromUTM" href="#Geodesy.LLAfromUTM"><code>Geodesy.LLAfromUTM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LLAfromUTM(zone, isnorth::Bool, datum)</code></pre><p>Construct a <code>Transformation</code> object to convert from <code>UTM</code> coordinates in the specified zone and hemisphere (<code>isnorth = true</code> or <code>false</code>) to global <code>LLA</code> coordinates. Pre-caches ellipsoidal parameters for efficiency and performs Charles Karney&#39;s accurate 6th-order series expansion algorithm.</p><p>(See also <code>LLAfromUTMZ</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.LLAfromUTMZ" href="#Geodesy.LLAfromUTMZ"><code>Geodesy.LLAfromUTMZ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LLAfromUTMZ(datum)</code></pre><p>Construct a <code>Transformation</code> object to convert from global <code>UTMZ</code> coordinates to global <code>LLA</code> coordinates. Pre-caches ellipsoidal parameters for efficiency and performs Charles Karney&#39;s accurate 6th-order series expansion algorithm.</p><p>(See also <code>LLAfromUTM</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.LatLon" href="#Geodesy.LatLon"><code>Geodesy.LatLon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LatLon(lat, lon)
LatLon(lat = ϕ, lon = Θ)</code></pre><p>Latitude and longitude co-ordinates. <em>Note:</em> assumes degrees not radians</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.NAD27" href="#Geodesy.NAD27"><code>Geodesy.NAD27</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>NAD27</code> - North American Datum of 1927</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.NAD83" href="#Geodesy.NAD83"><code>Geodesy.NAD83</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>NAD83</code> - North American Datum of 1983</p><p>For technical details, see &quot;NAD83 (NSRS2007) National Readjustment Final Report&quot; http://www.ngs.noaa.gov/PUBS_LIB/NSRS2007/NOAATRNOSNGS60.pdf</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.OSGB36" href="#Geodesy.OSGB36"><code>Geodesy.OSGB36</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>OSGB36</code> - Datum for Ordinance Survey of Great Britain, 1936</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.UTM" href="#Geodesy.UTM"><code>Geodesy.UTM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UTM(x, y, z = 0.0)</code></pre><p>Universal transverse Mercator (UTM) coordinates. Common projection type for world points. Zone not included in coordinates - it is a parameterized in the relavant transformations <code>UTMfromLLA</code> and <code>LLAfromUTM</code> (see also the <code>UTMZ</code> type).</p><p>This type may be used to parameterize UPS coordinates (Universal Polar Stereographic) to accurately represent the polar regions, in zone &quot;0&quot;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.UTMZ" href="#Geodesy.UTMZ"><code>Geodesy.UTMZ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UTMZ(x, y, z = 0.0, zone::Integer, hemisphere::Bool)</code></pre><p>Universal transverse Mercator (UTM) coordinates with zone number. Common projection type for world points. The UTM zone is included in coordinates (see also the <code>UTM</code> type).</p><p>This type may be used to parameterize UPS coordinates (Universal Polar Stereographic) to accurately represent the polar regions, in zone &quot;0&quot;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.UTMZfromLLA" href="#Geodesy.UTMZfromLLA"><code>Geodesy.UTMZfromLLA</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UTMZfromLLA(datum)</code></pre><p>Construct a <code>Transformation</code> object to convert from global <code>LLA</code> coordinates to global <code>UTMZ</code> coordinates. The zone and hemisphere is automatically calculated following the standard definitions (including exceptions in Norway). Pre-caches ellipsoidal parameters for efficiency and performs Charles Karney&#39;s accurate 6th-order series expansion algorithm.</p><p>(See also <code>UTMfromLLA</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.UTMZfromUTM" href="#Geodesy.UTMZfromUTM"><code>Geodesy.UTMZfromUTM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UTMZfromUTM(zone, isnorth, datum)</code></pre><p>Transformation to append the UTM/UPS zone and hemisphere to a raw <code>UTM</code> data point.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.UTMfromLLA" href="#Geodesy.UTMfromLLA"><code>Geodesy.UTMfromLLA</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UTMfromLLA(zone, isnorth::Bool, datum)</code></pre><p>Construct a <code>Transformation</code> object to convert from global <code>LLA</code> coordinates to <code>UTM</code> coordinates in the specified zone and hemisphere (<code>isnorth = true</code> or <code>false</code>). Pre-caches ellipsoidal parameters for efficiency and performs Charles Karney&#39;s accurate 6th-order series expansion algorithm.</p><p>(See also <code>UTMZfromLLA</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.UTMfromUTMZ" href="#Geodesy.UTMfromUTMZ"><code>Geodesy.UTMfromUTMZ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UTMfromUTMZ(zone, isnorth, datum)</code></pre><p>Transformation to remove the zone and hemisphere from <code>UTMZ</code> data point, and automatically convert the data to the specified zone if necessary.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.WGS84" href="#Geodesy.WGS84"><code>Geodesy.WGS84</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">WGS84()</code></pre><p>Construct an object representing the World Geodetic System of 1984, as a dynamic datum - see below for gory details about specific WGS84 frames).</p><p>If you&#39;re getting positions from a consumer GPS device, you&#39;re probably going to have WGS84 by default because it&#39;s the datum in which GPS satellites broadcast their position (&quot;broadcast ephemerides&quot;).  Note however that many devices can also provide position in a national datum, so you should check your device settings to be sure.</p><p>As a special case for low accuracy work (worse than a meter or so), <code>WGS84</code> will assume that coordinates supplied without a capture time are in the <em>latest</em> frame realization known to Geodesy.jl, WGS84 (G1762). Note that this may not be correct if you&#39;re processing historical data, or Geodesy.jl itself is out of date.  For higher accuracy, you should supply a date of capture - either with each coordinate, or explicitly using the <code>GpsWeek</code> parameter to the WGS84 type:</p><pre><code class="language-none">WGS84{GpsWeek}()</code></pre><p>Construct an object representing the static WGS84 datum computed using data gathered prior to the given <code>GpsWeek</code>.  WGS84 is maintained and updated by the US National Geospatial-Intelligence-Agency (NGA) at irregular intervals to align with the ITRF to within 0.1m (see [1]); if you care about accuracy at that level, you probably want to be solving for position in a different datum, for example, ITRF.  As of 2016, <code>GpsWeek</code> should be one out of [0, 730, 873, 1150, 1674, 1762].</p><p>Note that the dates of implementation of these frames as broadcast by the satellites are not the same as the associated GPS week - see Ref. [1], table 2.1.  (TODO: Perhaps Geodesy should have a table to figure out which frame to use at a given date?  Does anybody care?)</p><ol><li>&quot;World Geodetic System 1984&quot;, NGA standard NGA.STND.0036<em>1.0.0</em>WGS84, 2014-07-08, http://earth-info.nga.mil/GandG/publications/NGA<em>STND</em>0036<em>1</em>0<em>0</em>WGS84/NGA.STND.0036<em>1.0.0</em>WGS84.pdf</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.ECEFfromUTM-Tuple{Any,Any,Any}" href="#Geodesy.ECEFfromUTM-Tuple{Any,Any,Any}"><code>Geodesy.ECEFfromUTM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ECEFfromUTM(zone, isnorth, datum)</code></pre><p>Creates composite transformation <code>ECEFfromLLA(datum) ∘ LLAfromUTM(zone, isnorth, datum)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.ECEFfromUTMZ-Tuple{Any}" href="#Geodesy.ECEFfromUTMZ-Tuple{Any}"><code>Geodesy.ECEFfromUTMZ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ECEFfromUTMZ(datum)</code></pre><p>Creates composite transformation <code>ECEFfromLLA(datum) ∘ LLAfromUTMZ(datum)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.ENUfromLLA-Tuple{Any,Any}" href="#Geodesy.ENUfromLLA-Tuple{Any,Any}"><code>Geodesy.ENUfromLLA</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ENUfromLLA(origin, datum)</code></pre><p>Creates composite transformation <code>ENUfromECEF(origin, datum) ∘ ECEFfromLLA(datum)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.ENUfromUTM-Tuple{Any,Integer,Bool,Any}" href="#Geodesy.ENUfromUTM-Tuple{Any,Integer,Bool,Any}"><code>Geodesy.ENUfromUTM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ENUfromUTM(origin, zone, isnorth, datum)</code></pre><p>Creates composite transformation <code>UTMfromLLA(zone, isnorth, datum) ∘ LLAfromENU(origin, datum)</code>. If <code>origin</code> is a <code>UTM</code> point, then it is assumed it is in the given specified zone and hemisphere.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.ENUfromUTMZ-Tuple{Any,Any}" href="#Geodesy.ENUfromUTMZ-Tuple{Any,Any}"><code>Geodesy.ENUfromUTMZ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ENUfromUTMZ(origin, datum)</code></pre><p>Creates composite transformation <code>ENUfromLLA(origin, datum) ∘ LLAfromUTMZ(datum)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.LLAfromENU-Tuple{Any,Any}" href="#Geodesy.LLAfromENU-Tuple{Any,Any}"><code>Geodesy.LLAfromENU</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">LLAfromENU(origin, datum)</code></pre><p>Creates composite transformation <code>LLAfromECEF(datum) ∘ ECEFfromENU(origin, datum)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.UTMZfromECEF-Tuple{Any}" href="#Geodesy.UTMZfromECEF-Tuple{Any}"><code>Geodesy.UTMZfromECEF</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">UTMZfromECEF(datum)</code></pre><p>Creates composite transformation <code>UTMZfromLLA(datum) ∘ LLAfromECEF(datum)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.UTMZfromENU-Tuple{Any,Any}" href="#Geodesy.UTMZfromENU-Tuple{Any,Any}"><code>Geodesy.UTMZfromENU</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">UTMZfromENU(origin, datum)</code></pre><p>Creates composite transformation <code>UTMZfromLLA(datum) ∘ LLAfromENU(origin, datum)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.UTMfromECEF-Tuple{Any,Any,Any}" href="#Geodesy.UTMfromECEF-Tuple{Any,Any,Any}"><code>Geodesy.UTMfromECEF</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">UTMfromECEF(zone, isnorth, datum)</code></pre><p>Creates composite transformation <code>UTMfromLLA(zone, isnorth, datum) ∘ LLAfromECEF(datum)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.UTMfromENU-Tuple{Any,Integer,Bool,Any}" href="#Geodesy.UTMfromENU-Tuple{Any,Integer,Bool,Any}"><code>Geodesy.UTMfromENU</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">UTMfromENU(origin, zone, isnorth, datum)</code></pre><p>Creates composite transformation <code>UTMfromLLA(zone, isnorth, datum) ∘ LLAfromENU(origin, datum)</code>. If <code>origin</code> is a <code>UTM</code> point, then it is assumed it is in the given specified zone and hemisphere.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.datum_shift_ECEF-Tuple{Any,Any}" href="#Geodesy.datum_shift_ECEF-Tuple{Any,Any}"><code>Geodesy.datum_shift_ECEF</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">datum_shift_ECEF(dest_datum, source_datum)</code></pre><p>Return a transformation object which transforms ECEF points from <code>source_datum</code> to <code>dest_datum</code>.  The function should attempt to supply the current publicly accepted best estimate.</p><p>Note that the best known version of a datum transformation will inherently improve with time (see below), so we <em>cannot simultaneously</em> guarantee that:</p><ol><li>We return the best publicly accepted version of a datum shift.</li><li>We return the same thing in future versions of Geodesy.jl.</li></ol><p>This function will attempt to satisfy condition 1. rather than 2.; if you want a stable version of a transformation you should use one of the lower level functions, for example, <code>GDA94_from_ITRF_Dawson2010()</code>.</p><p><strong>Important note about accuracy</strong></p><p>If you care about accuracy, you should <em>always</em> store long term archival data in the source datum where possible, along with metadata defining the full datum and coordinate system in use.  The time to do a datum shift is when you want to compare information from two different datums.</p><p>Why all this bother about inaccuracy? The errors are twofold: First, the parameters of a datum shift come from a physical measurement process. Typically this involves measuring the coordinates of some physical locations in <em>both</em> datums, and a physical measurement procedure is always subject to some inaccuracy. Second, these <strong>tie points</strong> are used to infer a compact representation of the datum shift, with as few numerical parameters as possible. A small number of parameters will result in an overly smooth representation; this modelling error is a second source of inaccuracy.  Both these errors can be reduced if you choose to measure more tie points or improve the complexity of the numerical model at a future date.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.distance" href="#Geodesy.distance"><code>Geodesy.distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">distance(utm1, utm2, zone, isnorth, [datum = wgs84])
distance(a, utm2, zone, isnorth, [datum = wgs84])
distance(utm1, b, zone, isnorth, [datum = wgs84])</code></pre><p>If one or both points are UTM, we need the zone (and particularly the hemisphere, isnorth = true/false) to determine the Cartesian distance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.distance-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{T,1} where T)" href="#Geodesy.distance-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{T,1} where T)"><code>Geodesy.distance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">distance(a, b, [datum = wgs84])</code></pre><p>The Cartesian distance between points <code>a</code> and <code>b</code>. Uses <code>datum</code> to perform transformations as necessary, and unlike other <em>Geodesy</em> functions, this defaults to use the common WGS-84 datum for convenience.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.utm_zone-Union{Tuple{T}, Tuple{T,T}} where T" href="#Geodesy.utm_zone-Union{Tuple{T}, Tuple{T,T}} where T"><code>Geodesy.utm_zone</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(zone, isnorth) = utm_zone(lat, lon)
(zone, isnorth) = utm_zone(ll::LatLon)
(zone, isnorth) = utm_zone(lla::LLA)
(zone, isnorth) = utm_zone(ecef::ECEF, datum)</code></pre><p>Find the UTM zone and hemisphere (<code>isnorth = true</code> or <code>false</code>) for the given latitude and longitude (or world point), including the special rules for Norway and Svalbard. Zone 0 corresponds to the poles, using the UPS regions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.TransverseMercator" href="#Geodesy.TransverseMercator"><code>Geodesy.TransverseMercator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">immutable TransverseMercator{MaxPow}
TransverseMercator(datum)
TransverseMercator(ellipsoid)
TransverseMercator(a, f, [::Type{Val{MaxPow}} = Val{6}])</code></pre><p>Cache of ellipsoidal calculations necessary for transverse-Mercator and polar-stereographic transformations. Series expansion coefficients up to order <code>MaxPow</code> (between 4 and 8, default 6) are calculated and stored for fast transverse-Mercator and UTM calculations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.AngNormalize-Tuple{Number}" href="#Geodesy.AngNormalize-Tuple{Number}"><code>Geodesy.AngNormalize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>%AngNormalize:  Reduce angle to range [-180, 180) % %   x = AngNormalize(x) reduces angles to the range [-180, 180).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.GDA94_from_ITRF_Dawson2010-Tuple{Any,Any}" href="#Geodesy.GDA94_from_ITRF_Dawson2010-Tuple{Any,Any}"><code>Geodesy.GDA94_from_ITRF_Dawson2010</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">GDA94_from_ITRF_Dawson2010(ITRF_year, epoch)</code></pre><p>Return a <code>Transformation</code> converting ECEF points from a given ITRF to GDA94. Datum shift parameters are taken from [1], supporting <code>ITRF_year</code> 2008, 2005, 2000, 1997, 1996.  <code>epoch</code> is the <code>Date</code> (or <code>DateTime</code>) of interest at which the input <code>ECEF</code> coordinates to the transformation were measured in ITRF.</p><p>[1] J. Dawson and A. Woods, &quot;ITRF to GDA94 coordinate transforms&quot;,     Journal of Applied Geodesy, 4, p. 189 (2010).</p><p>TODO: We don&#39;t yet support <code>epoch</code> varying per input point, but there should be a <code>Transformation</code> object for this at some stage.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.LatFix-Tuple{Number}" href="#Geodesy.LatFix-Tuple{Number}"><code>Geodesy.LatFix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>LatFix(x) returns x is it is in the range [-90, 90]; otherwise it returns NaN.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.eatanhe-Tuple{Any,Any}" href="#Geodesy.eatanhe-Tuple{Any,Any}"><code>Geodesy.eatanhe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>eatanhe(x, e2) returns e<em>atanh(e</em>x) where e = sqrt(e2) e2 is a scalar; x can be any shape.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.polarst_fwd-Tuple{Bool,Float64,Geodesy.TransverseMercator,Any,Any}" href="#Geodesy.polarst_fwd-Tuple{Bool,Float64,Geodesy.TransverseMercator,Any,Any}"><code>Geodesy.polarst_fwd</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(x, y, gamma, k) = polarst_fwd(northpole::Bool, k0::Float64, tm::TransverseMercator, lat, lon)</code></pre><p>Perform polar-stereographic projection of <code>lat</code> and <code>lon</code> with respect to north or south pole <code>northpole</code> and horizontal scaling <code>k0</code> (<code>= 0.994</code> for UPS). <code>γ</code> and <code>k</code> are the local convergence and scaling factors, respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.polarst_inv-Tuple{Bool,Float64,Geodesy.TransverseMercator,Any,Any}" href="#Geodesy.polarst_inv-Tuple{Bool,Float64,Geodesy.TransverseMercator,Any,Any}"><code>Geodesy.polarst_inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(lat, lon, gamma, k) = polarst_inv(northp::Bool, k0::Float64, tm::TransverseMercator, x, y)</code></pre><p>Invert polar-stereographic projection of <code>x</code> and <code>y</code> with respect to north or south pole <code>northpole</code> and horizontal scaling <code>k0</code> (<code>= 0.994</code> for UPS). <code>γ</code> and <code>k</code> are the local convergence and scaling factors, respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.polyval-Tuple{Any,Any}" href="#Geodesy.polyval-Tuple{Any,Any}"><code>Geodesy.polyval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Evaluate polynomial with coefficients p[i] at x</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.tauf-Tuple{Any,Any}" href="#Geodesy.tauf-Tuple{Any,Any}"><code>Geodesy.tauf</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>%TAUF   tan(phi) % %   TAUF(taup, e2) returns tangent of phi in terms of taup the tangent of %   chi.  e2, the square of the eccentricity, is a scalar; taup can be any %   shape.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.taupf-Tuple{Any,Any}" href="#Geodesy.taupf-Tuple{Any,Any}"><code>Geodesy.taupf</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>taupf(tau, e2) returns tangent of chi in terms of tau the tangent of phi.  e2, the square of the eccentricity, is a scalar; tau can be any shape.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.transverse_mercator_forward-Union{Tuple{MaxPow}, Tuple{Any,Any,Any,Any,TransverseMercator{MaxPow}}} where MaxPow" href="#Geodesy.transverse_mercator_forward-Union{Tuple{MaxPow}, Tuple{Any,Any,Any,Any,TransverseMercator{MaxPow}}} where MaxPow"><code>Geodesy.transverse_mercator_forward</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(x, y, γ, k) = transverse_mercator_forward(lon0, lat, lon, k0, tm::TransverseMercator)</code></pre><p>Perform transverse-Mercator projection of <code>lat</code> and <code>lon</code> with respect to reference meridian <code>lat0</code> and horizontal scaling <code>k0</code> (<code>= 0.9996</code> for UTM) using a series expansion approach (see <code>TransverseMercator</code>). <code>γ</code> and <code>k</code> are the local convergence and scaling factors, respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.transverse_mercator_reverse-Union{Tuple{MaxPow}, Tuple{Any,Any,Any,Any,TransverseMercator{MaxPow}}} where MaxPow" href="#Geodesy.transverse_mercator_reverse-Union{Tuple{MaxPow}, Tuple{Any,Any,Any,Any,TransverseMercator{MaxPow}}} where MaxPow"><code>Geodesy.transverse_mercator_reverse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(lat, lon, γ, k) = transverse_mercator_reverse(lon0, x, y, k0, tm::TransverseMercator)</code></pre><p>Invert transverse-Mercator projection of <code>x</code> and <code>y</code> with respect to reference meridian <code>lat0</code> and horizontal scaling <code>k0</code> (<code>= 0.9996</code> for UTM) using a series expansion approach (see <code>TransverseMercator</code>). <code>γ</code> and <code>k</code> are the local convergence and scaling factors, respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Geodesy.utm_meridian-Tuple{Integer}" href="#Geodesy.utm_meridian-Tuple{Integer}"><code>Geodesy.utm_meridian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">utm_meridian(zone)</code></pre><p>Central meridian of the given UTM <code>zone</code> (note - does not include the conventiional 500km false easting offset).</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
