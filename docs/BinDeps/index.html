<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · BinDeps.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BinDeps.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#FAQ-1">FAQ</a></li><li class="toplevel"><a class="toctext" href="#The-high-level-interface-Declaring-dependencies-1">The high level interface - Declaring dependencies</a></li><li class="toplevel"><a class="toctext" href="#The-high-level-interface-Declaring-build-mechanisms-1">The high level interface - Declaring build mechanisms</a></li><li class="toplevel"><a class="toctext" href="#The-high-level-interface-built-in-providers-1">The high level interface - built in providers</a></li><li class="toplevel"><a class="toctext" href="#The-high-level-interface-Loading-dependencies-1">The high level interface - Loading dependencies</a></li><li class="toplevel"><a class="toctext" href="#The-low-level-interface-1">The low level interface</a></li><li class="toplevel"><a class="toctext" href="#Diagnostics-1">Diagnostics</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="BinDeps.jl-1" href="#BinDeps.jl-1">BinDeps.jl</a></h1><p><a href="http://pkg.julialang.org/detail/BinDeps"><img src="http://pkg.julialang.org/badges/BinDeps_0.6.svg" alt="BinDeps"/></a> <a href="https://travis-ci.org/JuliaPackaging/BinDeps.jl"><img src="https://travis-ci.org/JuliaPackaging/BinDeps.jl.svg?branch=master" alt="Travis"/></a> <a href="https://ci.appveyor.com/project/nalimilan/bindeps-jl/branch/master"><img src="https://ci.appveyor.com/api/projects/status/github/julialang/bindeps.jl?branch=master&amp;svg=true" alt="AppVeyor"/></a></p><p>Easily build binary dependencies for Julia packages</p><h1><a class="nav-anchor" id="FAQ-1" href="#FAQ-1">FAQ</a></h1><p>Since there seems to be a lot of confusion surrounding the package systems and the role of this package, before we get started looking at the actual package, I want to answer a few common questions:</p><ul><li><p>What is <code>BinDeps</code>?</p><p><code>BinDeps</code> is a package that provides a collection of tools to build binary dependencies for Julia packages.</p></li><li><p>Do I need to use this package if I want to build binary dependencies for my Julia package?</p><p>Absolutely not! The system is designed to give the maximum amount of freedom to the package author in order to be able to address any situation that one may encounter in the real world. This is achieved by simply evaluating a file called <code>deps/build.jl</code> (if it exists) in a package whenever it is installed or updated. Thus the following might perhaps be the simplest possible useful <code>build.jl</code> script one can imagine:</p></li></ul><pre><code class="language-julia">run(`make`)</code></pre><ul><li><p>I want to use BinDeps, but it is missing some functionality I need (e.g. a package manager)</p><p>Since BinDeps is written in Julia it is extensible with the same ease as the rest of Julia. In particular, defining new behavior, e.g. for adding a new package manager, consists of little more than adding a type and implementing a couple of methods (see the section on Interfaces) or the <a href="https://github.com/JuliaLang/WinRPM.jl">WinRPM package</a> for an example implementation.</p></li><li><p>I like the runtime features that BinDeps provides, but I don&#39;t really want to use its build time capabilities. What do you recommend?</p><p>The easiest way to do this is probably just to declare a <code>BuildProcess</code> for all your declared dependencies. This way, your custom build process will be called whenever there is an unsatisfied library dependency and you may still use the BinDeps runtime features.</p></li><li><p>Is there anything I should keep in mind when extending BinDeps or writing my own build process?</p><p>BinDeps uses a fairly standard set of directories by default and if possible, using the same directory structure is advised. Currently the specified directory structure is:</p></li></ul><pre><code class="language-none">deps/
    build.jl        # This is your build file
    downloads/      # Store any binary/source downloads here
    builds/
        dep1/       # out-of-tree build for dep1, is possible
        dep2/       # out-of-tree build for dep2, is possible
        ...
    src/
        dep1/       # Source code for dep1
        dep2/       # Source code for dep2
        ...
    usr/            # &quot;prefix&quot;, install your binaries here
        lib/        # Dynamic libraries (yes even on Windows)
        bin/        # Excecutables
        include/    # Headers
        ...</code></pre><h1><a class="nav-anchor" id="The-high-level-interface-Declaring-dependencies-1" href="#The-high-level-interface-Declaring-dependencies-1">The high level interface - Declaring dependencies</a></h1><p>To get a feel for the high level interface provided by BinDeps, have a look at real-world examples. The <a href="https://github.com/jiahao/GSL.jl/blob/master/deps/build.jl">build script from the GSL pakage</a> illustrates the simple case where only one library is needed. On the other hand, the <a href="https://github.com/JuliaLang/Cairo.jl/blob/master/deps/build.jl">build script from the Cairo package</a> uses almost all the features that BinDeps currently provides and offers a complete overview. Let&#39;s take it apart, to see exactly what&#39;s going on.</p><p>As you can see Cairo depends on a lot of libraries that all need to be managed by this build script. Every one of these library dependencies is introduced by the <code>library_dependency</code> function. The only required argument is the name of the library, so the following would be an entirely valid call:</p><pre><code class="language-julia">foo = library_dependency(&quot;libfoo&quot;)</code></pre><p>However, you&#39;ll most likely quickly run into the issue that this library is named differently on different systems, which is why BinDeps provides the handy <code>aliases</code> keyword argument. So suppose our library is sometimes known as <code>libfoo.so</code>, but other times as <code>libfoo-1.so</code> or <code>libfoo-1.0.0.dylib</code> or even <code>libbar.dll</code> on windows, because the authors of the library decided to punish windows users. In either case, we can easily declare all these in our library dependency:</p><pre><code class="language-julia">foo = library_dependency(&quot;libfoo&quot;, aliases = [&quot;libfoo&quot;, &quot;libfoo-1&quot;, &quot;libfoo-1.0.0&quot;, &quot;libbar&quot;])</code></pre><p>So far so good! There are a couple of other keyword arguments that are currently implemented:</p><ul><li><code>os = OS_NAME</code>  Limits this dependency to certain operating systems. The same could be achieved by using the OS-specific macro, but  this setting applies to all uses of this dependency and avoids having to wrap all uses of this dependency in macros.  Note that the <code>os</code> parameter must match the value of <code>Base.OS_NAME</code> on the target platform with the special exception that  <code>:Unix</code> matches all Unix-like platforms (e.g. <code>Linux</code>, <code>Mac OS X</code>, <code>FreeBSD</code>)  As an example, consider this line from the Cairo build script:</li></ul><pre><code class="language-julia">gettext = library_dependency(&quot;gettext&quot;, aliases = [&quot;libgettext&quot;, &quot;libgettextlib&quot;], os = :Unix)</code></pre><ul><li><code>depends = [dep1, dep2]</code>  Currently unused, but in the future will be used to keep track of the dependency graph between binary dependencies to allow parallel builds. E.g.:</li></ul><pre><code class="language-julia">cairo = library_dependency(&quot;cairo&quot;, aliases = [&quot;libcairo-2&quot;, &quot;libcairo&quot;], depends = [gobject, fontconfig, libpng])</code></pre><ul><li><p><code>runtime::Bool</code>  Whether or not to consider this a runtime dependency. If false, its absence  will not trigger an error at runtime (and it will not be loaded), but if it  cannot be found at buildtime it will be installed. This is useful for build-time  dependencies of other binary dependencies.</p></li><li><p><code>validate::Function</code>  You may pass a function to validate whether or not a certain library is usable,  e.g. whether or not has the correct version. To do so, pass a function that takes  (name,handle) as an argument and returns <code>true</code> if the library is usable and <code>false</code>  it not. The <code>name</code> argument is either an absolute path or the library name if it is a  global system library, while the handle is a handle that may be passed to <code>dlsym</code> to  check library symbols or the return value of a function.  Should the validation return false for a library that was installed by a provider, the  provider will be instructed to force a rebuild.</p></li></ul><pre><code class="language-julia">function validate_cairo_version(name,handle)
    f = Libdl.dlsym_e(handle, &quot;cairo_version&quot;)
    f == C_NULL &amp;&amp; return false
    v = ccall(f, Int32,())
    return v &gt; 10800
end
...
cairo = library_dependency(&quot;cairo&quot;, aliases = [&quot;libcairo-2&quot;, &quot;libcairo&quot;], validate = validate_cairo_version)</code></pre><p>Other keyword arguments will most likely be added as necessary.</p><h1><a class="nav-anchor" id="The-high-level-interface-Declaring-build-mechanisms-1" href="#The-high-level-interface-Declaring-build-mechanisms-1">The high level interface - Declaring build mechanisms</a></h1><p>Alright, now that we have declared all the dependencies that we need let&#39;s tell BinDeps how to build them. One of the easiest ways to do so is to use the system package manager. So suppose we have defined the following dependencies:</p><pre><code class="language-julia">foo = library_dependency(&quot;libfoo&quot;)
baz = library_dependency(&quot;libbaz&quot;)</code></pre><p>Let&#39;s suppose that these libraries are available in the <code>libfoo-dev</code> and <code>libbaz-dev</code> in apt-get and that both libraries are installed by the <code>baz</code> or the <code>baz1</code> yum package, and the <code>baz</code> pacman package. We may declare this as follows:</p><pre><code class="language-julia">provides(AptGet, Dict(&quot;libfoo-dev&quot; =&gt; foo, &quot;libbaz-dev&quot; =&gt; baz))
provides(Yum, [&quot;baz&quot;, &quot;baz1&quot;], [foo, baz])
provides(Pacman, &quot;baz&quot;, [foo, baz])</code></pre><p>One may remember the <code>provides</code> function by thinking <code>AptGet</code> <code>provides</code> the dependencies <code>foo</code> and <code>baz</code>.</p><p>The basic signature of the provides function is</p><pre><code class="language-julia">provides(Provider, data, dependency, options...)</code></pre><p>where <code>data</code> is provider-specific (e.g. a string in all of the package manager cases) and <code>dependency</code> is the return value from <code>library_dependency</code>. As you saw above multiple definitions may be combined into one function call as such:</p><pre><code class="language-julia">provides(Provider, Dict(data1=&gt;dep1, data2=&gt;dep2), options...)</code></pre><p>which is equivalent to (and in fact will be internally dispatched) to:</p><pre><code class="language-julia">provides(Provider, data1, dep1, options...)
provides(Provider, data2, dep2, options...)</code></pre><p>If one provide satisfied multiple dependencies simultaneously, <code>dependency</code> may also be an array of dependencies (as in the <code>Yum</code> and <code>Pacman</code> cases above).</p><p>There are also several builtin options. Some of them are:</p><ul><li><p><code>os = OS_NAME # e.g. :Linux, :Windows, :Darwin</code></p><p>This provider can only satisfy the library dependency on the specified <code>os</code>.  This argument takes has the same syntax as the <code>os</code> keyword argument to  <code>library_dependency</code>.</p></li><li><p><code>installed_libpath = &quot;path&quot;</code></p><p>If the provider installs a library dependency to someplace other than the  standard search paths, that location can be specified here.</p></li><li><p><code>SHA = &quot;sha&quot;</code></p></li></ul><p>Provides a SHA-256 checksum to validate a downloaded source or binary file against.</p><h1><a class="nav-anchor" id="The-high-level-interface-built-in-providers-1" href="#The-high-level-interface-built-in-providers-1">The high level interface - built in providers</a></h1><p>We have already seen the <code>AptGet</code> and <code>Yum</code> providers, which all take a string naming the package as their data argument. The other build-in providers are:</p><ul><li><p>Sources</p><p>Takes a <code>URI</code> object as its data argument and declared that the sources may be  downloaded from the provided URI. This dependency is special, because it&#39;s  success does not automatically mark the build as succeeded (in BinDeps  terminology, it&#39;s a &quot;helper&quot;). By default this provider expects the unpacked  directory name to be that of the archive downloaded. If that is not the case,  you may use the :unpacked_dir option to specify the name of the unpacked directory,  e.g.</p></li></ul><pre><code class="language-julia">provides(Sources,URI(&quot;http://libvirt.org/sources/libvirt-1.1.1-rc2.tar.gz&quot;), libvirt,
    unpacked_dir = &quot;libvirt-1.1.1&quot;)</code></pre><ul><li><p>Binaries</p><p>If given a <code>URI</code> object as its data argument, indicates that the binaries may be  downloaded from the provided URI. It is assumed that the binaries unpack the  libraries into <span>$usr/lib$</span>. If given a <span>$String$</span> as its data argument, provides  a custom search path for the binaries. A typical use might be to allow the  user to provide a custom path by using an environmental variable.</p></li><li><p>BuildProcess</p><p>Common super class of various kind of build processes. The exact behavior depends on the <code>data</code> argument. Some of the currently supported build processes are <code>Autotools</code> and <code>SimpleBuild</code>:</p></li><li><p>Autotools</p><p>A subclass of BuildProcess that that downloads the sources (as declared by the  &quot;Sources&quot; provider) and attempts to  install using Autotools. There is a plethora of options to  change the behavior of  this command. See the appropriate section of the manual (or even better,  read the code) for more details on the available options.</p></li></ul><pre><code class="language-julia">Autotools(; options...)</code></pre><ul><li><p>SimpleBuild</p><p>A subclass of BuildProcess that takes any object that&#39;s part of the low-level interface and could be passed to <code>run</code> and simply executes that command.</p></li></ul><h1><a class="nav-anchor" id="The-high-level-interface-Loading-dependencies-1" href="#The-high-level-interface-Loading-dependencies-1">The high level interface - Loading dependencies</a></h1><p>To load dependencies without a runtime dependence on BinDeps, place code like the following near the start of the Package&#39;s primary file. Don&#39;t forget to change the error message to reflect the name of the package.</p><pre><code class="language-julia">const depsfile = joinpath(dirname(@__FILE__), &quot;..&quot;, &quot;deps&quot;, &quot;deps.jl&quot;)
if isfile(depsfile)
    include(depsfile)
else
    error(&quot;HDF5 not properly installed. Please run Pkg.build(\&quot;HDF5\&quot;) then restart Julia.&quot;)
end</code></pre><p>This will make all your libraries available as variables named by the names you gave the dependency. E.g. if you declared a dependency as</p><pre><code class="language-julia">library_dependency(&quot;libfoo&quot;)</code></pre><p>The <code>libfoo</code> variable will now contain a reference to that library that may be passed to <code>ccall</code> or similar functions.</p><h1><a class="nav-anchor" id="The-low-level-interface-1" href="#The-low-level-interface-1">The low level interface</a></h1><p>The low level interface provides a number of utilities to write cross platform    build scripts. It looks something like this (from the Cairo build script):</p><pre><code class="language-julia">@build_steps begin
    GetSources(libpng)
    CreateDirectory(pngbuilddir)
    @build_steps begin
        ChangeDirectory(pngbuilddir)
        FileRule(joinpath(prefix,&quot;lib&quot;,&quot;libpng15.dll&quot;),@build_steps begin
            `cmake -DCMAKE_INSTALL_PREFIX=&quot;$prefix&quot; -G&quot;MSYS Makefiles&quot; $pngsrcdir`
            `make`
            `cp libpng*.dll $prefix/lib`
            `cp libpng*.a $prefix/lib`
            `cp libpng*.pc $prefix/lib/pkgconfig`
            `cp pnglibconf.h $prefix/include`
            `cp $pngsrcdir/png.h $prefix/include`
            `cp $pngsrcdir/pngconf.h $prefix/include`
        end)
    end
end</code></pre><p>All the steps are executed synchronously. The result of the <code>@build_steps</code> macro may be passed to run to execute it directly, thought this is not recommended other than for debugging purposes. Instead, please use the high level interface to tie the build process to dependencies.</p><p>Some of the builtin build steps are:</p><ul><li><p>FileDownloader(remote<em>file,local</em>file)</p><p>Download a file from <code>remote_file</code> create it as <code>local_file</code></p></li><li><p>FileUnpacker(local_file,folder)</p><pre><code class="language-none">Unpack the file `local_file` into the folder `folder`</code></pre></li><li><p>AutotoolsDependency(opts...)</p><p>Invoke autotools. Use of this build step is not recommended. Use the high level interface instead</p></li><li><p>CreateDirectory(dir)</p><p>Create the directory <code>dir</code></p></li><li><p>ChangeDirectory(dir)</p><p><code>cd</code> into the directory <code>dir</code> and try to remain there for this build block. Must be the first command in a <code>@build_steps</code> block and will remain active for the entire block</p></li><li><p>MakeTargets([dir,],[args...],env)</p><p>Invoke <code>make</code> with the given arguments in the given directory with the given environment.</p></li><li><p>DirectoryRule(dir,step)</p><p>If <code>dir</code> does not exist invoke step and validate that the directory was created</p></li><li><p>FileRule([files...],step)</p><p>Like Directory rule, but validates the existence of any of the files in the <code>files</code>array`.</p></li><li><p>GetSources(dep)</p><p>Get the declared sources from the dependency dep and put them in the default download location</p></li></ul><h1><a class="nav-anchor" id="Diagnostics-1" href="#Diagnostics-1">Diagnostics</a></h1><p>A simple way to see what libraries are required by a package, and to detect missing dependencies, is to use <code>BinDeps.debug(&quot;PackageName&quot;)</code>:</p><pre><code class="language-julia">julia&gt; using BinDeps

julia&gt; BinDeps.debug(&quot;Cairo&quot;)
INFO: Reading build script...
The package declares 1 dependencies.
 - Library Group &quot;cairo&quot; (satisfied by BinDeps.SystemPaths, BinDeps.SystemPaths)
     - Library &quot;png&quot; (not applicable to this system)
     - Library &quot;pixman&quot; (not applicable to this system)
     - Library &quot;ffi&quot; (not applicable to this system)
     - Library &quot;gettext&quot;
        - Satisfied by:
          - System Paths at /usr/lib64/preloadable_libintl.so
          - System Paths at /usr/lib64/libgettextpo.so
        - Providers:
          - BinDeps.AptGet package gettext (can&#39;t provide)
          - BinDeps.Yum package gettext-libs (can&#39;t provide)
          - Autotools Build</code></pre><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
