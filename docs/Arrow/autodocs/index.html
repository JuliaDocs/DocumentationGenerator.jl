<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Arrow.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Arrow.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.Datestamp" href="#Arrow.Datestamp"><code>Arrow.Datestamp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Datestamp &lt;: ArrowTime</code></pre><p>Stores a date as an <code>Int32</code> for Arrow formatted data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.DictEncoding" href="#Arrow.DictEncoding"><code>Arrow.DictEncoding</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DictEncoding{P&lt;:ArrowVector,J} &lt;: ArrowVector{J}</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.List" href="#Arrow.List"><code>Arrow.List</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">List{P&lt;:AbstractPrimitive,J} &lt;: AbstractList{J}</code></pre><p>An Arrow formatted array of variable length objects such as strings. The <code>List</code> contains &quot;value&quot; data as well as &quot;offsets&quot; which describe from which elements of the values data an element of <code>List</code> should be constructed.  The offsets are necessarily a <code>Primitive{Int32}</code> while the values can be any <code>ArrowVector</code> type (but in most circumstances should be <code>Primitive</code>).</p><p><strong>Constructors</strong></p><pre><code class="language-none">List{J}(len::Integer, offs::Primitive{Int32}, vals::AbstractPrimitive)
List{J}(offs::Primitive{Int32}, vals::AbstractPrimitive)
List{J}(data::Vector{UInt8}, offset_idx::Integer, len::Integer, vals::AbstractPrimitive)
List{J}(data::Vector{UInt8}, offset_idx::Integer, values_idx::Integer, ::Type{C}, x::AbstractVector)
List{J}(data::Vector{UInt8}, i::Integer, ::Type{C}, x::AbstractVector)
List(data::Vector{UInt8}, i::Integer, ::Type{C}, x::AbstractVector)
List{J}(Array, ::Type{C}, x::AbstractVector)
List(Array, ::Type{C}, x::AbstractVector)
List(::Type{C}, v::AbstractVector)
List(v::AbstractVector{&lt;:AbstractString})</code></pre><p>Note that by default, <code>List</code>s of strings will be encoded in UTF-8.</p><p><strong>Arguments</strong></p><ul><li><code>len</code>: the length of the <code>List</code></li><li><code>offs</code>: a <code>Primitive{Int32}</code> containing the offsets data</li><li><code>vals</code>: a <code>Primitive</code> containing the values data</li><li><code>data</code>: the data buffer in which the underlying data is stored</li><li><code>offset_idx</code>: location within <code>data</code> where the offset data is stored</li><li><code>values_idx</code>: location within <code>data</code> where the values data is stored</li><li><code>C</code>: the encoding type (type of values), e.g. for UTF-8 strings this is <code>UInt8</code>. defaults to <code>UInt8</code>   if not given explicitly</li><li><code>i</code>: the location in <code>data</code> where all data should be stored (offsets, then values)</li><li><code>x</code>, <code>v</code>: array to be stored or converted</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.NullableList" href="#Arrow.NullableList"><code>Arrow.NullableList</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NullableList{P&lt;:AbstractPrimitive,J} &lt;: AbstractList{Union{Missing,J}}</code></pre><p>An Arrow formatted array of variable length objects such as strings which may be null. The <code>NullableList</code> contains a bit mask specifying which values are null and &quot;offsets&quot; which describe from which elements of the values data an element of the <code>NullableList</code> should be constructed.  The bitmask is contained in a <code>Primitive{UInt8}</code> while the offsets data in a <code>Primitive{Int32}</code>. The values can be contained in any <code>ArrowVector</code> type, but in most cases should be <code>Primitive</code>.</p><p><strong>Constructors</strong></p><pre><code class="language-none">NullableList{J}(len::Integer, bmask::Primitive, offs::Primitive, vals::AbstractPrimitive)
NullableList{J}(bmask::Primitive, offs::Primitive, vals::AbstractPrimitive)
NullableList{J}(data::Vector{UInt8}, bitmask_idx::Integer, offset_idx::Integer, len::Integer,
                vals::AbstractPrimitive)
NullableList{J}(data::Vector{UInt8}, bitmask_idx::Integer, offset_idx::Integer, values_idx::Integer,
                len::Integer, ::Type{C}, values_len::Integer)
NullableList{J}(data::Vector{UInt8}, bitmask_idx::Integer, offset_idx::Integer, values_idx::Integer,
                ::Type{C}, x::AbstractVector)
NullableList(data::Vector{UInt8}, i::Integer, ::Type{C}, x::AbstractVector)
NullableList(Array, ::Type{C}, x::AbstractVector)
NullableList(Array, x::AbstracVector)
NullableList(::Type{C}, v::AbstractVector)
NullableList(v::AbstractVector)</code></pre><p>If <code>Array</code> is given as an argument, a contiguous array will be allocated to store the data.</p><p><strong>Arguments</strong></p><ul><li><code>len</code>: the length of the <code>NullableList</code></li><li><code>bmask</code>: the <code>Primitive</code> providing the bit mask</li><li><code>offs</code>: the <code>Primitive</code> providing the offsets</li><li><code>vals</code>: the <code>AbstractPrimitive</code> providing the values</li><li><code>data</code>: a buffer for storing the data</li><li><code>bitmask_idx</code>: the location in <code>data</code> of the bit mask</li><li><code>offsets_idx</code>: the location in <code>data</code> of the offsets</li><li><code>values_idx</code>: the location in <code>data</code> of the values</li><li><code>values_len</code>: the total length of the values data (i.e. number of elements in the values array)</li><li><code>C</code>: the data type of the values data. defaults to <code>UInt8</code> when not provided</li><li><code>x</code>, <code>v</code>: array to be stored by the <code>NullableList</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.NullablePrimitive" href="#Arrow.NullablePrimitive"><code>Arrow.NullablePrimitive</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NullablePrimitive{J} &lt;: AbstractPrimitive{Union{J,Missing}}</code></pre><p>A set of values stored contiguously in data with a bit mask specifying which values should be considered null.  The bit mask and data needn&#39;t necessarily coexist within the same array.</p><p><strong>Constructors</strong></p><pre><code class="language-none">NullablePrimitive(bmask::Primitive{UInt8}, vals::Primitive{J})
NullablePrimitive(data::Vector{UInt8}, bitmask_idx::Integer, values_idx::Integer, x::AbstractVector)
NullablePrimitive(data::Vector{UInt8}, i::Integer, x::AbstractVector)
NullablePrimitive(v::AbstractVector)
NullablePrimitive(Array, x::AbstractVector)</code></pre><p>If <code>Array</code> is passed to a constructor, the bit mask and values for the <code>NullablePrimitive</code> will be contiguously allocated within a single array (bit mask first, then values).</p><p><strong>Arguments</strong></p><ul><li><code>bmask</code>: a <code>Primitive{UInt8}</code> containing the null bitmask for the <code>NullablePrimitive</code></li><li><code>vals</code>: a <code>Primitive</code> containing the underlying data values for the <code>NullablePrimitive</code></li><li><code>data</code>: a buffer in which the data for the <code>NullablePrimitive</code> will be stored</li><li><code>bitmask_idx</code>: the location within <code>data</code> where the null bit mask will be stored</li><li><code>values_idx</code>: the location within <code>data</code> where the values will be stored</li><li><code>x</code>, <code>v</code>: values to be stored in data</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.Primitive" href="#Arrow.Primitive"><code>Arrow.Primitive</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Primitive{J} &lt;: AbstractPrimitive{J}</code></pre><p>A set of values which are stored contiguously in memory.  All other <code>ArrowVector</code> objects are built from <code>Primitive</code>s.</p><p><strong>Constructors</strong></p><pre><code class="language-none">Primitive{J}(data::Vector{UInt8}, i::Integer, len::Integer)
Primitive(data::Vector{UInt8}, i::Integer, x::AbstractVector)
Primitive(v::AbstractVector)
Primitive(Array, x::Abstractvector)</code></pre><p>If <code>Array</code> is provided as the virst argument, the data will be allocated contiguously in a new buffer.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: a data buffer which the <code>Primitive</code> will refer to for accessing and storing values</li><li><code>i</code>: the index of the location (1-based) in <code>data</code> where the beginning of the value data is stored</li><li><code>x</code>: a vector which will be written into <code>data[i]</code> on construction</li></ul><p><code></code>v<code>: existing reference data. constructors with will reference the original</code>v<code>as</code>data`</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.TimeOfDay" href="#Arrow.TimeOfDay"><code>Arrow.TimeOfDay</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TimeOfDay{P&lt;:Dates.TimePeriod,T&lt;:Union{Int32,Int64}} &lt;: ArrowTime</code></pre><p>An arrow formatted object for representing the time of day. Underlying data is <code>Int32</code> for seconds and milliseconds, <code>Int64</code> for microsecond and nanosecond.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.Timestamp" href="#Arrow.Timestamp"><code>Arrow.Timestamp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Timestamp{P&lt;:Dates.TimePeriod} &lt;: ArrowTime</code></pre><p>Timestamp in which time is stored in units <code>P</code> as <code>Int64</code> for Arrow formatted data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.arrowformat" href="#Arrow.arrowformat"><code>Arrow.arrowformat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arrowformat(v::AbstractVector)
arrowformat(Array, v::AbstractVector)</code></pre><p>Convert a vector to the appropriate arrowformat.  If <code>Array</code> is passed, a contiguous array will be used for the data buffer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.arrowview-Tuple{Primitive,UnitRange}" href="#Arrow.arrowview-Tuple{Primitive,UnitRange}"><code>Arrow.arrowview</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">arrowview(p::ArrowVector, idx::UnitRange)</code></pre><p>Return another <code>ArrowVector</code> which is a view into <code>p</code> for the index range <code>idx</code>.</p><p>This can only be done with contiguous indices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.bitmaskbytes-Tuple{Integer}" href="#Arrow.bitmaskbytes-Tuple{Integer}"><code>Arrow.bitmaskbytes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">bitmaskbytes(A::AbstractVector)
bitmaskbytes(::Type{Union{J,Missing}}, A::AbstractVector)</code></pre><p>Compute the number of bytes needed to store a null bitmask for the data in <code>A</code>.  This is 0 unless <code>J &lt;: Union{K,Missing}</code>. Note that this does not take into account scheme-dependent padding.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.bitpack-Tuple{AbstractArray{Bool,1}}" href="#Arrow.bitpack-Tuple{AbstractArray{Bool,1}}"><code>Arrow.bitpack</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">bitpack(A::AbstractVector{Bool})</code></pre><p>Returns a <code>Vector{UInt8}</code> the bits of which are the values of <code>A</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.bytesforbits-Tuple{Integer}" href="#Arrow.bytesforbits-Tuple{Integer}"><code>Arrow.bytesforbits</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">bytesforbits(n::Integer)</code></pre><p>Get the number of bytes required to store <code>n</code> bits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.getoffset-Tuple{AbstractList,Any}" href="#Arrow.getoffset-Tuple{AbstractList,Any}"><code>Arrow.getoffset</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getoffset(l::AbstractList, i::Integer)</code></pre><p>Retrieve offset <code>i</code> for list <code>l</code>.  Note that this retrieves the Arrow formated 0-based indexed raw numbers!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.isnull-Tuple{ArrowVector,Any}" href="#Arrow.isnull-Tuple{ArrowVector,Any}"><code>Arrow.isnull</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isnull(A::ArrowVector, idx)</code></pre><p>Check whether element(s) <code>idx</code> of <code>A</code> are null.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.nullcount-Tuple{ArrowVector}" href="#Arrow.nullcount-Tuple{ArrowVector}"><code>Arrow.nullcount</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">nullcount(A::ArrowVector)</code></pre><p>Return the number of nulls (<code>missing</code>s) in <code>A</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.offsets-Union{Tuple{C}, Tuple{K}, Tuple{Type{K},Type{C},AbstractArray{T,1} where T}} where C where K&lt;:Integer" href="#Arrow.offsets-Union{Tuple{C}, Tuple{K}, Tuple{Type{K},Type{C},AbstractArray{T,1} where T}} where C where K&lt;:Integer"><code>Arrow.offsets</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">offsets(v::AbstractVector)</code></pre><p>Construct a <code>Vector{Int32}</code> of offsets appropriate for data appearing in <code>v</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.padding-Tuple{Integer}" href="#Arrow.padding-Tuple{Integer}"><code>Arrow.padding</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">padding(n::Integer)</code></pre><p>Determines the total number of bytes needed to store <code>n</code> bytes with padding. Note that the Arrow standard requires buffers to be aligned to 8-byte boundaries.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.rawpadded-Tuple{Primitive,Union{AbstractArray{#s832,1} where #s832&lt;:Integer, #s833} where #s833&lt;:Integer}" href="#Arrow.rawpadded-Tuple{Primitive,Union{AbstractArray{#s832,1} where #s832&lt;:Integer, #s833} where #s833&lt;:Integer}"><code>Arrow.rawpadded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rawpadded(A::Primitive)</code></pre><p>Get a <code>Vector{UInt8}</code> describing the data of <code>A</code> with Arrow padding (8 bytes).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.rawvalues-Tuple{ArrowVector,Any}" href="#Arrow.rawvalues-Tuple{ArrowVector,Any}"><code>Arrow.rawvalues</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rawvalues(A::ArrowVector, idx)</code></pre><p>Gets a <code>Vector{UInt8}</code> of the raw values associated with the indices <code>idx</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.rawvalues-Tuple{Primitive,Union{AbstractArray{#s832,1} where #s832&lt;:Integer, #s833} where #s833&lt;:Integer}" href="#Arrow.rawvalues-Tuple{Primitive,Union{AbstractArray{#s832,1} where #s832&lt;:Integer, #s833} where #s833&lt;:Integer}"><code>Arrow.rawvalues</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rawvalues(A::Primitive, i)
rawvalues(A::Primitive)</code></pre><p>Gets the raw values for elements at locations <code>i</code> in the form of a <code>Vector{UInt8}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.totalbytes-Tuple{AbstractArray{T,1} where T}" href="#Arrow.totalbytes-Tuple{AbstractArray{T,1} where T}"><code>Arrow.totalbytes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">totalbytes(A::AbstractVector)
totalbytes(::Type{Union{J,Missing}}, A::AbstractVector)
totalbytes(::Type{C}, A::AbstractVector)
totalbytes(::Type{Union{J,Missing}}, ::Type{C}, A::AbstractVector)</code></pre><p>Computes the minimum number of bytes needed to store <code>A</code> as an Arrow formatted primitive array or list.</p><p>To obtain the minimum bytes to store string data, one must input <code>C</code> the character encoding type the string will be converted to (e.g. <code>UInt8</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unbitpack-Tuple{AbstractArray{UInt8,1}}" href="#Arrow.unbitpack-Tuple{AbstractArray{UInt8,1}}"><code>Arrow.unbitpack</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unbitpack(A::AbstractVector{UInt8})</code></pre><p>Returns a <code>Vector{Bool}</code> the values of which are the bits of <code>A</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.valuesbytes-Union{Tuple{J}, Tuple{Type{J},Integer}} where J" href="#Arrow.valuesbytes-Union{Tuple{J}, Tuple{Type{J},Integer}} where J"><code>Arrow.valuesbytes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">valuesbytes(A::AbstractVector)
valuesbytes(::Type{C}, A::AbstractVector{&lt;:AbstractString})</code></pre><p>Computes the number of bytes needed to store the <em>values</em> of <code>A</code> (without converting the underlying binary type). This does not include the number of bytes needed to store metadata such as a null bitmask or offsets.</p><p>To obtain the number of values bytes needed to string data, one must input <code>C</code> the character encoding type the string will be converted to (e.g. <code>UInt8</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.writepadded-Tuple{IO,Any}" href="#Arrow.writepadded-Tuple{IO,Any}"><code>Arrow.writepadded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">writepadded(io::IO, x)
writepadded(io::IO, A::Primitive)
writepadded(io::IO, A::Arrowvector, subbuffs::Function...)</code></pre><p>Write the data <code>x</code> to <code>io</code> with 8-byte padding. This is commonly needed in Arrow implementations since Arrow requires 8-byte boundary alignment.</p><p>If a <code>Primitive</code> is provided, the appropriate padded values will be written.</p><p>If an <code>ArrowVector</code> is provided, the ordering of the sub-buffers must be specified, and they will be written in the order given.  For example <code>writepadded(io, A, bitmask, offsets, values)</code> will write the bit mask, offsets and then values of <code>A</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.writepadded-Tuple{IO,Primitive,Union{AbstractArray{#s832,1} where #s832&lt;:Integer, #s833} where #s833&lt;:Integer}" href="#Arrow.writepadded-Tuple{IO,Primitive,Union{AbstractArray{#s832,1} where #s832&lt;:Integer, #s833} where #s833&lt;:Integer}"><code>Arrow.writepadded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">writepadded(io::IO, A::Primitive)</code></pre><p>Write the values of <code>A</code> to <code>io</code> with Arrow padding (8 bytes).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.bitmaskpointer-Union{Tuple{ArrowVector{Union{Missing, J}}}, Tuple{J}} where J" href="#Arrow.bitmaskpointer-Union{Tuple{ArrowVector{Union{Missing, J}}}, Tuple{J}} where J"><code>Arrow.bitmaskpointer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">bitmaskpointer(A::ArrowVector)</code></pre><p>Returns a pointer to the start of the bitmask buffer for <code>A</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.construct-Union{Tuple{T}, Tuple{Type{T},AbstractPrimitive,Integer,Integer}} where T" href="#Arrow.construct-Union{Tuple{T}, Tuple{Type{T},AbstractPrimitive,Integer,Integer}} where T"><code>Arrow.construct</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">construct(::Type{T}, A::AbstractPrimitive{J}, i::Integer, len::Integer)</code></pre><p>Construct an object of type <code>T</code> from <code>len</code> values in <code>A</code> starting at index <code>i</code>. For this to work requires the existence of a constructor of the form <code>T(::Vector{J})</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.datapointer-Tuple{Primitive}" href="#Arrow.datapointer-Tuple{Primitive}"><code>Arrow.datapointer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">datapointer(A::Primitive)</code></pre><p>Returns a pointer to the very start of the data buffer for <code>A</code> (i.e. does not depend on indices).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.ellength-Tuple{AbstractList,Integer}" href="#Arrow.ellength-Tuple{AbstractList,Integer}"><code>Arrow.ellength</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ellength(l::AbstractList, i::Integer)</code></pre><p>Get the length of element <code>i</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.encode-Union{Tuple{J}, Tuple{C}, Tuple{Type{C},AbstractArray{J,1}}} where J where C" href="#Arrow.encode-Union{Tuple{J}, Tuple{C}, Tuple{Type{C},AbstractArray{J,1}}} where J where C"><code>Arrow.encode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">encode(::Type{C}, v::AbstractVector{J})</code></pre><p>Attempt to encode the data in <code>v</code> as a <code>Vector{C}</code>. This requires that if <code>convert(Vector{C}, x)</code> is valid where <code>x ∈ v</code>.  Nothing is stored for cases where <code>x == missing</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.getbit-Union{Tuple{J}, Tuple{Primitive{J},Integer}} where J" href="#Arrow.getbit-Union{Tuple{J}, Tuple{Primitive{J},Integer}} where J"><code>Arrow.getbit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getbit(A::Primitive, i)</code></pre><p>Get the <code>i</code>th bit of the primitive.  For example, for a <code>Primitive{UInt8]</code> the 10th bit is the second bit of the second value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.getvalue-Union{Tuple{J}, Tuple{Union{NullablePrimitive{J}, Primitive{J}},Integer}} where J" href="#Arrow.getvalue-Union{Tuple{J}, Tuple{Union{NullablePrimitive{J}, Primitive{J}},Integer}} where J"><code>Arrow.getvalue</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getvalue(A::ArrowVector, idx)</code></pre><p>Get the values for indices <code>idx</code> from <code>A</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.offsetspointer-Tuple{AbstractList}" href="#Arrow.offsetspointer-Tuple{AbstractList}"><code>Arrow.offsetspointer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">offsetspointer(A::AbstractList)</code></pre><p>Returns a pointer to the start of the offsets buffer for <code>A</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_construct-Tuple{Type{String},Primitive{UInt8},Integer,Integer}" href="#Arrow.unsafe_construct-Tuple{Type{String},Primitive{UInt8},Integer,Integer}"><code>Arrow.unsafe_construct</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_construct(::Type{T}, A::Primitive, i::Integer, len::Integer)</code></pre><p>Construct an object of type <code>T</code> using <code>len</code> elements from <code>A</code> starting at index <code>i</code> (1-based indexing). This is mostly used by <code>AbstractList</code> objects to construct variable length objects such as strings from primitive arrays.</p><p>Users must define new methods for new types <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_ellength-Tuple{AbstractList,Integer}" href="#Arrow.unsafe_ellength-Tuple{AbstractList,Integer}"><code>Arrow.unsafe_ellength</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_ellength(l::AbstractList, i::Integer)</code></pre><p>Get the length of element <code>i</code>. Involves calls to <code>unsafe_load</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_getoffset-Tuple{AbstractList,Any}" href="#Arrow.unsafe_getoffset-Tuple{AbstractList,Any}"><code>Arrow.unsafe_getoffset</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_getoffset(l::AbstractList, i::Integer)</code></pre><p>Get the offset for element <code>i</code>.  Contains a call to <code>unsafe_load</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_getvalue-Union{Tuple{J}, Tuple{Union{NullablePrimitive{J}, Primitive{J}},Integer}} where J" href="#Arrow.unsafe_getvalue-Union{Tuple{J}, Tuple{Union{NullablePrimitive{J}, Primitive{J}},Integer}} where J"><code>Arrow.unsafe_getvalue</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_getvalue(A::ArrowVector, i)</code></pre><p>Retrieve the value from memory location <code>i</code> using Julia 1-based indexing. <code>i</code> can be a single integer index, an <code>AbstractVector</code> of integer indices, or an <code>AbstractVector{Bool}</code> mask.</p><p>This typically involves a call to <code>unsafe_load</code> or <code>unsafe_wrap</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_isnull-Tuple{ArrowVector,Integer}" href="#Arrow.unsafe_isnull-Tuple{ArrowVector,Integer}"><code>Arrow.unsafe_isnull</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_isnull(A::ArrowVector, idx)</code></pre><p>Check whether element(s) <code>idx</code> of <code>A</code> are null.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_rawbitmask-Union{Tuple{ArrowVector{Union{Missing, J}}}, Tuple{J}} where J" href="#Arrow.unsafe_rawbitmask-Union{Tuple{ArrowVector{Union{Missing, J}}}, Tuple{J}} where J"><code>Arrow.unsafe_rawbitmask</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_rawbitmask(p::ArrowVector{Union{J,Missing}})</code></pre><p>Retrieve the raw value of the null bit mask for <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_rawoffsets-Tuple{AbstractList}" href="#Arrow.unsafe_rawoffsets-Tuple{AbstractList}"><code>Arrow.unsafe_rawoffsets</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_rawoffsets(p::AbstractList)</code></pre><p>Retreive the raw offstets for <code>p</code> as a <code>Vector{UInt8}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_rawpadded-Tuple{Ptr{UInt8},Integer}" href="#Arrow.unsafe_rawpadded-Tuple{Ptr{UInt8},Integer}"><code>Arrow.unsafe_rawpadded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_rawpadded(ptr::Ptr, len::Integer, padding::Function=identity)</code></pre><p>Return a <code>Vector{UInt8}</code> padded to appropriate size specified by <code>padding</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_rawpaddedvalues-Tuple{AbstractPrimitive}" href="#Arrow.unsafe_rawpaddedvalues-Tuple{AbstractPrimitive}"><code>Arrow.unsafe_rawpaddedvalues</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_rawpaddedvalues(p::ArrowVector)</code></pre><p>Retreive raw value data for <code>p</code> as a <code>Vector{UInt8}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_setnull!-Union{Tuple{J}, Tuple{ArrowVector{Union{Missing, J}},Bool,Integer}} where J" href="#Arrow.unsafe_setnull!-Union{Tuple{J}, Tuple{ArrowVector{Union{Missing, J}},Bool,Integer}} where J"><code>Arrow.unsafe_setnull!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_setnull!(A::ArrowVector{Union{J,Missing}}, x::Bool, i::Integer)</code></pre><p>Set element <code>i</code> of <code>A</code> to be null. This involves no bounds checking and a call to <code>unsafe_store!</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_setnulls!-Union{Tuple{J}, Tuple{ArrowVector{Union{Missing, J}},Array{UInt8,1}}} where J" href="#Arrow.unsafe_setnulls!-Union{Tuple{J}, Tuple{ArrowVector{Union{Missing, J}},Array{UInt8,1}}} where J"><code>Arrow.unsafe_setnulls!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_setnulls!(A::ArrowVector, nulls::AbstractVector{Bool})</code></pre><p>Set <em>all</em> the nulls for the <code>ArrowVector</code>. This does not check bounds and contains a call to <code>unsafe_copy!</code> (but does not copy directly from <code>nulls</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_setoffset!-Tuple{AbstractList,Int32,Integer}" href="#Arrow.unsafe_setoffset!-Tuple{AbstractList,Int32,Integer}"><code>Arrow.unsafe_setoffset!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_setoffset!(l::AbstractList, off::Int32, i::Integer)</code></pre><p>Set offset <code>i</code> to <code>off</code>.  Contains a call to <code>unsafe_store!</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_setoffsets!-Tuple{AbstractList,Array{Int32,1}}" href="#Arrow.unsafe_setoffsets!-Tuple{AbstractList,Array{Int32,1}}"><code>Arrow.unsafe_setoffsets!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_setoffsets!(l::AbstractList, off::Vector{Int32})</code></pre><p>Set all offsets to the <code>Vector{Int32}</code> <code>off</code>.  Contains a call to <code>unsafe_copy!</code> which copies the entirety of <code>off</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.unsafe_setvalue!-Union{Tuple{J}, Tuple{Union{NullablePrimitive{J}, Primitive{J}},J,Integer}} where J" href="#Arrow.unsafe_setvalue!-Union{Tuple{J}, Tuple{Union{NullablePrimitive{J}, Primitive{J}},J,Integer}} where J"><code>Arrow.unsafe_setvalue!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_setvalue!(A::ArrowVector{J}, x, i)</code></pre><p>Set the value at location <code>i</code> to <code>x</code>.  If <code>i</code> is a single integer, <code>x</code> should be an element of type <code>J</code>.  Otherwise <code>i</code> can be an <code>AbstractVector{&lt;:Integer}</code> or <code>AbstractVector{Bool}</code> in which case <code>x</code> should be an appropriately sized <code>AbstractVector{J}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Arrow.valuespointer-Tuple{ArrowVector}" href="#Arrow.valuespointer-Tuple{ArrowVector}"><code>Arrow.valuespointer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">valuespointer(A::ArrowVector)</code></pre><p>Returns a pointer to the start of the values buffer for <code>A</code>.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
