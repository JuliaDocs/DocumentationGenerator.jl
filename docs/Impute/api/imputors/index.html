<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Imputors · Impute.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/invenia.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Impute.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../impute/">Impute</a></li><li><a class="toctext" href="../context/">Context</a></li><li class="current"><a class="toctext" href>Imputors</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Fill-1">Fill</a></li><li class="toplevel"><a class="toctext" href="#Interpolate-1">Interpolate</a></li><li class="toplevel"><a class="toctext" href="#Last-Observation-Carried-Forward-(LOCF)-1">Last Observation Carried Forward (LOCF)</a></li><li class="toplevel"><a class="toctext" href="#Next-Observation-Carried-Backward-(NOCB)-1">Next Observation Carried Backward (NOCB)</a></li><li class="toplevel"><a class="toctext" href="#Chain-1">Chain</a></li></ul></li><li><a class="toctext" href="../utils/">Utilities</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Imputors</a></li></ul></nav><hr/><div id="topbar"><span>Imputors</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!" href="#Impute.impute!"><code>Impute.impute!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">impute!(imp::Imputor, data::Dataset, limit::Float64=0.1)</code></pre><p>Creates a <code>Context</code> using information about <code>data</code>. These include</p><ol><li><p>missing data function which defaults to <code>missing</code></p></li><li><p>number of elements: <code>*(size(data)...)</code></p></li></ol><p><strong>Arguments</strong></p><ul><li><code>imp::Imputor</code>: the Imputor method to use</li><li><code>data::Dataset</code>: the data to impute</li><li><code>limit::Float64: missing data ratio limit/threshold (default: 0.1)</code></li></ul><p><strong>Return</strong></p><ul><li><code>Dataset</code>: the input <code>data</code> with values imputed.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{Impute.Imputor,Impute.Context,AbstractArray{T,2} where T}" href="#Impute.impute!-Tuple{Impute.Imputor,Impute.Context,AbstractArray{T,2} where T}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">impute!(imp::Imputor, ctx::Context, data::AbstractMatrix)</code></pre><p>Imputes the data in a matrix by imputing the values 1 column at a time; if this is not the desired behaviour custom imputor methods should overload this method.</p><p><strong>Arguments</strong></p><ul><li><code>imp::Imputor</code>: the Imputor method to use</li><li><code>ctx::Context</code>: the contextual information for missing data</li><li><code>data::AbstractMatrix</code>: the data to impute</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix</code>: the input <code>data</code> with values imputed</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{Impute.Imputor,Impute.Context,DataFrame}" href="#Impute.impute!-Tuple{Impute.Imputor,Impute.Context,DataFrame}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">impute!(imp::Imputor, ctx::Context, data::DataFrame)</code></pre><p>Imputes the data in a DataFrame by imputing the values 1 column at a time; if this is not the desired behaviour custom imputor methods should overload this method.</p><p><strong>Arguments</strong></p><ul><li><code>imp::Imputor</code>: the Imputor method to use</li><li><code>ctx::Context</code>: the contextual information for missing data</li><li><code>data::DataFrame</code>: the data to impute</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: the input <code>data</code> with values imputed</li></ul></div></div></section><h1><a class="nav-anchor" id="Drop-1" href="#Drop-1">Drop</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{Impute.Drop,Impute.Context,AbstractArray{T,1} where T}" href="#Impute.impute!-Tuple{Impute.Drop,Impute.Context,AbstractArray{T,1} where T}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">impute!(imp::Drop, ctx::Context, data::AbstractVector)</code></pre><p>Uses <code>filter!</code> to remove missing elements from the array.</p><p><strong>Arguments</strong></p><ul><li><code>imp::Drop</code>: this <code>Imputor</code> method</li><li><code>ctx::Context</code>: contextual information for missing data</li><li><code>data::AbstractVector</code>: the data to impute</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractVector</code>: our data array with missing elements removed</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{Impute.Drop,Impute.Context,AbstractArray{T,2} where T}" href="#Impute.impute!-Tuple{Impute.Drop,Impute.Context,AbstractArray{T,2} where T}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">impute!(imp::Drop, ctx::Context, data::AbstractMatrix)</code></pre><p>Finds the missing rows in the matrix and uses a mask (Vector{Bool}) to return the <code>data</code> with those rows removed. Unfortunately, the mask approach requires copying the matrix.</p><p>NOTES (or premature optimizations):</p><ul><li>We use <code>view</code>, but this will change the type of the <code>data</code> by returning a <code>SubArray</code></li><li>We might be able to do something clever by:<ol><li>reshaping the data to a vector</li><li>running <code>deleteat!</code> for the appropriate indices and</li><li>reshaping the data back to the desired shape.</li></ol></li></ul><p><strong>Arguments</strong></p><ul><li><code>imp::Drop</code>: this <code>Imputor</code> method</li><li><code>ctx::Context</code>: contextual information for missing data</li><li><code>data::AbstractMatrix</code>: the data to impute</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix</code>: a new matrix with missing rows removed</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{Impute.Drop,Impute.Context,DataFrame}" href="#Impute.impute!-Tuple{Impute.Drop,Impute.Context,DataFrame}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">impute!(imp::Drop, ctx::Context, data::DataFrame)</code></pre><p>Finds the missing rows in the <code>DataFrame</code> and deletes them.</p><p>NOTE: this isn&#39;t quite as fast as <code>dropnull</code> in <code>DataFrames</code>s as we&#39;re using an arbitrary <code>missing</code> function rather than using the precomputed <code>dt.isnull</code> vector of bools.</p><p><strong>Arguments</strong></p><ul><li><code>imp::Drop</code>: this <code>Imputor</code> method</li><li><code>ctx::Context</code>: contextual information for missing data</li><li><code>data::DataFrame</code>: the data to impute</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: our data with the missing rows removed.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Drop" href="#Impute.Drop"><code>Impute.Drop</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Drop &lt;: Imputor</code></pre><p>Removes missing values from the <code>AbstractArray</code> or <code>DataFrame</code> provided.</p></div></div></section><h1><a class="nav-anchor" id="Fill-1" href="#Fill-1">Fill</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{Impute.Fill,Impute.Context,AbstractArray{T,1} where T}" href="#Impute.impute!-Tuple{Impute.Fill,Impute.Context,AbstractArray{T,1} where T}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">impute!(imp::Fill, ctx::Context, data::AbstractVector)</code></pre><p>Computes the fill value if <code>imp.value</code> is a <code>Function</code> (i.e., <code>imp.value(drop(copy(data)))</code>) and replaces all missing values in the <code>data</code> with that value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Fill" href="#Impute.Fill"><code>Impute.Fill</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Fill &lt;: Imputor</code></pre><p>Fills in the missing data with a specific value.</p><p><strong>Fields</strong></p><ul><li><code>value::Any</code>: A scalar missing value or a function that returns the a scalar if   passed the data with missing data removed (e.g, <code>mean</code>)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Fill-Tuple{}" href="#Impute.Fill-Tuple{}"><code>Impute.Fill</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Fill() -&gt; Fill</code></pre><p>By default <code>Fill()</code> will use the mean of the existing values as the fill value.</p></div></div></section><h1><a class="nav-anchor" id="Interpolate-1" href="#Interpolate-1">Interpolate</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Union{Tuple{T}, Tuple{Interpolate,Context,AbstractArray{#s13,1} where #s13&lt;:Union{Missing, T}}} where T" href="#Impute.impute!-Union{Tuple{T}, Tuple{Interpolate,Context,AbstractArray{#s13,1} where #s13&lt;:Union{Missing, T}}} where T"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">impute!(imp::Interpolate, ctx::Context, data::AbstractVector)</code></pre><p>Uses linear interpolation between existing elements of a vector to fill in missing data.</p><p>WARNING: Missing values at the head or tail of the array cannot be interpolated if there are no existing values on both sides. As a result, this method does not guarantee that all missing values will be imputed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Interpolate" href="#Impute.Interpolate"><code>Impute.Interpolate</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Interpolate &lt;: Imputor</code></pre><p>Performs linear interpolation between the nearest values in an vector.</p></div></div></section><h1><a class="nav-anchor" id="Last-Observation-Carried-Forward-(LOCF)-1" href="#Last-Observation-Carried-Forward-(LOCF)-1">Last Observation Carried Forward (LOCF)</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{Impute.LOCF,Impute.Context,AbstractArray{T,1} where T}" href="#Impute.impute!-Tuple{Impute.LOCF,Impute.Context,AbstractArray{T,1} where T}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">impute!(imp::LOCF, ctx::Context, data::AbstractVector)</code></pre><p>Iterates forwards through the <code>data</code> and fills missing data with the last existing observation.</p><p>WARNING: missing elements at the head of the array may not be imputed if there is no existing observation to carry forward. As a result, this method does not guarantee that all missing values will be imputed.</p><p><strong>Usage</strong></p><pre><code class="language-none"></code></pre></div></div></section><h1><a class="nav-anchor" id="Next-Observation-Carried-Backward-(NOCB)-1" href="#Next-Observation-Carried-Backward-(NOCB)-1">Next Observation Carried Backward (NOCB)</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{Impute.NOCB,Impute.Context,AbstractArray{T,1} where T}" href="#Impute.impute!-Tuple{Impute.NOCB,Impute.Context,AbstractArray{T,1} where T}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">impute!(imp::NOCB, ctx::Context, data::AbstractVector)</code></pre><p>Iterates backwards through the <code>data</code> and fills missing data with the next existing observation.</p><p>WARNING: missing elements at the tail of the array may not be imputed if there is no existing observation to carry backward. As a result, this method does not guarantee that all missing values will be imputed.</p><p><strong>Usage</strong></p><pre><code class="language-none"></code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.NOCB" href="#Impute.NOCB"><code>Impute.NOCB</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NOCB &lt;: Imputor</code></pre><p>Fills in missing data using the Next Observation Carried Backward (NOCB) approach.</p></div></div></section><h1><a class="nav-anchor" id="Chain-1" href="#Chain-1">Chain</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{Impute.Chain,Function,Union{DataFrame, AbstractArray}}" href="#Impute.impute!-Tuple{Impute.Chain,Function,Union{DataFrame, AbstractArray}}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">impute!(imp::Chain, missing::Function, data::Dataset; limit::Float64=0.1)</code></pre><p>Creates a <code>Context</code> and runs the <code>Imputor</code>s on the supplied data.</p><p><strong>Arguments</strong></p><ul><li><code>imp::Chain</code>: the chain to run</li><li><code>missing::Function</code>: the missing function to use in the <code>Context</code> to pass to the <code>Imputor</code>s</li><li><code>data::Dataset</code>: our data to impute</li><li><code>limit::Float64</code>: the missing data ration limit/threshold</li></ul><p><strong>Returns</strong></p><ul><li><code>Dataset</code>: our imputed data</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{Impute.Chain,Union{DataFrame, AbstractArray}}" href="#Impute.impute!-Tuple{Impute.Chain,Union{DataFrame, AbstractArray}}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">impute!(imp::Chain, data::Dataset; limit::Float64=0.1)</code></pre><p>Infers the missing data function from the <code>data</code> and passes that to <code>impute!(imp::Chain, missing::Function, data::Dataset; limit::Float64=0.1)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>imp::Chain</code>: the chain to run</li><li><code>data::Dataset</code>: our data to impute</li><li><code>limit::Float64</code>: the missing data ration limit/threshold</li></ul><p><strong>Returns</strong></p><ul><li><code>Dataset</code>: our imputed data</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Chain" href="#Impute.Chain"><code>Impute.Chain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Chain &lt;: Imputor</code></pre><p>Runs multiple <code>Imputor</code>s on the same data in the order they&#39;re provided.</p><p><strong>Fields</strong></p><ul><li><code>imputors::Array{Imputor}</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Chain-Tuple{Vararg{Impute.Imputor,N} where N}" href="#Impute.Chain-Tuple{Vararg{Impute.Imputor,N} where N}"><code>Impute.Chain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Chain(imputors::Imputor...) -&gt; Chain</code></pre><p>Creates a Chain using the <code>Imputor</code>s provided (ordering matters).</p></div></div></section><footer><hr/><a class="previous" href="../context/"><span class="direction">Previous</span><span class="title">Context</span></a><a class="next" href="../utils/"><span class="direction">Next</span><span class="title">Utilities</span></a></footer></article></body></html>
