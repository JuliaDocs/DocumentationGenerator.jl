<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sched.jl · Sched.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Sched.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Sched.jl</a><ul class="internal"><li><a class="toctext" href="#Install-1">Install</a></li><li><a class="toctext" href="#Usage-1">Usage</a></li><li><a class="toctext" href="#Contents-1">Contents</a></li><li><a class="toctext" href="#Syntax-1">Syntax</a></li><li><a class="toctext" href="#Package-Internals-1">Package Internals</a></li><li><a class="toctext" href="#See-also-1">See also</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Sched.jl</a></li></ul></nav><hr/><div id="topbar"><span>Sched.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Sched.jl-1" href="#Sched.jl-1">Sched.jl</a></h1><p>A <a href="https://julialang.org/">Julia</a> event scheduler inspired by <a href="https://docs.python.org/3/library/sched.html">Python sched</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sched.Sched" href="#Sched.Sched"><code>Sched.Sched</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>A generally useful event scheduler class. Each instance of this class manages its own queue. No multi-threading is implied; you are supposed to hack that yourself, or use a single instance per application. Each instance is parametrized with two functions, one that is supposed to return the current time, one that is supposed to implement a delay.    You can implement real-time scheduling by substituting time and sleep from built-in module time, or you can implement simulated time by writing your own functions.    This can also be used to integrate scheduling with STDWIN events; the delay function is allowed to modify the queue.    Time can be expressed as integers or floating point numbers, as long as it is consistent. Events are specified by tuples (time, priority, action, argument, kwargs). As in UNIX, lower priority numbers mean higher priority; in this way the queue can be maintained as a priority queue.    Execution of the event means calling the action function, passing it the argument sequence in &quot;argument&quot; (remember that in Python, multiple function arguments are be packed in a sequence) and keyword parameters in &quot;kwargs&quot;. The action function may be an instance method so it has another way to reference private data (besides global variables).</p></div></div></section><h2><a class="nav-anchor" id="Install-1" href="#Install-1">Install</a></h2><p><code>Sched</code> is a registered package. To add it to your Julia packages, simply do the following in REPL:</p><pre><code class="language-julia">Pkg.add(&quot;Sched&quot;)</code></pre><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><p><a href="sample/sample.jl">Download example</a></p><h2><a class="nav-anchor" id="Contents-1" href="#Contents-1">Contents</a></h2><ul><li><a href="#Sched.jl-1">Sched.jl</a></li><ul><li><a href="#Install-1">Install</a></li><li><a href="#Usage-1">Usage</a></li><li><a href="#Contents-1">Contents</a></li><li><a href="#Syntax-1">Syntax</a></li><li><a href="#Package-Internals-1">Package Internals</a></li><li><a href="#See-also-1">See also</a></li></ul></ul><h2><a class="nav-anchor" id="Syntax-1" href="#Syntax-1">Syntax</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sched.Scheduler" href="#Sched.Scheduler"><code>Sched.Scheduler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Scheduler(; timefunc=_time, delayfunc=sleep)</code></pre><p>Initialize a new Scheduler instance, passing optionaly the time and delay functions</p><p>The scheduler struct defines a generic interface to scheduling events.  It needs two functions to actually deal with the “outside world”</p><ul><li><p>The <code>timefunc</code> should be callable without arguments, and return a number (the “time”, in any units whatsoever). <code>timefunc</code> default is <code>UTCDateTimeFunc</code>.</p></li><li><p>The <code>delayfunc</code> function should be callable with one argument, compatible  with the output of <code>timefunc</code>, and should delay that many time units. delayfunc  will also be called with the argument 0 after each event is run to allow other threads an opportunity to run in multi-threaded applications.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sched.enterabs" href="#Sched.enterabs"><code>Sched.enterabs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">enterabs(sched, time_, priority, action, args...; kwargs...)</code></pre><p>Enter a new event in the queue at an absolute time. Returns an ID for the event which can be used to remove it, if necessary.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sched.enter" href="#Sched.enter"><code>Sched.enter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">enter(sched, delay, priority, action, args...; kwargs...)</code></pre><p>Enter a new event in the queue at a relative time. A variant of enterabs that specifies the time as a relative time. This is actually the more commonly used interface.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sched.cancel" href="#Sched.cancel"><code>Sched.cancel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cancel(sched, event)</code></pre><p>Remove an event from the queue. This must be presented the ID as returned by enter(). If the event is not in the queue, this raises ValueError.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isempty(collection) -&gt; Bool</code></pre><p>Determine whether a collection is empty (has no elements).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isempty([])
true

julia&gt; isempty([1 2 3])
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/essentials.jl#L704-L717">source</a><div><div><pre><code class="language-none">isempty(cb)</code></pre><p>Test whether the buffer is empty.</p></div></div><div><div><pre><code class="language-none">isempty(hs::HalfSpace)::Bool</code></pre><p>Return if a half-space is empty or not.</p><p><strong>Input</strong></p><ul><li><code>hs</code> – half-space</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><div><div><pre><code class="language-none">isempty(P::AbstractPolytope)::Bool</code></pre><p>Determine whether a polytope is empty.</p><p><strong>Input</strong></p><ul><li><code>P</code> – abstract polytope</li></ul><p><strong>Output</strong></p><p><code>true</code> if the given polytope contains no vertices, and <code>false</code> otherwise.</p><p><strong>Algorithm</strong></p><p>This algorithm checks whether the <code>vertices_list</code> of the given polytope is empty or not.</p></div></div><div><div><pre><code class="language-none">isempty(S::AbstractCentrallySymmetric)::Bool</code></pre><p>Return if a centrally symmetric set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><div><div><pre><code class="language-none">isempty(P::AbstractCentrallySymmetricPolytope)::Bool</code></pre><p>Return if a centrally symmetric, polytopic set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric, polytopic set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><div><div><pre><code class="language-none">isempty(∅::EmptySet)::Bool</code></pre><p>Return if the empty set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li></ul><p><strong>Output</strong></p><p><code>true</code>.</p></div></div><div><div><p>isempty(P::HPoly{N}; [solver]=GLPKSolverLP())::Bool where {N&lt;:Real}</p><p>Determine whether a polyhedron is empty.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>backend</code> – (optional, default: <code>default_polyhedra_backend(P, N)</code>)              the polyhedral computations backend</li><li><code>solver</code>  – (optional, default: <code>GLPKSolverLP()</code>) LP solver backend</li></ul><p><strong>Output</strong></p><p><code>true</code> if and only if the constraints are inconsistent.</p><p><strong>Algorithm</strong></p><p>This function uses <code>Polyhedra.isempty</code> which evaluates the feasibility of the LP whose feasible set is determined by the set of constraints and whose objective function is zero.</p><p><strong>Notes</strong></p><p>This implementation uses <code>GLPKSolverLP</code> as linear programming backend by default.</p></div></div><div><div><pre><code class="language-none">isempty(hp::Hyperplane)::Bool</code></pre><p>Return if a hyperplane is empty or not.</p><p><strong>Input</strong></p><ul><li><code>hp</code> – hyperplane</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><div><div><pre><code class="language-none">isempty(L::Line)::Bool</code></pre><p>Return if a line is empty or not.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><div><div><pre><code class="language-none">isempty(cp::CartesianProduct)::Bool</code></pre><p>Return if a Cartesian product is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the sub-blocks is empty.</p></div></div><div><div><pre><code class="language-none">isempty(cpa::CartesianProductArray)::Bool</code></pre><p>Return if a Cartesian product is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the sub-blocks is empty.</p></div></div><div><div><pre><code class="language-none">isempty(ch::ConvexHull)::Bool</code></pre><p>Return if a convex hull of two convex sets is empty or not.</p><p><strong>Input</strong></p><ul><li><code>ch</code> – convex hull</li></ul><p><strong>Output</strong></p><p><code>true</code> iff both wrapped sets are empty.</p></div></div><div><div><pre><code class="language-none">isempty(cha::ConvexHullArray)::Bool</code></pre><p>Return if a convex hull array is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are empty.</p></div></div><div><div><pre><code class="language-none">isempty(em::ExponentialMap)::Bool</code></pre><p>Return if an exponential map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>em</code> – exponential map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><div><div><pre><code class="language-none">isempty(eprojmap::ExponentialProjectionMap)::Bool</code></pre><p>Return if an exponential projection map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>eprojmap</code> – exponential projection map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><div><div><pre><code class="language-none">isempty(cap::Intersection)::Bool</code></pre><p>Return if the intersection is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the intersection is empty.</p><p><strong>Notes</strong></p><p>The result will be cached, so a second query will be fast.</p></div></div><div><div><pre><code class="language-none">isempty(lm::LinearMap)::Bool</code></pre><p>Return if a linear map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><div><div><pre><code class="language-none">isempty(ms::MinkowskiSum)::Bool</code></pre><p>Return if a Minkowski sum is empty or not.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the wrapped sets are empty.</p></div></div><div><div><pre><code class="language-none">isempty(msa::MinkowskiSumArray)::Bool</code></pre><p>Return if a Minkowski sum array is empty or not.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the wrapped sets are empty.</p></div></div><div><div><pre><code class="language-none">isempty(cms::CacheMinkowskiSum)::Bool</code></pre><p>Return if a caching Minkowski sum array is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the wrapped sets are empty.</p><p><strong>Notes</strong></p><p>Forgotten sets cannot be checked anymore. Usually they have been empty because otherwise the support vector query should have crashed before. In that case, the caching Minkowski sum should not be used further.</p></div></div><div><div><pre><code class="language-none">isempty(p::Rep, solver::MathProgBase.AbstractMathProgSolver=Polyhedra.solver(p))</code></pre><p>Check whether the polyhedron <code>p</code> is empty by using the solver <code>solver</code>.</p></div></div><div><div><pre><code class="language-none">isempty(sched) -&gt; Bool</code></pre><p>Check whether the queue is empty.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.run" href="#Base.run"><code>Base.run</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">run(command, args...; wait::Bool = true)</code></pre><p>Run a command object, constructed with backticks. Throws an error if anything goes wrong, including the process exiting with a non-zero status (when <code>wait</code> is true).</p><p>If <code>wait</code> is false, the process runs asynchronously. You can later wait for it and check its exit status by calling <code>success</code> on the returned process object.</p><p>When <code>wait</code> is false, the process&#39; I/O streams are directed to <code>devnull</code>. When <code>wait</code> is true, I/O streams are shared with the parent process. Use <a href="@ref"><code>pipeline</code></a> to control I/O redirection.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/process.jl#L647-L659">source</a><div><div><pre><code class="language-none">run(sched; blocking=true)</code></pre><p>Execute events until the queue is empty. If blocking is False executes the scheduled events due to expire soonest (if any) and then return the deadline of the next scheduled call in the scheduler. When there is a positive delay until the first event, the delay function is called and the event is left in the queue; otherwise, the event is removed from the queue and executed (its action function is called, passing it the argument).  If the delay function returns prematurely, it is simply restarted. It is legal for both the delay function and the action function to modify the queue or to raise an exception; exceptions are not caught but the scheduler&#39;s state remains well-defined so run() may be called again. A questionable hack is added to allow other threads to run: just after an event is executed, a delay of 0 is executed, to avoid monopolizing the CPU when other threads are also runnable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sched.queue" href="#Sched.queue"><code>Sched.queue</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">queue(sched)</code></pre><p>Return an ordered list of upcoming events.</p></div></div></section><h2><a class="nav-anchor" id="Package-Internals-1" href="#Package-Internals-1">Package Internals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sched.Event" href="#Sched.Event"><code>Sched.Event</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Event(time_, priority, action, args...; kwargs...)</code></pre><p>Event structure</p><ul><li><code>time_</code>: Numeric type compatible with the return value of the timefunc function passed to the constructor.&#39;</li><li><code>priority</code>: Events scheduled for the same time will be executed in the order of their priority.</li><li><code>action</code>: Executing the event means executing action(args...; kwargs...)</li><li><code>args</code>: args is a sequence holding the positional arguments for the action.</li><li><code>kwargs</code>: kwargs is a dictionary holding the keyword arguments for the action.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sched.Priority" href="#Sched.Priority"><code>Sched.Priority</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Priority(time_, priority)</code></pre><p>Priority of events</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sched.TimeFunc" href="#Sched.TimeFunc"><code>Sched.TimeFunc</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for struct that returns real-time or simulated time when called (functor)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sched.UTCDateTimeFuncStruct" href="#Sched.UTCDateTimeFuncStruct"><code>Sched.UTCDateTimeFuncStruct</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UTCDateTimeFuncStruct()</code></pre><p>Functor that return real-time as DateTime (UTC) when called</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Sched.FloatTimeFuncStruct" href="#Sched.FloatTimeFuncStruct"><code>Sched.FloatTimeFuncStruct</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FloatTimeFuncStruct()</code></pre><p>Functor that return real-time as Float when called</p></div></div></section><h2><a class="nav-anchor" id="See-also-1" href="#See-also-1">See also</a></h2><ul><li><a href="https://scls19fr.github.io/ExtensibleScheduler.jl/latest/">ExtensibleScheduler.jl</a> a more advanced and extensible <a href="http://www.julialang.org">Julia</a> events scheduler</li><li><a href="https://discourse.julialang.org/t/julia-cron-like-event-scheduler/6899">https://discourse.julialang.org/t/julia-cron-like-event-scheduler/6899</a></li></ul><footer><hr/></footer></article></body></html>
