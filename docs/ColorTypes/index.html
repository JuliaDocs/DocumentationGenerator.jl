<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · ColorTypes.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ColorTypes.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Types-available-in-ColorTypes-1">Types available in ColorTypes</a></li><li><a class="toctext" href="#The-type-hierarchy-and-abstract-types-1">The type hierarchy and abstract types</a></li><li><a class="toctext" href="#Colors-1">Colors</a></li><li><a class="toctext" href="#Grayscale-&quot;colors&quot;-1">Grayscale &quot;colors&quot;</a></li><li><a class="toctext" href="#a-name&quot;traits&quot;/aTraits-(utility-functions-for-instances-and-types)-1">&lt;a name=&quot;traits&quot;&gt;&lt;/a&gt;Traits (utility functions for instances and types)</a></li><li><a class="toctext" href="#Extending-ColorTypes-and-Colors-1">Extending ColorTypes and Colors</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ColorTypes-1" href="#ColorTypes-1">ColorTypes</a></h1><p><a href="https://travis-ci.org/JuliaGraphics/ColorTypes.jl"><img src="https://travis-ci.org/JuliaGraphics/ColorTypes.jl.svg?branch=master" alt="Build Status"/></a> <a href="http://codecov.io/github/JuliaGraphics/ColorTypes.jl?branch=master"><img src="http://codecov.io/github/JuliaGraphics/ColorTypes.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p>This &quot;minimalistic&quot; package serves as the foundation for working with colors in Julia.  It defines basic color types and their constructors, and sets up traits and <code>show</code> methods to make them easier to work with.</p><p>Of related interest is the <a href="https://github.com/JuliaGraphics/Colors.jl">Colors.jl</a> package, which provides &quot;colorimetry&quot; and conversion functions for working with colors.  You may also be interested in the <a href="https://github.com/JuliaGraphics/ColorVectorSpace.jl">ColorVectorSpace.jl</a> package, which defines mathematical operations for certain color types.  Both of these packages are based on ColorTypes, which ensures that any color objects will be broadly usable.</p><h1><a class="nav-anchor" id="Types-available-in-ColorTypes-1" href="#Types-available-in-ColorTypes-1">Types available in ColorTypes</a></h1><h2><a class="nav-anchor" id="The-type-hierarchy-and-abstract-types-1" href="#The-type-hierarchy-and-abstract-types-1">The type hierarchy and abstract types</a></h2><p>Here is the type hierarchy used in ColorTypes:</p><p><img src="images/types.png &quot;Types&quot;" alt="Types"/></p><ul><li><p><code>Colorant</code> is the general term used for any object exported by this package.  True colors are called <code>Color</code>; <code>TransparentColor</code> indicates an object that also has alpha-channel information.</p></li><li><p><code>Color{T,3}</code> is a 3-component color (like RGB = red, green, blue); <code>Color{T,1}</code> is a 1-component color, i.e., grayscale).</p></li><li><p>Most colors have both <code>AlphaColor</code> and <code>ColorAlpha</code> variants; for example, <code>RGB</code> has both <code>ARGB</code> and <code>RGBA</code>.  These indicate different underlying storage in memory: <code>AlphaColor</code> stores the alpha-channel first, then the color, whereas <code>ColorAlpha</code> stores the color first, then the alpha-channel.  Storage order can be particularly important for interfacing with certain external libraries (e.g., OpenGL and Cairo).</p></li><li><p>To support generic programming, <code>TransparentColor</code> constructors always take the alpha channel last, independent of their internal storage order. That is, one uses</p></li></ul><pre><code class="language-julia">RGBA(red, green, blue, alpha)
RGBA(RGB(red, green, blue), alpha)
ARGB(red, green, blue, alpha)       # note alpha is last
ARGB(RGB(red, green, blue), alpha)</code></pre><p>This way you can write code with a generic <code>C&lt;:Colorant</code> type and   not worry about the proper order for supplying arguments to the   constructor.  See the <a href="#traits">traits section</a> for some useful   utilities.</p><h2><a class="nav-anchor" id="Colors-1" href="#Colors-1">Colors</a></h2><h3><a class="nav-anchor" id="RGB-plus-BGR,-RGB1,-RGB4,-and-RGB24:-the-AbstractRGB-group-1" href="#RGB-plus-BGR,-RGB1,-RGB4,-and-RGB24:-the-AbstractRGB-group-1">RGB plus BGR, RGB1, RGB4, and RGB24: the AbstractRGB group</a></h3><p>The <a href="https://en.wikipedia.org/wiki/SRGB">sRGB colorspace</a>.</p><pre><code class="language-julia">struct RGB{T} &lt;: AbstractRGB{T}
    r::T # Red in [0,1]
    g::T # Green in [0,1]
    b::T # Blue in [0,1]
end</code></pre><p>RGBs may be defined with two broad number types: <code>FloatingPoint</code> and <code>FixedPoint</code>.  <code>FixedPoint</code> come from the <a href="https://github.com/JeffBezanson/FixedPointNumbers.jl"><code>FixedPointNumbers</code></a> package, and represent fractional numbers internally using integers.  For example, <code>N0f8(1)</code> creates a <code>Normed{UInt8,8}</code> (<code>N0f8</code> for short) number with value equal to <code>1.0</code> but which internally is represented as <code>0xff</code>.  This strategy ensures that <code>1</code> always means &quot;saturated color&quot;, regardless of how that value is represented. Ordinary integers should not be used, although the convenience constructor <code>RGB(1,0,0)</code> will create a value <code>RGB{N0f8}(1.0, 0.0, 0.0)</code>.</p><p>The analogous <code>BGR</code> type is defined as</p><pre><code class="language-jl">struct BGR{T} &lt;: AbstractRGB{T}
    b::T
    g::T
    r::T
end</code></pre><p>i.e., identical to <code>RGB</code> except in the opposite storage order.  One crucial point: <strong>for all <code>AbstractRGB</code> types, the constructor accepts values in the order <code>(r,g,b)</code> regardless of how they are arranged internally in memory</strong>.</p><p><code>RGB1</code> and <code>RGB4</code> seem exactly like <code>RGB</code>, but internally they insert one extra (&quot;invisible&quot;) padding element; when the element type is <code>N0f8</code>, these have favorable memory alignment for interfacing with libraries like OpenGL.</p><p>Finally, one may represent an RGB color as 8-bit values packed into a 32-bit integer:</p><pre><code class="language-julia">struct RGB24 &lt;: AbstractRGB{N0f8}
    color::UInt32
end</code></pre><p>The storage order is <code>0xAARRGGBB</code>, where <code>RR</code> means the red channel, <code>GG</code> means the green, and <code>BB</code> means the blue.  <code>AA</code> is ignored for <code>RGB24</code>; there is also an <code>ARGB32</code>, for which that byte represents alpha. Note that this type can also be constructed as <code>RGB24(0.8,0.5,0.2)</code>. However, since this type has no fields named <code>r</code>, <code>g</code>, <code>b</code>, it is better to extract values from <code>AbstractRGB</code> objects using <code>red(c)</code>, <code>green(c)</code>, <code>blue(c)</code>.</p><h3><a class="nav-anchor" id="HSV-1" href="#HSV-1">HSV</a></h3><p><a href="https://en.wikipedia.org/wiki/HSL_and_HSV">Hue-Saturation-Value</a>. A common projection of RGB to cylindrical coordinates.  This is also sometimes called &quot;HSB&quot; for Hue-Saturation-Brightness.</p><pre><code class="language-julia">struct HSV{T} &lt;: Color{T,3}
    h::T # Hue in [0,360)
    s::T # Saturation in [0,1]
    v::T # Value in [0,1]
end</code></pre><p>For HSV (and all remaining color types), <code>T</code> must be of <code>FloatingPoint</code> type, since the values range beyond what can be represented with most <code>FixedPoint</code> types.</p><h3><a class="nav-anchor" id="HSL-1" href="#HSL-1">HSL</a></h3><p><a href="https://en.wikipedia.org/wiki/HSL_and_HSV">Hue-Saturation-Lightness</a>. Another common projection of RGB to cylindrical coordinates.</p><pre><code class="language-julia">struct HSL{T} &lt;: Color{T,3}
    h::T # Hue in [0,360)
    s::T # Saturation in [0,1]
    l::T # Lightness in [0,1]
end</code></pre><h3><a class="nav-anchor" id="HSI-1" href="#HSI-1">HSI</a></h3><p>Hue, saturation, intensity, a variation of HSL and HSV commonly used in computer vision.</p><pre><code class="language-julia">struct HSI{T} &lt;: Color{T,3}
    h::T
    s::T
    i::T
end</code></pre><h3><a class="nav-anchor" id="XYZ-1" href="#XYZ-1">XYZ</a></h3><p>The <a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">XYZ colorspace</a> standardized by the CIE in 1931, based on experimental measurements of color perception culminating in the CIE standard observer (see <code>Colors.jl</code>&#39;s <code>cie_color_match</code> function).</p><pre><code class="language-julia">struct XYZ{T} &lt;: Color{T,3}
    x::T
    y::T
    z::T
end</code></pre><p>This colorspace is noteworthy because it is linear–-values may be added or scaled as if they form a vector space.  See further discussion in the ColorVectorSpace.jl package.</p><h3><a class="nav-anchor" id="xyY-1" href="#xyY-1">xyY</a></h3><p>The xyY colorspace is another CIE standardized color space, based directly off of a transformation from XYZ. It was developed specifically because the xy chromaticity space is invariant to the lightness of the patch.</p><pre><code class="language-julia">struct xyY{T} &lt;: Color{T,3}
    x::T
    y::T
    Y::T
end</code></pre><h3><a class="nav-anchor" id="Lab-1" href="#Lab-1">Lab</a></h3><p>A perceptually uniform colorspace standardized by the CIE in 1976. See also LUV, the associated colorspace standardized the same year.</p><pre><code class="language-julia">struct Lab{T} &lt;: Color{T,3}
    l::T # Luminance in approximately [0,100]
    a::T # Red/Green
    b::T # Blue/Yellow
end</code></pre><h3><a class="nav-anchor" id="Luv-1" href="#Luv-1">Luv</a></h3><p>A perceptually uniform colorspace standardized by the CIE in 1976. See also LAB, a similar colorspace standardized the same year.</p><pre><code class="language-julia">struct Luv{T} &lt;: Color{T,3}
    l::T # Luminance
    u::T # Red/Green
    v::T # Blue/Yellow
end</code></pre><h3><a class="nav-anchor" id="LCHab-1" href="#LCHab-1">LCHab</a></h3><p>The LAB colorspace reparameterized using cylindrical coordinates.</p><pre><code class="language-julia">struct LCHab{T} &lt;: Color{T,3}
    l::T # Luminance in [0,100]
    c::T # Chroma
    h::T # Hue in [0,360)
end</code></pre><h3><a class="nav-anchor" id="LCHuv-1" href="#LCHuv-1">LCHuv</a></h3><p>The LUV colorspace reparameterized using cylindrical coordinates.</p><pre><code class="language-julia">struct LCHuv{T} &lt;: Color{T,3}
    l::T # Luminance
    c::T # Chroma
    h::T # Hue
end</code></pre><h3><a class="nav-anchor" id="DIN99-1" href="#DIN99-1">DIN99</a></h3><p>The DIN99 uniform colorspace as described in the DIN 6176 specification.</p><pre><code class="language-julia">struct DIN99{T} &lt;: Color{T,3}
    l::T # L99 (Lightness)
    a::T # a99 (Red/Green)
    b::T # b99 (Blue/Yellow)
end</code></pre><h3><a class="nav-anchor" id="DIN99d-1" href="#DIN99d-1">DIN99d</a></h3><p>The DIN99d uniform colorspace is an improvement on the DIN99 color space that adds a correction to the X tristimulus value in order to emulate the rotation term present in the DeltaE2000 equation.</p><pre><code class="language-julia">struct DIN99d{T} &lt;: Color{T,3}
    l::T # L99d (Lightness)
    a::T # a99d (Reddish/Greenish)
    b::T # b99d (Bluish/Yellowish)
end</code></pre><h3><a class="nav-anchor" id="DIN99o-1" href="#DIN99o-1">DIN99o</a></h3><p>Revised version of the DIN99 uniform colorspace with modified coefficients for an improved metric.  Similar to DIN99d X correction and the DeltaE2000 rotation term, DIN99o achieves comparable results by optimized <code>a*/b*</code> rotation and chroma compression terms.</p><pre><code class="language-julia">struct DIN99o{T} &lt;: Color{T,3}
    l::T # L99o (Lightness)
    a::T # a99o (Red/Green)
    b::T # b99o (Blue/Yellow)
end</code></pre><h3><a class="nav-anchor" id="LMS-1" href="#LMS-1">LMS</a></h3><p>Long-Medium-Short cone response values. Multiple methods of converting to LMS space have been defined. Here the <a href="https://en.wikipedia.org/wiki/CIECAM02#CAT02">CAT02</a> chromatic adaptation matrix is used.</p><pre><code class="language-julia">struct LMS{T} &lt;: Color{T,3}
    l::T # Long
    m::T # Medium
    s::T # Short
end</code></pre><p>Like <code>XYZ</code>, <code>LMS</code> is a linear color space.</p><h3><a class="nav-anchor" id="YIQ-(NTSC)-1" href="#YIQ-(NTSC)-1">YIQ (NTSC)</a></h3><p>A color-encoding format used by the NTSC broadcast standard.</p><pre><code class="language-julia">struct YIQ{T} &lt;: Color{T,3}
    y::T
    i::T
    q::T
end</code></pre><h3><a class="nav-anchor" id="Y&#39;CbCr-1" href="#Y&#39;CbCr-1">Y&#39;CbCr</a></h3><p>A color-encoding format common in video and digital photography.</p><pre><code class="language-jl">struct YCbCr{T} &lt;: Color{T,3}
    y::T
    cb::T
    cr::T
end</code></pre><h2><a class="nav-anchor" id="Grayscale-&quot;colors&quot;-1" href="#Grayscale-&quot;colors&quot;-1">Grayscale &quot;colors&quot;</a></h2><h3><a class="nav-anchor" id="Gray-1" href="#Gray-1">Gray</a></h3><p><code>Gray</code> is a simple wrapper around a number:</p><pre><code class="language-jl">struct Gray{T} &lt;: AbstractGray{T}
    val::T
end</code></pre><p>In many situations you don&#39;t need a <code>Gray</code> wrapper, but there are times when it can be helpful to clarify meaning or assist with dispatching to appropriate methods.  It is also present for consistency with the two corresponding grayscale-plus-transparency types, <code>AGray</code> and <code>GrayA</code>.</p><h3><a class="nav-anchor" id="Gray24-and-AGray32-1" href="#Gray24-and-AGray32-1">Gray24 and AGray32</a></h3><p><code>Gray24</code> is a grayscale value encoded as a <code>UInt32</code>:</p><pre><code class="language-jl">struct Gray24 &lt;: AbstractGray{N0f8}
    color::UInt32
end</code></pre><p>The storage format is <code>0xAAIIIIII</code>, where each <code>II</code> pair (I=intensity) must be identical.  The <code>AA</code> is ignored, but in the corresponding <code>AGray32</code> type it encodes alpha.</p><h2><a class="nav-anchor" id="a-name&quot;traits&quot;/aTraits-(utility-functions-for-instances-and-types)-1" href="#a-name&quot;traits&quot;/aTraits-(utility-functions-for-instances-and-types)-1">&lt;a name=&quot;traits&quot;&gt;&lt;/a&gt;Traits (utility functions for instances and types)</a></h2><p>One of the nicest things about this package is that it provides a rich set of trait-functions for working with color types:</p><ul><li><p><code>eltype(c)</code> extracts the underlying element type, e.g., <code>Float32</code></p></li><li><p><code>length(c)</code> extracts the number of components (including <code>alpha</code>, if present)</p></li><li><p><code>alphacolor(c)</code> and <code>coloralpha(c)</code> convert a <code>Color</code> to an object with transparency (either <code>ARGB</code> or <code>RGBA</code>, respectively).</p></li><li><p><code>color_type(c)</code> extracts the opaque (color-only) type of the object (e.g., <code>RGB{N0f8}</code> from an object of type <code>ARGB{N0f8}</code>).</p></li><li><p><code>base_color_type(c)</code> and <code>base_colorant_type(c)</code> extract type information and discard the element type (e.g., <code>base_colorant_type(ARGB{N0f8})</code> yields <code>ARGB</code>)</p></li><li><p><code>ccolor(Cdest, Csrc)</code> helps pick a concrete element type for methods where the output may be left unstated, e.g., <code>convert(RGB, c)</code> rather than <code>convert(RGB{N0f8}, c)</code>.</p></li></ul><p>All of these methods are individually documented (typically with greater detail); just type <code>?ccolor</code> at the REPL.</p><h3><a class="nav-anchor" id="Getters-1" href="#Getters-1">Getters</a></h3><ul><li><p><code>red</code>, <code>green</code>, <code>blue</code> extract channels from <code>AbstractRGB</code> types; <code>gray</code> extracts the intensity from a grayscale object</p></li><li><p><code>alpha</code> extracts the alpha channel from any <code>Color</code> object (returning 1 if there is no alpha channel)</p></li><li><p><code>comp1</code>, <code>comp2</code>, and <code>comp3</code> extract color components in the order expected by the constructor</p></li></ul><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><ul><li><p><code>mapc(f, c)</code> executes the function <code>f</code> on each color channel of <code>c</code>, returning a new color in the same colorspace.</p></li><li><p><code>reducec(op, v0, c)</code> returns a single number based on a binary operator <code>op</code> across the color channels of <code>c</code>. <code>v0</code> is the initial value.</p></li><li><p><code>mapreducec(f, op, v0, c)</code> is similar to <code>reducec</code> except it applies <code>f</code> to each color channel before combining values with <code>op</code>.</p></li></ul><h2><a class="nav-anchor" id="Extending-ColorTypes-and-Colors-1" href="#Extending-ColorTypes-and-Colors-1">Extending ColorTypes and Colors</a></h2><p>In most cases, adding a new color space is quite straightforward:</p><ul><li>Add your new type to <a href="src/types.jl"><code>types.jl</code></a>, following the model of the other color types;</li><li>Add the type to the list of exports in <a href="src/ColorTypes.jl"><code>ColorTypes.jl</code></a>;</li><li>In the Colors package, add <a href="https://github.com/JuliaGraphics/Colors.jl/blob/master/src/conversions.jl">conversions</a> to and from your new colorspace.</li></ul><p>In special cases, there may be other considerations:</p><ul><li>For RGB-related types, 0 means &quot;black&quot; and 1 means &quot;saturated.&quot; If your type has unusual numeric interpretation, you may need to add a new number type to <a href="https://github.com/JeffBezanson/FixedPointNumbers.jl">FixedPointNumbers</a> and set up appropriate <code>eltype_default</code> and <code>eltype_ub</code> traits.</li><li>If your type has extra fields, check the &quot;Generated code&quot; section of <code>types.jl</code> carefully. You may need to define a <code>colorfields</code> function and/or call <code>@make_constructors</code> or <code>@make_alpha</code> manually.</li></ul><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
