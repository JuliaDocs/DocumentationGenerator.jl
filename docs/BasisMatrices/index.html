<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · BasisMatrices.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BasisMatrices.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Quick-(and-incomplete-intro)-1">Quick (and incomplete intro)</a></li><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Basic-Overview-of-Julian-API-1">Basic Overview of Julian API</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="BasisMatrices-1" href="#BasisMatrices-1">BasisMatrices</a></h1><p><a href="https://travis-ci.org/QuantEcon/BasisMatrices.jl"><img src="https://travis-ci.org/QuantEcon/BasisMatrices.jl.svg?branch=master" alt="Build Status"/></a> <a href="http://codecov.io/github/QuantEcon/BasisMatrices.jl?branch=master"><img src="http://codecov.io/github/QuantEcon/BasisMatrices.jl/coverage.svg?branch=master" alt="codecov.io"/></a> <a href="https://coveralls.io/github/QuantEcon/BasisMatrices.jl?branch=master"><img src="https://coveralls.io/repos/QuantEcon/BasisMatrices.jl/badge.svg?branch=master&amp;service=github" alt="Coverage Status"/></a></p><p>Portions of this library are inspired by the <a href="http://www4.ncsu.edu/~pfackler/compecon/toolbox.html">CompEcon Matlab toolbox</a> by Paul Fackler and Mario Miranda. The original Matlab code was written to accompany the publication</p><blockquote><p>Miranda, Mario J., and Paul L. Fackler. Applied computational economics and finance. MIT press, 2004.</p></blockquote><p>The portions of this package that are based on their code have been licensed with their permission.</p><h2><a class="nav-anchor" id="Quick-(and-incomplete-intro)-1" href="#Quick-(and-incomplete-intro)-1">Quick (and incomplete intro)</a></h2><h3><a class="nav-anchor" id="Matlab-esque-interface-1" href="#Matlab-esque-interface-1">Matlab-esque interface</a></h3><p>For an API similar to the original <a href="http://www4.ncsu.edu/~pfackler/compecon/toolbox.html">CompEcon Matlab package</a> by Miranda and Fackler, please see the <a href="https://github.com/QuantEcon/CompEcon.jl">CompEcon.jl</a> package.</p><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>Here&#39;s an example of how to use the Julia-based API to set up multi-dimensional basis matrix and work with it.</p><pre><code class="language-julia">ygrid0 = linspace(-4, 4, 10)
agrid0 = linspace(0.0.^0.4, 100.0.^0.4, 25).^(1/0.4)

# method one, using the Basis constructor multiple times
basis = Basis(SplineParams(agrid0, 0, 3),  # cubic spline
              SplineParams(ygrid0, 0, 1))  # linear

# method two, constructing separately, then calling `Basis` with the two
a_basis = Basis(SplineParams(agrid0, 0, 3))
y_basis = Basis(SplineParams(ygrid0, 0, 1))
basis = Basis(a_basis, y_basis)

# Construct state vector (matrix). Note that for higher order splines points
# are added to the input vector, so let&#39;s extract the actual grid points used
# from the second argument
S, (agrid, ygrid) = nodes(basis)

# construct basis matrix and its lu-factorization for very fast inversion
# NOTE: I am doing this in a round-about way. I could have just done
#       Φ = BasisMatrix(basis), but doing it this way gives me the direct
#       representation so I get Φ_y without repeating any calculations
Φ_direct = BasisMatrix(basis, Direct(), S, [0 0])
Φ_y = Φ_direct.vals[2]
Φ = convert(Expanded, Φ_direct, [0 0]).vals[1]
lu_Φ = lufact(Φ)</code></pre><h2><a class="nav-anchor" id="Basic-Overview-of-Julian-API-1" href="#Basic-Overview-of-Julian-API-1">Basic Overview of Julian API</a></h2><p>This section provides a sketch of the type based Julian API.</p><h3><a class="nav-anchor" id="Theoretical-Foundation-1" href="#Theoretical-Foundation-1">Theoretical Foundation</a></h3><p>To understand the Julian API and type system, we first need to understand the fundamental theory behind the interpolation scheme implemented here. Interpolation in BasisMatrices is built around three key concepts:</p><ol><li>An functional <code>Basis</code>: for each dimension, the basis specifies<ul><li>family of basis function (B spline, Chebyshev polynomials, ect.)</li><li>domain (bounds)</li><li>interpolation nodes (grid on domain)</li></ul></li><li>A <code>BasisMatrix</code>:<ul><li>Represents the evaluation of basis functions at the interpolation nodes</li><li>Constructed one dimension at a time, then combined with tensor product</li></ul></li><li>A coefficient vector: used to map from domain of the <code>Basis</code> into real line</li></ol><h3><a class="nav-anchor" id="Core-types-1" href="#Core-types-1">Core types</a></h3><p>Functionality implemented around 5 core types (or type families) that relate closely to the theoretical concepts outlined above.</p><h4><a class="nav-anchor" id="Representing-the-Basis-1" href="#Representing-the-Basis-1">Representing the <code>Basis</code></a></h4><p>The first two groups of type are helper types used to facilitate construction of the <code>Basis</code>. They are the <code>BasisFamily</code> and the <code>BasisParams</code> types:</p><p>First is the <code>BasisFamily</code>:</p><pre><code class="language-julia">abstract type BasisFamily end
struct Cheb &lt;: BasisFamily end
struct Lin &lt;: BasisFamily end
struct Spline &lt;: BasisFamily end

abstract type BasisParams end
mutable struct ChebParams &lt;: BasisParams
    n::Int
    a::Float64
    b::Float64
end

mutable struct SplineParams &lt;: BasisParams
    breaks::Vector{Float64}
    evennum::Int
    k::Int
end

mutable struct LinParams &lt;: BasisParams
    breaks::Vector{Float64}
    evennum::Int
end</code></pre><p><code>BasisFamily</code> is an abstract type, whose subtypes are singletons that specify the class of functions in the basis.</p><p><code>BasisParams</code> is an abstract type, whose subtypes are type types that hold all information needed to construct the Basis of a particular class</p><p>Then we have the central <code>Basis</code> type:</p><pre><code class="language-julia">mutable struct Basis{N,TP&lt;:Tuple}
    params::TP     # params to construct basis
end</code></pre><p>The <code>params</code> field of this type contains an <code>N</code> element tuple, where each element is a subtype of <code>BasisParams</code>. This represents an <code>N</code> dimensional basis.</p><p>The <code>Basis</code> has support for the following methods:</p><ul><li>A whole slew of constructors</li><li><code>getindex(b::Basis, i::Int)</code>: which extracts the univariate <code>Basis</code> along the <code>i</code>th dimension</li><li><code>ndims</code>: The number of dimensions</li><li><code>length</code>: the product of the <code>n</code> field</li><li><code>size(b::Basis, i::Int)</code>: The <code>i</code>th element of the <code>n</code> field (number of basis functions in dimension <code>i</code>)</li><li><code>size(b::Basis)</code>: <code>b.n</code> as a tuple instead of a vector (similar to <code>size(a::Array)</code>)</li><li><code>==</code>: test two basis for equality</li><li><code>nodes(b::Basis)-&gt;(Matrix, Vector{Vector{Float64}})</code>: the interpolation nodes. the first element is the tensor product of all dimensions, second element is a vector of vectors, where the <code>i</code>th element contains the nodes along dimension <code>i</code>.</li><li><code>min</code> and <code>max</code> gives an <code>N</code> element tuple of the lower and upper bounds of the domain in each dimension.</li></ul><h4><a class="nav-anchor" id="BasisMatrix-representation-1" href="#BasisMatrix-representation-1"><code>BasisMatrix</code> representation</a></h4><p>Next we turn to representing the <code>BasisMatrix</code>, which is responsible for keeping track of the basis functions evaluated at the interpolation nodes. To keep track of this representation, we have another family of helper types:</p><pre><code class="language-julia">abstract type AbstractBasisMatrixRep end
const ABSR = AbstractBasisMatrixRep

struct Tensor &lt;: ABSR end
struct Direct &lt;: ABSR end
struct Expanded &lt;: ABSR end</code></pre><p><code>AbstractBasisMatrixRep</code> is an abstract types, whose subtypes are singletons that specify how the basis matrices are stored. To understand how they are different, we need to see the structure of the <code>BasisMatrix</code> type:</p><pre><code class="language-julia">mutable struct BasisMatrix{BST&lt;:ABSR, TM&lt;:AbstractMatrix}
    order::Matrix{Int}
    vals::Matrix{TM}
end</code></pre><p>The <code>order</code> field keeps track of what order of derivative or integral the arrays inside <code>vals</code> correspond to.</p><p>The content inside <code>vals</code> will vary based on the type Parameter <code>BST&lt;:AbstractBasisMatrixRep</code>:</p><ol><li>for <code>BST==Tensor</code> <code>vals</code> will store the evaluation of the basis functions at each of the integration nodes independently. Thus, the <code>[d, i]</code> element will be the derivative order <code>d</code> Basis at the interpolation nodes along the <code>i</code>th dimension (each column is a basis function, each row is an interpolation node). This is the most compact and memory efficient representation</li><li>For <code>BST==Direct</code> <code>vals</code> will expand along the first dimension (rows) of the array so that for each <code>i</code>, the <code>[d, i]</code> element will have <code>length(basis)</code> rows and <code>basis.n[i]</code> (modulo loss or addition of basis functions from derivative/integral operators.)</li><li>For <code>BST==Expanded</code> <code>vals</code> will be expanded along both the rows and the columns and will contain a single <code>Matrix</code> for each desired derivative order. This format is the least memory efficient, but simplest conceptually for thinking about how to compute a coefficient vector (if <code>y</code> is <code>f(x)</code> then <code>coefs[d] = b.vals[d] \ y</code>)</li></ol><p>See the file <a href="https://github.com/QuantEcon/BasisMatrices.jl/blob/master/demo/basis_mat_formats.jl">demo/basis<em>mat</em>formats.jl</a> for a more detailed description of the basis matrix formats.</p><h4><a class="nav-anchor" id="Convenience-Interpoland-type-1" href="#Convenience-Interpoland-type-1">Convenience <code>Interpoland</code> type</a></h4><p>Finally the convenient <code>Interpoland</code> type:</p><pre><code class="language-julia">mutable struct Interpoland{TB&lt;:Basis,TC&lt;:AbstractArray,TBM&lt;:BasisMatrix{Tensor}}
    basis::TB  # the basis -- can&#39;t change
    coefs::TC  # coefficients -- might change
    bmat::TBM  # BasisMatrix at nodes of `b` -- can&#39;t change
end</code></pre><p>The main purpose of this type is to keep track of the coefficient vector and the <code>Basis</code> so the user doesn&#39;t have to carry both of them around. It also holds a <code>BasisMatrix</code> for the evaluation of the basis matrices at the interpolation nodes. This means that if the coefficient vector needs to be updated, this <code>BasisMatrix</code> will not be re-computed.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
