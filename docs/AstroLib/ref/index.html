<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · AstroLib</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="AstroLib logo"/></a><h1>AstroLib</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li class="current"><a class="toctext" href>Reference</a><ul class="internal"><li><a class="toctext" href="#Data-types-1">Data types</a></li><li><a class="toctext" href="#Functions-organized-by-category-1">Functions organized by category</a></li><li><a class="toctext" href="#Types-and-functions-organized-alphabetically-1">Types and functions organized alphabetically</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Reference</a></li></ul></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h1><h2><a class="nav-anchor" id="Data-types-1" href="#Data-types-1">Data types</a></h2><h3><a class="nav-anchor" id="Observatory-1" href="#Observatory-1">Observatory</a></h3><p><code>AstroLib.jl</code> defines a new <code>Observatory</code> type. This can be used to define a new object holding information about an observing site. It is a [composite type] whose fields are</p><ul><li><code>name</code> (<code>String</code> type): the name of the site</li><li><code>latitude</code> (<code>Float64</code> type): North-ward latitude of the site in degrees</li><li><code>longitude</code> (<code>Float64</code> type): East-ward longitude of the site in degrees</li><li><code>altitude</code> (<code>Float64</code> type): altitude of the site in meters</li><li><code>tz</code> (<code>Float64</code> type): the number of hours of offset from UTC</li></ul><p>The type constructor <code>Observatory</code> can be used to create a new <code>Observatory</code> object. Its syntax is</p><pre><code class="language-julia">Observatory(name, lat, long, alt, tz)</code></pre><p><code>name</code> should be a string; <code>lat</code>, <code>long</code>, and <code>tz</code> should be anything that can be converted to a floating number with <code>ten</code> function; <code>alt</code> should be a real number.</p><p>A predefined list of some observing sites is provided with <code>AstroLib.observatories</code> constant. It is a dictionary whose keys are the abbreviated names of the observatories. For example, you can access information of the European Southern Observatory with</p><pre><code class="language-julia">julia&gt; obs = AstroLib.observatories[&quot;eso&quot;]
Observatory: European Southern Observatory
latitude:    -29.256666666666668°N
longitude:   -70.73°E
altitude:    2347.0 m
time zone:   UTC-4

julia&gt; obs.longitude
-70.73</code></pre><p>You can list all keys of the dictionary with</p><pre><code class="language-julia">keys(AstroLib.observatories)</code></pre><p>Feel free to contribute new sites or adjust information of already present ones.</p><h3><a class="nav-anchor" id="Planet-1" href="#Planet-1">Planet</a></h3><p>The package provides <code>Planet</code> type to hold information about Solar System planets. Its fields are</p><ul><li>Designation:<ul><li><code>name</code>: the name</li></ul></li><li>Physical characteristics:<ul><li><code>radius</code>: mean radius in meters</li><li><code>eqradius</code>: equatorial radius in meters</li><li><code>polradius</code>: polar radius in meters</li><li><code>mass</code>: mass in kilogram</li></ul></li><li>Orbital characteristics (epoch J2000):<ul><li><code>ecc</code>: eccentricity of the orbit</li><li><code>axis</code>: semi-major axis of the orbit in meters</li><li><code>period</code>: sidereal orbital period in seconds</li></ul></li></ul><p>The constructor has this syntax:</p><pre><code class="language-julia">Planet(name, radius, eqradius, polradius, mass, ecc, axis, period)</code></pre><p>The list of Solar System planets, from Mercury to Pluto, is available with <code>AstroLib.planets</code> dictionary. The keys of this dictionary are the lowercase names of the planets. For example:</p><pre><code class="language-julia">julia&gt; AstroLib.planets[&quot;mercury&quot;]
Planet:            Mercury
mean radius:       2.4397e6 m
equatorial radius: 2.4397e6 m
polar radius:      2.4397e6 m
mass:              3.3011e23 kg
eccentricity:      0.20563069
semi-major axis:   5.790905e10 m
period:            5.790905e10 s

julia&gt; AstroLib.planets[&quot;mars&quot;].eqradius
3.3962e6

julia&gt; AstroLib.planets[&quot;saturn&quot;].mass
5.6834e25</code></pre><h2><a class="nav-anchor" id="Functions-organized-by-category-1" href="#Functions-organized-by-category-1">Functions organized by category</a></h2><h3><a class="nav-anchor" id="Coordinates-and-positions-1" href="#Coordinates-and-positions-1">Coordinates and positions</a></h3><p><a href="#AstroLib.adstring-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractFloat"><code>adstring()</code></a>, <a href="#AstroLib.aitoff-Tuple{Real,Real}"><code>aitoff()</code></a>, <a href="#AstroLib.altaz2hadec-Tuple{Real,Real,Real}"><code>altaz2hadec()</code></a>, <a href="#AstroLib.baryvel-Tuple{Real}"><code>baryvel()</code></a>, <a href="#AstroLib.bprecess"><code>bprecess()</code></a>, <a href="#AstroLib.co_aberration"><code>co_aberration()</code></a>, <a href="#AstroLib.co_nutate-Tuple{Real,Real,Real}"><code>co_nutate()</code></a>, <a href="#AstroLib.co_refract"><code>co_refract()</code></a>, <a href="#AstroLib.eci2geo-NTuple{4,Real}"><code>eci2geo()</code></a>, <a href="#AstroLib.eq2hor"><code>eq2hor()</code></a>, <a href="#AstroLib.eqpole-Tuple{Real,Real}"><code>eqpole()</code></a>, <a href="#AstroLib.euler-Tuple{Real,Real,Integer}"><code>euler()</code></a>, <a href="#AstroLib.gcirc-Tuple{Integer,Real,Real,Real,Real}"><code>gcirc()</code></a>, <a href="#AstroLib.geo2eci-NTuple{4,Real}"><code>geo2eci()</code></a>, <a href="#AstroLib.geo2geodetic-NTuple{5,Real}"><code>geo2geodetic()</code></a>, <a href="#AstroLib.geo2mag"><code>geo2mag()</code></a>, <a href="#AstroLib.geodetic2geo-NTuple{5,Real}"><code>geodetic2geo()</code></a>, <a href="#AstroLib.hadec2altaz-Tuple{Real,Real,Real}"><code>hadec2altaz()</code></a>, <a href="#AstroLib.helio_rv"><code>helio_rv()</code></a>, <a href="#AstroLib.helio"><code>helio()</code></a>, <a href="#AstroLib.hor2eq"><code>hor2eq()</code></a>, <a href="#AstroLib.jprecess"><code>jprecess()</code></a>, <a href="#AstroLib.mag2geo"><code>mag2geo()</code></a>, <a href="#AstroLib.mean_obliquity-Tuple{Real}"><code>mean_obliquity()</code></a>, <a href="#AstroLib.planet_coords-Tuple{Real,Integer}"><code>planet_coords()</code></a>, <a href="#AstroLib.polrec-Tuple{Real,Real}"><code>polrec()</code></a>, <a href="#AstroLib.posang-Tuple{Integer,Real,Real,Real,Real}"><code>posang()</code></a>, <a href="#AstroLib.precess-NTuple{4,Real}"><code>precess()</code></a>, <a href="#AstroLib.precess_cd"><code>precess_cd()</code></a>, <a href="#AstroLib.precess_xyz-NTuple{5,Real}"><code>precess_xyz()</code></a>, <a href="#AstroLib.premat-Tuple{Real,Real}"><code>premat()</code></a>, <a href="#AstroLib.radec-Tuple{Real,Real}"><code>radec()</code></a>, <a href="#AstroLib.recpol-Tuple{Real,Real}"><code>recpol()</code></a>, <a href="#AstroLib.true_obliquity-Tuple{Real}"><code>true_obliquity()</code></a>, <a href="#AstroLib.zenpos"><code>zenpos()</code></a></p><h3><a class="nav-anchor" id="Time-and-date-1" href="#Time-and-date-1">Time and date</a></h3><p><a href="#AstroLib.ct2lst-Tuple{Real,Real}"><code>ct2lst()</code></a>, <a href="#AstroLib.daycnv"><code>daycnv()</code></a>, <a href="#AstroLib.get_date-Tuple{Dates.DateTime,Bool,Bool}"><code>get_date()</code></a>, <a href="#AstroLib.get_juldate-Tuple{}"><code>get_juldate()</code></a>, <a href="#AstroLib.helio_jd-Tuple{Real,Real,Real}"><code>helio_jd()</code></a>, <a href="#AstroLib.jdcnv"><code>jdcnv()</code></a>, <a href="#AstroLib.juldate-Tuple{Dates.DateTime}"><code>juldate()</code></a>, <a href="#AstroLib.month_cnv-Tuple{Integer}"><code>month_cnv()</code></a>, <a href="#AstroLib.nutate-Tuple{Real}"><code>nutate()</code></a>, <a href="#AstroLib.ydn2md-Tuple{Integer,Integer}"><code>ydn2md()</code></a>, <a href="#AstroLib.ymd2dn"><code>ymd2dn()</code></a></p><h3><a class="nav-anchor" id="Moon-and-sun-1" href="#Moon-and-sun-1">Moon and sun</a></h3><p><a href="#AstroLib.moonpos-Tuple{Real}"><code>moonpos()</code></a>, <a href="#AstroLib.mphase-Tuple{Real}"><code>mphase()</code></a>, <a href="#AstroLib.sunpos-Tuple{Real}"><code>sunpos()</code></a>, <a href="#AstroLib.xyz"><code>xyz()</code></a></p><h3><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h3><p><a href="#AstroLib.airtovac-Tuple{Real}"><code>airtovac()</code></a>, <a href="#AstroLib.calz_unred"><code>calz_unred()</code></a>, <a href="#AstroLib.deredd-NTuple{5,Real}"><code>deredd()</code></a>, <a href="#AstroLib.flux2mag"><code>flux2mag()</code></a>, <a href="#AstroLib.gal_uvw-NTuple{6,Real}"><code>gal_uvw()</code></a>, <a href="#AstroLib.imf-Tuple{AbstractArray{#s757,1} where #s757&lt;:Real,AbstractArray{#s756,1} where #s756&lt;:Real,AbstractArray{#s755,1} where #s755&lt;:Real}"><code>imf()</code></a>, <a href="#AstroLib.ismeuv"><code>ismeuv()</code></a>, <a href="#AstroLib.kepler_solver-Tuple{Real,Real}"><code>kepler_solver()</code></a>, <a href="#AstroLib.lsf_rotate"><code>lsf_rotate()</code></a>, <a href="#AstroLib.mag2flux"><code>mag2flux()</code></a>, <a href="#AstroLib.paczynski-Tuple{Real}"><code>paczynski()</code></a>, <a href="#AstroLib.planck_freq-Tuple{Real,Real}"><code>planck_freq()</code></a>, <a href="#AstroLib.planck_wave-Tuple{Real,Real}"><code>planck_wave()</code></a>, <a href="#AstroLib.rad2sec-Tuple{Real}"><code>rad2sec()</code></a>, <a href="#AstroLib.rhotheta-NTuple{8,Real}"><code>rhotheta()</code></a>, <a href="#AstroLib.sec2rad-Tuple{Real}"><code>sec2rad()</code></a>, <a href="#AstroLib.sixty-Tuple{Real}"><code>sixty()</code></a>, <a href="#AstroLib.sphdist-NTuple{4,Real}"><code>sphdist()</code></a>, <a href="#AstroLib.ten"><code>ten()</code></a>, <a href="#AstroLib.tic_one"><code>tic_one()</code></a>, <a href="#AstroLib.ticpos-Tuple{Real,Real,Real}"><code>ticpos()</code></a>, <a href="#AstroLib.tics"><code>tics()</code></a>, <a href="#AstroLib.trueanom-Tuple{Real,Real}"><code>trueanom()</code></a>, <a href="#AstroLib.uvbybeta"><code>uvbybeta()</code></a>, <a href="#AstroLib.vactoair-Tuple{Real}"><code>vactoair()</code></a></p><h3><a class="nav-anchor" id="Miscellaneous-(non-astronomy)-functions-1" href="#Miscellaneous-(non-astronomy)-functions-1">Miscellaneous (non-astronomy) functions</a></h3><p><a href="#AstroLib.ordinal-Tuple{Integer}"><code>ordinal()</code></a></p><h2><a class="nav-anchor" id="Types-and-functions-organized-alphabetically-1" href="#Types-and-functions-organized-alphabetically-1">Types and functions organized alphabetically</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.Observatory" href="#AstroLib.Observatory"><code>AstroLib.Observatory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type holding information about an observing site.  Its fields are:</p><ul><li><code>name</code>: the name of the site</li><li><code>latitude</code>: North-ward latitude of the site in degrees</li><li><code>longitude</code>: East-ward longitude of the site in degrees</li><li><code>altitude</code>: altitude of the site in meters</li><li><code>tz</code>: the number of hours of offset from UTC</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.Planet" href="#AstroLib.Planet"><code>AstroLib.Planet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type holding information about a planet.  Its fields are:</p><p>Designation:</p><ul><li><code>name</code>: the name</li></ul><p>Physical characteristics:</p><ul><li><code>radius</code>: mean radius in meters</li><li><code>eqradius</code>: equatorial radius in meters</li><li><code>polradius</code>: polar radius in meters</li><li><code>mass</code>: mass in kilogram</li></ul><p>Orbital characteristics (epoch J2000):</p><ul><li><code>ecc</code>: eccentricity of the orbit</li><li><code>axis</code>: semi-major axis of the orbit in meters</li><li><code>period</code>: sidereal orbital period in seconds</li></ul><p>Position characteristics (epoch J2000):</p><ul><li><code>inc</code>: inclination in degrees</li><li><code>asc_long</code>: longitude of the ascending node in degrees</li><li><code>per_long</code>: longitude of perihelion in degrees</li><li><code>mean_long</code>: mean longitude in degrees</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.adstring-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractFloat" href="#AstroLib.adstring-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractFloat"><code>AstroLib.adstring</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">adstring(ra::Real, dec::Real[, precision::Int=2, truncate::Bool=true]) -&gt; string
adstring([ra, dec]) -&gt; string
adstring(dec) -&gt; string
adstring([ra], [dec]) -&gt; [&quot;string1&quot;, &quot;string2&quot;, ...]</code></pre><p><strong>Purpose</strong></p><p>Returns right ascension and declination as string(s) in sexagesimal format.</p><p><strong>Explanation</strong></p><p>Takes right ascension and declination expressed in decimal format, converts them to sexagesimal and return a formatted string.  The precision of right ascension and declination can be specified.</p><p><strong>Arguments</strong></p><p>Arguments of this function are:</p><ul><li><code>ra</code>: right ascension in decimal degrees.  It is converted to hours before printing.</li><li><code>dec</code>: declination in decimal degrees.</li></ul><p>The function can be called in different ways:</p><ul><li>Two numeric arguments: first is <code>ra</code>, the second is <code>dec</code>.</li><li>An iterable (array, tuple) of two elements: <code>(ra, dec)</code>.</li><li>One numeric argument: it is assumed only <code>dec</code> is provided.</li></ul><p>Optional keywords affecting the output format are always available:</p><ul><li><code>precision</code> (optional integer keyword): specifies the number of digits of declination seconds.  The number of digits for right ascension seconds is always assumed to be one more <code>precision</code>.  If the function is called with only <code>dec</code> as input, <code>precision</code> default to 1, in any other case defaults to 0.</li><li><code>truncate</code> (optional boolean keyword): if true, then the last displayed digit in the output is truncated in precision rather than rounded.  This option is useful if <code>adstring</code> is used to form an official IAU name (see http://vizier.u-strasbg.fr/Dic/iau-spec.htx) with coordinate specification.</li></ul><p><strong>Output</strong></p><p>The function returns one string.  The format of strings can be specified with <code>precision</code> and <code>truncate</code> keywords, see above.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; adstring(30.4, -1.23, truncate=true)
&quot; 02 01 35.9  -01 13 48&quot;

julia&gt; adstring.([30.4, -15.63], [-1.23, 48.41], precision=1)
2-element Array{String,1}:
 &quot; 02 01 36.00  -01 13 48.0&quot;
 &quot; 22 57 28.80  +48 24 36.0&quot;</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.airtovac-Tuple{Real}" href="#AstroLib.airtovac-Tuple{Real}"><code>AstroLib.airtovac</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">airtovac(wave_air) -&gt; wave_vacuum</code></pre><p><strong>Purpose</strong></p><p>Converts air wavelengths to vacuum wavelengths.</p><p><strong>Explanation</strong></p><p>Wavelengths are corrected for the index of refraction of air under standard conditions. Wavelength values below <span>$2000 Å$</span> will <em>not</em> be altered, take care within <span>$[1 Å, 2000 Å]$</span>.  Uses relation of Ciddor (1996).</p><p><strong>Arguments</strong></p><ul><li><code>wave_air</code>: the wavelength in air.</li></ul><p><strong>Output</strong></p><p>Vacuum wavelength in angstroms.</p><p><strong>Method</strong></p><p>Uses relation of Ciddor (1996), Applied Optics 62, 958.</p><p><strong>Example</strong></p><p>If the air wavelength is <code>w = 6056.125</code> (a Krypton line), then <code>airtovac(w)</code> yields a vacuum wavelength of <code>6057.8019</code>.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; airtovac(6056.125)
6057.801930991426</code></pre><p><strong>Notes</strong></p><p><code>vactoair</code> converts vacuum wavelengths to air wavelengths.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.aitoff-Tuple{Real,Real}" href="#AstroLib.aitoff-Tuple{Real,Real}"><code>AstroLib.aitoff</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">aitoff(l, b) -&gt; x, y</code></pre><p><strong>Purpose</strong></p><p>Convert longitude <code>l</code> and latitude <code>b</code> to <code>(x, y)</code> using an Aitoff projection.</p><p><strong>Explanation</strong></p><p>This function can be used to create an all-sky map in Galactic coordinates with an equal-area Aitoff projection.  Output map coordinates are zero longitude centered.</p><p><strong>Arguments</strong></p><ul><li><code>l</code>: longitude, scalar or vector, in degrees.</li><li><code>b</code>: latitude, number of elements as <code>l</code>, in degrees.</li></ul><p>Coordinates can be given also as a 2-tuple <code>(l, b)</code>.</p><p><strong>Output</strong></p><p>2-tuple <code>(x, y)</code>.</p><ul><li><code>x</code>: x coordinate, same number of elements as <code>l</code>.  <code>x</code> is normalized to be in <span>$[-180, 180]$</span>.</li><li><code>y</code>: y coordinate, same number of elements as <code>l</code>.  <code>y</code> is normalized to be in <span>$[-90, 90]$</span>.</li></ul><p><strong>Example</strong></p><p>Get <span>$(x ,y)$</span> Aitoff coordinates of Sirius, whose Galactic coordinates are <span>$(227.23, -8.890)$</span>.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; x, y = aitoff(227.23, -8.890)
(-137.92196683723276, -11.772527357473054)</code></pre><p><strong>Notes</strong></p><p>See AIPS memo No. 46 (ftp://ftp.aoc.nrao.edu/pub/software/aips/TEXT/PUBL/AIPSMEMO46.PS), page 4, for details of the algorithm.  This version of <code>aitoff</code> assumes the projection is centered at b=0 degrees.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.altaz2hadec-Tuple{Real,Real,Real}" href="#AstroLib.altaz2hadec-Tuple{Real,Real,Real}"><code>AstroLib.altaz2hadec</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">altaz2hadec(alt, az, lat) -&gt; ha, dec</code></pre><p><strong>Purpose</strong></p><p>Convert Horizon (Alt-Az) coordinates to Hour Angle and Declination.</p><p><strong>Explanation</strong></p><p>Can deal with the NCP singularity.  Intended mainly to be used by program <code>hor2eq</code>.</p><p><strong>Arguments</strong></p><p>Input coordinates may be either a scalar or an array, of the same dimension.</p><ul><li><code>alt</code>: local apparent altitude, in degrees, scalar or array.</li><li><code>az</code>: the local apparent azimuth, in degrees, scalar or vector, measured <em>east</em> of <em>north</em>!!!  If you have measured azimuth west-of-south (like the book Meeus does), convert it to east of north via: <code>az = (az + 180) % 360</code>.</li><li><code>lat</code>: the local geodetic latitude, in degrees, scalar or array.</li></ul><p><code>alt</code> and <code>az</code> can be given as a 2-tuple <code>(alt, az)</code>.</p><p><strong>Output</strong></p><p>2-tuple <code>(ha, dec)</code></p><ul><li><code>ha</code>: the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined.</li><li><code>dec</code>: the local apparent declination, in degrees.</li></ul><p>The output coordinates are always floating points and have the same type (scalar or array) as the input coordinates.</p><p><strong>Example</strong></p><p>Arcturus is observed at an apparent altitude of 59d,05m,10s and an azimuth (measured east of north) of 133d,18m,29s while at the latitude of +43.07833 degrees.  What are the local hour angle and declination of this object?</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; ha, dec = altaz2hadec(ten(59,05,10), ten(133,18,29), 43.07833)
(336.6828582472844, 19.182450965120402)</code></pre><p>The widely available XEPHEM code gets:</p><pre><code class="language-none">Hour Angle = 336.683
Declination = 19.1824</code></pre><p><strong>Notes</strong></p><p><code>hadec2altaz</code> converts Hour Angle and Declination to Horizon (Alt-Az) coordinates.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.baryvel-Tuple{Real}" href="#AstroLib.baryvel-Tuple{Real}"><code>AstroLib.baryvel</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">baryvel(dje, deq) -&gt; dvelh, dvelb</code></pre><p><strong>Purpose</strong></p><p>Calculates heliocentric and barycentric velocity components of Earth.</p><p><strong>Explanation</strong></p><p>Baryvel takes into account the Earth-Moon motion, and is useful for radial velocity work to an accuracy of ~1 m/s.</p><p><strong>Arguments</strong></p><ul><li><code>dje</code>: julian ephemeris date</li><li><code>deq</code> (optional): epoch of mean equinox of <code>dvelh</code> and <code>dvelb</code>. If <code>deq</code> is not provided, then it is assumed to be equal to <code>dje</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>dvelh</code>: heliocentric velocity component. in km/s</li><li><code>dvelb</code>: barycentric velocity component. in km/s</li></ul><p><strong>Example</strong></p><p>Compute the radial velocity of the Earth toward Altair on 15-Feb-1994 using both the original Stumpf algorithm.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; jd = jdcnv(1994, 2, 15, 0)
2.4493985e6

julia&gt; baryvel(jd, 2000)
([-17.0724, -22.8112, -9.88932], [-17.0808, -22.8047, -9.88626])</code></pre><p><strong>Notes</strong></p><p>The 3-vectors outputs <code>dvelh</code> and <code>dvelb</code> are given in a right-handed coordinate system with the +X axis toward the Vernal Equinox, and +Z axis toward the celestial pole.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.bprecess" href="#AstroLib.bprecess"><code>AstroLib.bprecess</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bprecess(ra, dec[, epoch]) -&gt; ra1950, dec1950
bprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -&gt; ra1950, dec1950</code></pre><p><strong>Purpose</strong></p><p>Precess positions from J2000.0 (FK5) to B1950.0 (FK4).</p><p><strong>Explanation</strong></p><p>Calculates the mean place of a star at B1950.0 on the FK4 system from the mean place at J2000.0 on the FK5 system.</p><p><code>bprecess</code> function has two methods, one for each of the following cases:</p><ul><li>the proper motion is known and non-zero</li><li>the proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations.</li></ul><p><strong>Arguments</strong></p><p>The function has 2 methods.  The common mandatory arguments are:</p><ul><li><code>ra</code>: input J2000 right ascension, in degrees.</li><li><code>dec</code>: input J2000 declination, in degrees.</li></ul><p>The two methods have a different third argument (see &quot;Explanation&quot; section for more details).  It can be one of the following:</p><ul><li><code>muradec</code>: 2-element vector containing the proper motion in seconds of arc per tropical <em>century</em> in right ascension and declination.</li><li><code>epoch</code>: scalar giving epoch of original observations.</li></ul><p>If none of these two arguments is provided (so <code>bprecess</code> is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and <code>epoch = 2000</code>.</p><p>If it is used the method involving <code>muradec</code> argument, the following keywords are available:</p><ul><li><code>parallax</code> (optional numerical keyword): stellar parallax, in seconds of arc.</li><li><code>radvel</code> (optional numerical keyword): radial velocity in km/s.</li></ul><p>Right ascension and declination can be passed as the 2-tuple <code>(ra, dec)</code>.  You can also pass <code>ra</code>, <code>dec</code>, <code>parallax</code>, and <code>radvel</code> as arrays, all of the same length N.  In that case, <code>muradec</code> should be a matrix 2×N.</p><p><strong>Output</strong></p><p>The 2-tuple of right ascension and declination in 1950, in degrees, of input coordinates is returned.  If <code>ra</code> and <code>dec</code> (and other possible optional arguments) are arrays, the 2-tuple of arrays <code>(ra1950, dec1950)</code> of the same length as the input coordinates is returned.</p><p><strong>Method</strong></p><p>The algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 186.  See also Aoki et al (1983), A&amp;A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A.</p><p><strong>Example</strong></p><p>The SAO2000 catalogue gives the J2000 position and proper motion for the star HD</p><ol><li>Find the B1950 position.</li></ol><ul><li>RA(2000) = 13h 42m 12.740s</li><li>Dec(2000) = 8d 23&#39; 17.69&#39;&#39;</li><li>Mu(RA) = -.0257 s/yr</li><li>Mu(Dec) = -.090 &#39;&#39;/yr</li></ul><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; muradec = 100*[-15*0.0257, -0.090]; # convert to century proper motion

julia&gt; ra = ten(13, 42, 12.74)*15;

julia&gt; decl = ten(8, 23, 17.69);

julia&gt; adstring(bprecess(ra, decl, muradec), precision=2)
&quot; 13 39 44.526  +08 38 28.63&quot;</code></pre><p><strong>Notes</strong></p><p>&quot;When transferring individual observations, as opposed to catalog mean place, the safest method is to transform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0&quot; – from the Explanatory Supplement (1992), p. 180</p><p><code>jprecess</code> performs the precession to J2000 coordinates.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.calz_unred" href="#AstroLib.calz_unred"><code>AstroLib.calz_unred</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">calz_unred(wave, flux, ebv[, r_v]) -&gt; deredden_wave</code></pre><p><strong>Purpose</strong></p><p>Deredden a galaxy spectrum using the Calzetti et al. (2000) recipe.</p><p><strong>Explanation</strong></p><p>Calzetti et al.  (2000, ApJ 533, 682; http://adsabs.harvard.edu/abs/2000ApJ...533..682C) developed a recipe for dereddening the spectra of galaxies where massive stars dominate the radiation output, valid between <span>$0.12$</span> to <span>$2.2$</span> microns.  (<code>calz_unred</code> extrapolates between <span>$0.12$</span> and <span>$0.0912$</span> microns.)</p><p><strong>Arguments</strong></p><ul><li><code>wave</code>: wavelength (Angstroms)</li><li><code>flux</code>: calibrated flux.</li><li><code>ebv</code>: color excess E(B-V).  If a negative <code>ebv</code> is supplied, then fluxes will be reddened rather than deredenned.  Note that the supplied color excess should be that derived for the stellar continuum, EBV(stars), which is related to the reddening derived from the gas, EBV(gas), via the Balmer decrement by EBV(stars) = 0.44*EBV(gas).</li><li><code>r_v</code> (optional): ratio of total to selective extinction, default is 4.05.  Calzetti et al. (2000) estimate <span>$r_v = 4.05 \pm 0.80$</span> from optical-IR observations of 4 starbursts.</li></ul><p><strong>Output</strong></p><p>Unreddened flux, same units as <code>flux</code>.  Flux values will be left unchanged outside valid domain (<span>$0.0912$</span> - <span>$2.2$</span> microns).</p><p><strong>Example</strong></p><p>Estimate how a flat galaxy spectrum (in wavelength) between <span>$1200 Å$</span> and <span>$3200 Å$</span> is altered by a reddening of E(B-V) = 0.1.</p><pre><code class="language-julia">wave = collect(1200:50:3150);
flux = ones(wave);
flux_new = calz_unred.(wave, flux, -0.1);</code></pre><p>Using a plotting tool you can visualize the unreddend flux.  For example, with <a href="https://github.com/JuliaPy/PyPlot.jl">PyPlot.jl</a></p><pre><code class="language-julia">using PyPlot
plot(wave, flux_new)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.co_aberration" href="#AstroLib.co_aberration"><code>AstroLib.co_aberration</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">co_aberration(jd, ra, dec[, eps=NaN]) -&gt; d_ra, d_dec</code></pre><p><strong>Purpose</strong></p><p>Calculate changes to right ascension and declination due to the effect of annual aberration</p><p><strong>Explanation</strong></p><p>With reference to Meeus, Chapter 23</p><p><strong>Arguments</strong></p><ul><li><code>jd</code>: julian date, scalar or vector</li><li><code>ra</code>: right ascension in degrees, scalar or vector</li><li><code>dec</code>: declination in degrees, scalar or vector</li><li><code>eps</code> (optional): true obliquity of the ecliptic (in radians). It will be calculated if no argument is specified.</li></ul><p><strong>Output</strong></p><p>The 2-tuple <code>(d_ra, d_dec)</code>:</p><ul><li><code>d_ra</code>: correction to right ascension due to aberration, in arc seconds</li><li><code>d_dec</code>: correction to declination due to aberration, in arc seconds</li></ul><p><strong>Example</strong></p><p>Compute the change in RA and Dec of Theta Persei (RA = 2h46m,11.331s, Dec = 49d20&#39;,54.5&#39;&#39;) due to aberration on 2028 Nov 13.19 TD</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; jd = jdcnv(2028,11,13,4, 56)
2.4620887055555554e6

julia&gt; co_aberration(jd,ten(2,46,11.331)*15,ten(49,20,54.54))
(30.04404628365077, 6.699400463119431)</code></pre><p>d<em>ra = 30.04404628365103&#39;&#39; (≈ 2.003s) d</em>dec = 6.699400463118504&#39;&#39;</p><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p><p>The output d<em>ra is <em>not</em> multiplied by cos(dec), so that apparent</em>ra = ra + d_ra/3600.</p><p>These formula are from Meeus, Chapters 23.  Accuracy is much better than 1 arcsecond. The maximum deviation due to annual aberration is 20.49&#39;&#39; and occurs when the Earth&#39;s velocity is perpendicular to the direction of the star.</p><p>This function calls <a href="#AstroLib.true_obliquity-Tuple{Real}"><code>true_obliquity</code></a> and <a href="#AstroLib.sunpos-Tuple{Real}"><code>sunpos</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.co_nutate-Tuple{Real,Real,Real}" href="#AstroLib.co_nutate-Tuple{Real,Real,Real}"><code>AstroLib.co_nutate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">co_nutate(jd, ra, dec) -&gt; d_ra, d_dec, eps, d_psi, d_eps</code></pre><p><strong>Purpose</strong></p><p>Calculate changes in RA and Dec due to nutation of the Earth&#39;s rotation</p><p><strong>Explanation</strong></p><p>Calculates necessary changes to ra and dec due to the nutation of the Earth&#39;s rotation axis, as described in Meeus, Chap 23. Uses formulae from Astronomical Almanac, 1984, and does the calculations in equatorial rectangular coordinates to avoid singularities at the celestial poles.</p><p><strong>Arguments</strong></p><ul><li><code>jd</code>: julian date, scalar or vector</li><li><code>ra</code>: right ascension in degrees, scalar or vector</li><li><code>dec</code>: declination in degrees, scalar or vector</li></ul><p><strong>Output</strong></p><p>The 5-tuple <code>(d_ra, d_dec, eps, d_psi, d_eps)</code>:</p><ul><li><code>d_ra</code>: correction to right ascension due to nutation, in degrees</li><li><code>d_dec</code>: correction to declination due to nutation, in degrees</li><li><code>eps</code>: the true obliquity of the ecliptic</li><li><code>d_psi</code>: nutation in the longitude of the ecliptic</li><li><code>d_eps</code>: nutation in the obliquity of the ecliptic</li></ul><p><strong>Example</strong></p><p>Example 23a in Meeus: On 2028 Nov 13.19 TD the mean position of Theta Persei is 2h 46m 11.331s 49d 20&#39; 54.54&#39;&#39;. Determine the shift in position due to the Earth&#39;s nutation.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; jd = jdcnv(2028,11,13,4,56)
2.4620887055555554e6

julia&gt; co_nutate(jd,ten(2,46,11.331) * 15,ten(49,20,54.54))
(0.004400660977140092, 0.00172668646508356, 0.40904016038217555, 14.859389427896476, 2.7038090372350574)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p><p>The output of <code>d_ra</code> and <code>d_dec</code> in IDL AstroLib is in arcseconds, however it is in degrees here.</p><p>This function calls <a href="#AstroLib.mean_obliquity-Tuple{Real}"><code>mean_obliquity</code></a> and <a href="#AstroLib.nutate-Tuple{Real}"><code>nutate</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.co_refract" href="#AstroLib.co_refract"><code>AstroLib.co_refract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">co_refract(old_alt[, altitude=0, pressure=NaN, temperature=NaN,
           epsilon=0.25, to_observe=false]) -&gt; aout</code></pre><p><strong>Purpose</strong></p><p>Calculate correction to altitude due to atmospheric refraction.</p><p><strong>Explanation</strong></p><p>Because the index of refraction of air is not precisely 1.0, the atmosphere bends all incoming light, making a star or other celestial object appear at a slightly different altitude (or elevation) than it really is.  It is important to understand the following definitions:</p><ul><li><p>Observed Altitude: The altitude that a star is seen to be, with a telescope. This is where it appears in the sky. This is should be always greater than the apparent altitude.</p></li><li><p>Apparent Altitude: The altitude that a star would be at, if ~there were no atmosphere~ (sometimes called the &quot;true&quot; altitude). This is usually calculated from an object&#39;s celestial coordinates. Apparent altitude should always be smaller than the observed altitude.</p></li></ul><p>Thus, for example, the Sun&#39;s apparent altitude when you see it right on the horizon is actually -34 arcminutes.</p><p>This program uses a couple of simple formulae to estimate the effect for most optical and radio wavelengths. Typically, you know your observed altitude (from an observation), and want the apparent altitude. To go the other way, this program uses an iterative approach.</p><p><strong>Arguments</strong></p><ul><li><code>old_alt</code>: observed altitude in degrees. If <code>to_observe</code> is set to true, this should be apparent altitude</li><li><code>altitude</code> (optional): the height of the observing location, in meters. This is only used to determine an approximate temperature and pressure, if these are not specified separately. Default is 0 i.e. sea level</li><li><code>pressure</code> (optional): the pressure at the observing location, in millibars. Default is NaN</li><li><code>temperature</code> (optional): the temperature at the observing location, in Kelvins. Default is NaN</li><li><code>epsilon</code> (optional): the accuracy to obtain, in arcseconds. If <code>to_observe</code> is true, then it will be calculated. Default is 0.25 arcseconds</li><li><code>to_observe</code> (optional boolean keyword): if set to true, it is assumed that <code>old_alt</code> has apparent altitude as its input and the observed altitude will be found</li></ul><p><strong>Output</strong></p><ul><li><code>aout</code>: apparent altitude, in degrees. Observed altitude is returned if <code>to_observe</code> is set to true</li></ul><p><strong>Example</strong></p><p>The lower limb of the Sun is observed to have altitude of 0d 30&#39;. Calculate the the true (i.e. apparent) altitude of the Sun&#39;s lower limb using mean  conditions of air pressure and temperature.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; co_refract(0.5)
0.02584736873098442</code></pre><p><strong>Notes</strong></p><p>If altitude is set but the temperature or pressure is not, the program will make an intelligent guess for the temperature and pressure.</p><p><strong>Wavelength Dependence</strong></p><p>This correction is 0 at zenith, about 1 arcminute at 45 degrees, and 34 arcminutes at the horizon for optical wavelengths. The correction is non-negligible at all wavelengths, but is not very easily calculable. These formulae assume a wavelength of 550 nm, and will be accurate to about 4 arcseconds for all visible wavelengths, for elevations of 10 degrees and higher. Amazingly, they are also accurate for radio frequencies less than ~ 100 GHz.</p><p><strong>References</strong></p><ul><li>Meeus, Astronomical Algorithms, Chapter 15.</li><li>Explanatory Supplement to the Astronomical Almanac, 1992.</li><li>Methods of Experimental Physics, Vol 12 Part B, Astrophysics, Radio Telescopes, Chapter 2.5, &quot;Refraction Effects in the Neutral Atmosphere&quot;, by R.K. Crane.</li></ul><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.ct2lst-Tuple{Real,Real}" href="#AstroLib.ct2lst-Tuple{Real,Real}"><code>AstroLib.ct2lst</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ct2lst(longitude, jd) -&gt; local_sidereal_time
ct2lst(longitude, tz, date) -&gt; local_sidereal_time</code></pre><p><strong>Purpose</strong></p><p>Convert from Local Civil Time to Local Mean Sidereal Time.</p><p><strong>Arguments</strong></p><p>The function can be called in two different ways.  The only argument common to both methods is <code>longitude</code>:</p><ul><li><code>longitude</code>: the longitude in degrees (east of Greenwich) of the place for which the local sidereal time is desired.  The Greenwich mean sidereal time (GMST) can be found by setting longitude = <code>0</code>.</li></ul><p>The civil date to be converted to mean sidereal time can be specified either by providing the Julian days:</p><ul><li><code>jd</code>: this is number of Julian days for the date to be converted.</li></ul><p>or the time zone and the date:</p><ul><li><code>tz</code>: the time zone of the site in hours, positive East of the Greenwich meridian (ahead of GMT).  Use this parameter to easily account for Daylight Savings time (e.g. -4=EDT, -5 = EST/CDT).</li><li><code>date</code>: this is the local civil time with type <code>DateTime</code>.</li></ul><p><strong>Output</strong></p><p>The local sidereal time for the date/time specified in hours.</p><p><strong>Method</strong></p><p>The Julian days of the day and time is question is used to determine the number of days to have passed since 2000-01-01.  This is used in conjunction with the GST of that date to extrapolate to the current GST; this is then used to get the LST.  See Astronomical Algorithms by Jean Meeus, p. 84 (Eq. 11-4) for the constants used.</p><p><strong>Example</strong></p><p>Find the Greenwich mean sidereal time (GMST) on 2008-07-30 at 15:53 in Baltimore, Maryland (longitude=-76.72 degrees).  The timezone is EDT or tz=-4</p><pre><code class="language-julia-repl">julia&gt; using AstroLib, Dates

julia&gt; lst = ct2lst(-76.72, -4, DateTime(2008, 7, 30, 15, 53))
11.356505172312609

julia&gt; sixty(lst)
3-element StaticArrays.SArray{Tuple{3},Float64,1,3}:
 11.0
 21.0
 23.418620325392112</code></pre><p>Find the Greenwich mean sidereal time (GMST) on 2015-11-24 at 13:21 in Heidelberg, Germany (longitude=08° 43&#39; E).  The timezone is CET or tz=1. Provide <code>ct2lst</code> only with the longitude of the place and the number of Julian days.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib, Dates

julia&gt; longitude=ten(8, 43); # Convert longitude to decimals.

julia&gt; jd = jdcnv(DateTime(2015, 11, 24, 13, 21) - Dates.Hour(1));
# Get number of Julian days. Remember to subtract the time zone in
# order to convert local time to UTC.

julia&gt; lst = ct2lst(longitude, jd) # Calculate Greenwich Mean Sidereal Time.
17.140685171005316

julia&gt; sixty(lst)
3-element StaticArrays.SArray{Tuple{3},Float64,1,3}:
 17.0
  8.0
 26.466615619137883</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.daycnv" href="#AstroLib.daycnv"><code>AstroLib.daycnv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">daycnv(julian_days) -&gt; DateTime</code></pre><p><strong>Purpose</strong></p><p>Converts Julian days number to Gregorian calendar dates.</p><p><strong>Explanation</strong></p><p>Takes the number of Julian calendar days since epoch <code>-4713-11-24T12:00:00</code> and returns the corresponding proleptic Gregorian Calendar date.</p><p><strong>Argument</strong></p><ul><li><code>julian_days</code>: Julian days number.</li></ul><p><strong>Output</strong></p><p>Proleptic Gregorian Calendar date, of type <code>DateTime</code>, corresponding to the given Julian days number.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; daycnv(2440000)
1968-05-23T12:00:00</code></pre><p><strong>Notes</strong></p><p><code>jdcnv</code> is the inverse of this function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.deredd-NTuple{5,Real}" href="#AstroLib.deredd-NTuple{5,Real}"><code>AstroLib.deredd</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">deredd(Eby, by, m1, c1, ub) -&gt; by0, m0, c0, ub0</code></pre><p><strong>Purpose</strong></p><p>Deredden stellar Stromgren parameters given for a value of E(b-y)</p><p><strong>Arguments</strong></p><ul><li><code>Eby</code>: color index E(b-y), scalar (E(b-y) = 0.73*E(B-V))</li><li><code>by</code>: b-y color (observed)</li><li><code>m1</code>: Stromgren line blanketing parameter (observed)</li><li><code>c1</code>: Stromgren Balmer discontinuity parameter (observed)</li><li><code>ub</code>: u-b color (observed)</li></ul><p>All arguments can be either scalars or arrays all of the same length.</p><p><strong>Output</strong></p><p>The 4-tuple <code>(by0, m0, c0, ub0)</code>.</p><ul><li><code>by0</code>: b-y color (dereddened)</li><li><code>m0</code>: line blanketing index (dereddened)</li><li><code>c0</code>: Balmer discontinuity parameter (dereddened)</li><li><code>ub0</code>: u-b color (dereddened)</li></ul><p>These are scalars or arrays of the same length as the input arguments.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; deredd(0.5, 0.2, 1.0, 1.0, 0.1)
(-0.3, 1.165, 0.905, -0.665)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.eci2geo-NTuple{4,Real}" href="#AstroLib.eci2geo-NTuple{4,Real}"><code>AstroLib.eci2geo</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">eci2geo(x, y, z, jd) -&gt; latitude, longitude, altitude</code></pre><p><strong>Purpose</strong></p><p>Convert Earth-centered inertial coordinates to geographic spherical coordinates.</p><p><strong>Explanation</strong></p><p>Converts from ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates to geographic spherical coordinates (latitude, longitude, altitude).  Julian day is also needed as input.</p><p>ECI coordinates are in km from Earth center at the supplied time (True of Date). Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: ECI x coordinate at <code>jd</code>, in kilometers.</li><li><code>y</code>: ECI y coordinate at <code>jd</code>, in kilometers.</li><li><code>z</code>: ECI z coordinate at <code>jd</code>, in kilometers.</li><li><code>jd</code>: Julian days.</li></ul><p>The three coordinates can be passed as a 3-tuple <code>(x, y, z)</code>.  In addition, <code>x</code>, <code>y</code>, <code>z</code>, and <code>jd</code> can be given as arrays of the same length.</p><p><strong>Output</strong></p><p>The 3-tuple of geographical coordinate (latitude, longitude, altitude).</p><ul><li>latitude: latitude, in degrees.</li><li>longitude: longitude, in degrees.</li><li>altitude: altitude, in kilometers.</li></ul><p>If ECI coordinates are given as arrays, a 3-tuple of arrays of the same length is returned.</p><p><strong>Example</strong></p><p>Obtain the geographic direction of the vernal point on 2015-06-30T14:03:12.857, in geographic coordinates, at altitude 600 km.  Note: equatorial radii of Solar System planets in meters are stored into <code>AstroLib.planets</code> dictionary.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; x = AstroLib.planets[&quot;earth&quot;].eqradius*1e-3 + 600;

julia&gt; lat, long, alt = eci2geo(x, 0, 0, jdcnv(&quot;2015-06-30T14:03:12.857&quot;))
(0.0, 230.87301833205856, 600.0)</code></pre><p>These coordinates can be further transformed into geodetic coordinates using <code>geo2geodetic</code> or into geomagnetic coordinates using <code>geo2mag</code>.</p><p><strong>Notes</strong></p><p><code>geo2eci</code> converts geographic spherical coordinates to Earth-centered inertial coordinates.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.eq2hor" href="#AstroLib.eq2hor"><code>AstroLib.eq2hor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eq2hor(ra, dec, jd[, obsname; ws=false, B1950=false, precession=true, nutate=true,
       aberration=true, refract=true, pressure=NaN, temperature=NaN]) -&gt; alt, az, ha

eq2hor(ra, dec, jd, lat, lon[, altitude=0; ws=false, B1950=false,
       precession=true, nutate=true, aberration=true, refract=true,
       pressure=NaN, temperature=NaN]) -&gt; alt, az, ha</code></pre><p><strong>Purpose</strong></p><p>Convert celestial  (ra-dec) coords to local horizon coords (alt-az).</p><p><strong>Explanation</strong></p><p>This code calculates horizon (alt,az) coordinates from equatorial (ra,dec) coords. It performs precession, nutation, aberration, and refraction corrections.</p><p><strong>Arguments</strong></p><p>This function has two base methods.  With one you can specify the name of the observatory, if present in <code>AstroLib.observatories</code>, with the other one you can provide the coordinates of the observing site and, optionally, the altitude.</p><p>Common mandatory arguments:</p><ul><li><code>ra</code>: right ascension of object, in degrees</li><li><code>dec</code>: declination of object, in degrees</li><li><code>jd</code>: julian date</li></ul><p>Other positional arguments:</p><ul><li><code>obsname</code>: set this to a valid observatory name in <code>AstroLib.observatories</code>.</li></ul><p>or</p><ul><li><code>lat</code>: north geodetic latitude of location, in degrees.</li><li><code>lon</code>: AST longitude of location, in degrees. You can specify west longitude with a negative sign.</li><li><code>altitude</code>: the altitude of the observing location, in meters.  It is <code>0</code> by default</li></ul><p>Optional keyword arguments:</p><ul><li><code>ws</code> (optional boolean keyword): set this to <code>true</code> to get the azimuth measured</li><li><code>B1950</code> (optional boolean keyword): set this to <code>true</code> if the ra and dec are specified in B1950 (FK4 coordinates) instead of J2000 (FK5). This is <code>false</code> by default</li><li><code>precession</code> (optional boolean keyword): set this to <code>false</code> for no precession correction, <code>true</code> by default</li><li><code>nutate</code> (optional boolean keyword): set this to <code>false</code> for no nutation, <code>true</code> by default</li><li><code>aberration</code> (optional boolean keyword): set this to <code>false</code> for no aberration correction, <code>true</code> by default</li><li><code>refract</code> (optional boolean keyword): set this to <code>false</code> for no refraction correction, <code>true</code> by default</li><li><code>pressure</code> (optional keyword): the pressure at the observing location, in millibars. Default value is <code>NaN</code></li><li><code>temperature</code> (optional keyword): the temperature at the observing location, in Kelvins. Default value is <code>NaN</code></li></ul><p><strong>Output</strong></p><ul><li><code>alt</code>: altitude of horizon coords, in degrees</li><li><code>az</code>: azimuth angle measured East from North (unless ws is <code>true</code>), in degrees</li><li><code>ha</code>: hour angle, in degrees</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; alt_o, az_o = eq2hor(ten(6,40,58.2)*15, ten(9,53,44), 2460107.25, ten(50,31,36),
                            ten(6,51,18), 369, pressure = 980, temperature=283)
(16.42399150972157, 265.60656932130564, 76.11502253130612)

julia&gt; adstring(az_o, alt_o)
&quot; 17 42 25.6  +16 25 26&quot;</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.eqpole-Tuple{Real,Real}" href="#AstroLib.eqpole-Tuple{Real,Real}"><code>AstroLib.eqpole</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">eqpole(l, b[; southpole = false]) -&gt; x, y</code></pre><p><strong>Purpose</strong></p><p>Convert right ascension <span>$l$</span> and declination <span>$b$</span> to coordinate <span>$(x, y)$</span> using an equal-area polar projection.</p><p><strong>Explanation</strong></p><p>The output <span>$x$</span> and <span>$y$</span> coordinates are scaled to be in the range <span>$[-90, 90]$</span> and to go from equator to pole to equator.  Output map points can be centered on the north pole or south pole.</p><p><strong>Arguments</strong></p><ul><li><code>l</code>: longitude, scalar or vector, in degrees</li><li><code>b</code>: latitude, same number of elements as right ascension, in degrees</li><li><code>southpole</code> (optional boolean keyword): keyword to indicate that the plot is to be centered on the south pole instead of the north pole.  Default is <code>false</code>.</li></ul><p><strong>Output</strong></p><p>The 2-tuple <span>$(x, y)$</span>:</p><ul><li><span>$x$</span> coordinate, same number of elements as right ascension, normalized to be in the range <span>$[-90, 90]$</span>.</li><li><span>$y$</span> coordinate, same number of elements as declination, normalized to be in the range <span>$[-90, 90]$</span>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; eqpole(100, 35, southpole=true)
(-111.18287262822456, -19.604540237028665)

julia&gt; eqpole(80, 19)
(72.78853915267848, 12.83458333897169)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.euler-Tuple{Real,Real,Integer}" href="#AstroLib.euler-Tuple{Real,Real,Integer}"><code>AstroLib.euler</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">euler(ai, bi, select[, FK4=true, radians=true])</code></pre><p><strong>Purpose</strong></p><p>Transform between Galactic, celestial, and ecliptic coordinates.</p><p><strong>Explanation</strong></p><p>The function is used by the astro procedure.</p><p><strong>Arguments</strong></p><ul><li><p><code>ai</code>: input longitude, scalar or vector.</p></li><li><p><code>bi</code>: input latitude, scalar or vector.</p></li><li><p><code>select</code> : integer input specifying type of coordinate transformation. SELECT   From          To     | SELECT   From       To    1   RA-Dec (2000) Galactic |   4    Ecliptic   RA-Dec    2   Galactic      RA-DEC   |   5    Ecliptic   Galactic    3   RA-Dec        Ecliptic |   6    Galactic   Ecliptic</p></li><li><p><code>FK4</code> (optional boolean keyword) : if this keyword is set to <code>true</code>, then input and output celestial and ecliptic coordinates should be given in equinox B1950. When <code>false</code>, by default, they should be given in equinox J2000.</p></li><li><p><code>radians</code> (optional boolean keyword) : if this keyword is set to <code>true</code>, all input and output angles are in radians rather than degrees.</p></li></ul><p><strong>Output</strong></p><p>a 2-tuple <code>(ao, bo)</code>:</p><ul><li><code>ao</code>: output longitude in degrees.</li><li><code>bo</code>: output latitude in degrees.</li></ul><p><strong>Example</strong></p><p>Find the Galactic coordinates of Cyg X-1 (ra=299.590315, dec=35.201604)</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; euler(299.590315, 35.201604, 1)
(71.33498957116959, 3.0668335310640984)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.flux2mag" href="#AstroLib.flux2mag"><code>AstroLib.flux2mag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">flux2mag(flux[, zero_point, ABwave=number]) -&gt; magnitude</code></pre><p><strong>Purpose</strong></p><p>Convert from flux expressed in erg/(s cm² Å) to magnitudes.</p><p><strong>Explanation</strong></p><p>This is the reverse of <code>mag2flux</code>.</p><p><strong>Arguments</strong></p><ul><li><code>flux</code>: the flux to be converted in magnitude, expressed in erg/(s cm² Å).</li><li><code>zero_point</code>: the zero point level of the magnitude.  If not</li></ul><p>supplied then defaults to 21.1 (Code et al 1976).  Ignored if the <code>ABwave</code>  keyword is supplied</p><ul><li><code>ABwave</code> (optional numeric keyword): wavelength in Angstroms.</li></ul><p>If supplied, then returns Oke AB magnitudes (Oke &amp; Gunn 1983, ApJ, 266, 713;  http://adsabs.harvard.edu/abs/1983ApJ...266..713O).</p><p><strong>Output</strong></p><p>The magnitude.</p><p>If the <code>ABwave</code> keyword is set then magnitude is given by the expression</p><div>\[\text{ABmag} = -2.5\log_{10}(f) - 5\log_{10}(\text{ABwave}) - 2.406\]</div><p>Otherwise, magnitude is given by the expression</p><div>\[\text{mag} = -2.5\log_{10}(\text{flux}) - \text{zero point}\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; flux2mag(5.2e-15)
14.609991640913002

julia&gt; flux2mag(5.2e-15, 15)
20.709991640913003

julia&gt; flux2mag(5.2e-15, ABwave=15)
27.423535345634598</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.gal_uvw-NTuple{6,Real}" href="#AstroLib.gal_uvw-NTuple{6,Real}"><code>AstroLib.gal_uvw</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">gal_uvw(ra, dec, pmra, pmdec, vrad, plx[, lsr=true]) -&gt; u, v, w</code></pre><p><strong>Purpose</strong></p><p>Calculate the Galactic space velocity <span>$(u, v, w)$</span> of a star.</p><p><strong>Explanation</strong></p><p>Calculates the Galactic space velocity <span>$(u, v, w)$</span> of a star given its (1) coordinates, (2) proper motion, (3) parallax, and (4) radial velocity.</p><p><strong>Arguments</strong></p><p>User must supply a position, proper motion, radial velocity and parallax. Either scalars or arrays all of the same length can be supplied.</p><p>(1) Position:</p><ul><li><code>ra</code>: right ascension, in degrees</li><li><code>dec</code>: declination, in degrees</li></ul><p>(2) Proper Motion</p><ul><li><code>pmra</code>: proper motion in right ascension in arc units (typically milli-arcseconds/yr).  If given <span>$\mu_\alpha$</span> – proper motion in seconds of time/year – then this is equal to <span>$15 \mu_\alpha \cos(\text{dec})$</span>.</li><li><code>pmdec</code>: proper motion in declination (typically mas/yr).</li></ul><p>(3) Radial Velocity</p><ul><li><code>vrad</code>: velocity in km/s</li></ul><p>(4) Parallax</p><ul><li><code>plx</code>: parallax with same distance units as proper motion measurements typically milliarcseconds (mas)</li></ul><p>If you know the distance in parsecs, then set <code>plx</code> to <span>$1000/\text{distance}$</span>, if proper motion measurements are given in milli-arcseconds/yr.</p><p>There is an additional optional keyword:</p><ul><li><code>lsr</code> (optional boolean keyword): if this keyword is set to <code>true</code>, then the output velocities will be corrected for the solar motion <span>$(u, v, w)_\odot = (-8.5, 13.38, 6.49)$</span> (Coşkunoǧlu et al. 2011 MNRAS, 412, 1237; DOI:<a href="http://dx.doi.org/10.1111/j.1365-2966.2010.17983.x">10.1111/j.1365-2966.2010.17983.x</a>) to the local standard of rest (LSR).  Note that the value of the solar motion through the LSR remains poorly determined.</li></ul><p><strong>Output</strong></p><p>The 3-tuple <span>$(u, v, w)$</span></p><ul><li><span>$u$</span>: velocity (km/s) positive toward the Galactic <em>anti</em>center</li><li><span>$v$</span>: velocity (km/s) positive in the direction of Galactic rotation</li><li><span>$w$</span>: velocity (km/s) positive toward the North Galactic Pole</li></ul><p><strong>Method</strong></p><p>Follows the general outline of Johnson &amp; Soderblom (1987, AJ, 93, 864; DOI:<a href="http://dx.doi.org/10.1086/114370">10.1086/114370</a>) except that <span>$u$</span> is positive outward toward the Galactic <em>anti</em>center, and the J2000 transformation matrix to Galactic coordinates is taken from the introduction to the Hipparcos catalog.</p><p><strong>Example</strong></p><p>Compute the U,V,W coordinates for the halo star HD 6755.  Use values from Hipparcos catalog, and correct to the LSR.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; ra=ten(1,9,42.3)*15.; dec = ten(61,32,49.5);

julia&gt; pmra = 627.89;  pmdec = 77.84; # mas/yr

julia&gt; vrad = -321.4; dis = 129; # distance in parsecs

julia&gt; u, v, w = gal_uvw(ra, dec, pmra, pmdec, vrad, 1e3/dis, lsr=true)
(118.2110474553902, -466.4828898385057, 88.16573278565097)</code></pre><p><strong>Notes</strong></p><p>This function does not take distance as input.  See &quot;Arguments&quot; section above for how to provide it using parallax argument.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.gcirc-Tuple{Integer,Real,Real,Real,Real}" href="#AstroLib.gcirc-Tuple{Integer,Real,Real,Real,Real}"><code>AstroLib.gcirc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">gcirc(units, ra1, dec1, ra2, dec2) -&gt; angular_distance</code></pre><p><strong>Purpose</strong></p><p>Computes rigorous great circle arc distances.</p><p><strong>Explanation</strong></p><p>Input position can be either radians, sexagesimal right ascension and declination, or degrees.</p><p><strong>Arguments</strong></p><ul><li><code>units</code>: integer, can be either 0, or 1, or 2.  Describes units of inputs and output:<ul><li>0: everything (input right ascensions and declinations, and output distance) is radians</li><li>1: right ascensions are in decimal hours, declinations in decimal degrees, output distance in arc seconds</li><li>2: right ascensions and declinations are in degrees, output distance in arc seconds</li></ul></li><li><code>ra1</code>:  right ascension or longitude of point 1</li><li><code>dec1</code>: declination or latitude of point 1</li><li><code>ra2</code>: right ascension or longitude of point 2</li><li><code>dec2</code>: declination or latitude of point 2</li></ul><p>Both <code>ra1</code> and <code>dec1</code>, and <code>ra2</code> and <code>dec2</code> can be given as 2-tuples <code>(ra1, dec1)</code> and <code>(ra2, dec2)</code>.</p><p><strong>Output</strong></p><p>Angular distance on the sky between points 1 and 2, as a <code>AbstractFloat</code>.  See <code>units</code> argument above for the units.</p><p><strong>Method</strong></p><p>&quot;Haversine formula&quot; see http://en.wikipedia.org/wiki/Great-circle_distance.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; gcirc(0, 120, -43, 175, +22)
1.590442261600714</code></pre><p><strong>Notes</strong></p><ul><li>The function <code>sphdist</code> provides an alternate method of computing a spherical</li></ul><p>distance.</p><ul><li>The Haversine formula can give rounding errors for antipodal points.</li></ul><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.geo2eci-NTuple{4,Real}" href="#AstroLib.geo2eci-NTuple{4,Real}"><code>AstroLib.geo2eci</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">geo2eci(latitude, longitude, altitude, jd) -&gt; x, y, z</code></pre><p><strong>Purpose</strong></p><p>Convert geographic spherical coordinates to Earth-centered inertial coordinates.</p><p><strong>Explanation</strong></p><p>Converts from geographic spherical coordinates (latitude, longitude, altitude) to ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates.  Julian days is also needed.</p><p>Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius.  ECI coordinates are in km from Earth center at epoch TOD (True of Date).</p><p><strong>Arguments</strong></p><ul><li><code>latitude</code>: geographic latitude, in degrees.</li><li><code>longitude</code>: geographic longitude, in degrees.</li><li><code>altitude</code>: geographic altitude, in kilometers.</li><li><code>jd</code>: Julian days.</li></ul><p>The three coordinates can be passed as a 3-tuple <code>(latitude, longitude, altitude)</code>.  In addition, <code>latitude</code>, <code>longitude</code>, <code>altitude</code>, and <code>jd</code> can be given as arrays of the same length.</p><p><strong>Output</strong></p><p>The 3-tuple of ECI (x, y, z) coordinates, in kilometers.  The TOD epoch is the supplied <code>jd</code> time.</p><p>If geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned.</p><p><strong>Example</strong></p><p>Obtain the ECI coordinates of the intersection of the equator and Greenwich&#39;s meridian on 2015-06-30T14:03:12.857</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; geo2eci(0, 0, 0, jdcnv(&quot;2015-06-30T14:03:12.857&quot;))
(-4024.8671780315185, 4947.835465127513, 0.0)</code></pre><p><strong>Notes</strong></p><p><code>eci2geo</code> converts Earth-centered inertial coordinates to geographic spherical coordinates.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.geo2geodetic-NTuple{5,Real}" href="#AstroLib.geo2geodetic-NTuple{5,Real}"><code>AstroLib.geo2geodetic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">geo2geodetic(latitude, longitude, altitude) -&gt; latitude, longitude, altitude
geo2geodetic(latitude, longitude, altitude, planet) -&gt; latitude, longitude, altitude
geo2geodetic(latitude, longitude, altitude, equatorial_radius, polar_radius) -&gt; latitude, longitude, altitude</code></pre><p><strong>Purpose</strong></p><p>Convert from geographic (or planetographic) to geodetic coordinates.</p><p><strong>Explanation</strong></p><p>Converts from geographic (latitude, longitude, altitude) to geodetic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth&#39;s oblateness.</p><p>Geographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground.</p><p><strong>Arguments</strong></p><p>The function has two base methods.  The arguments common to all methods and always mandatory are <code>latitude</code>, <code>longitude</code>, and <code>altitude</code>:</p><ul><li><code>latitude</code>: geographic latitude, in degrees.</li><li><code>longitude</code>: geographic longitude, in degrees.</li><li><code>altitude</code>: geographic altitude, in kilometers.</li></ul><p>In order to convert to geodetic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included).</p><p>If you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are:</p><ul><li><code>equatorial_radius</code>: value of the equatorial radius of the body, in kilometers.</li><li><code>polar_radius</code>: value of the polar radius of the body, in kilometers.</li></ul><p>Instead, if you want to use the method with the selection of a planet, the only additional argument is the planet name:</p><ul><li><code>planet</code> (optional string argument): string with the name of the Solar System planet, from &quot;Mercury&quot; to &quot;Pluto&quot;.  If omitted (so, when only <code>latitude</code>, <code>longitude</code>, and <code>altitude</code> are provided), the default is &quot;Earth&quot;.</li></ul><p>In all cases, the three coordinates can be passed as a 3-tuple <code>(latitude, longitude, altitude)</code>.  In addition, geographical <code>latitude</code>, <code>longitude</code>, and <code>altitude</code> can be given as arrays of the same length.</p><p><strong>Output</strong></p><p>The 3-tuple <code>(latitude, longitude, altitude)</code> in geodetic coordinates, for the body with specified equatorial and polar radii (Earth by default).</p><p>If geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned.</p><p><strong>Method</strong></p><p>Stephen P.  Keeler and Yves Nievergelt, &quot;Computing geodetic coordinates&quot;, SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI:<a href="http://dx.doi.org/10.1137/S0036144597323921">10.1137/S0036144597323921</a>).</p><p>Planetary constants are from Planetary Fact Sheet (http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html).</p><p><strong>Example</strong></p><p>Locate the Earth geographic North pole (latitude: 90°, longitude: 0°, altitude 0 km), in geodetic coordinates:</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; geo2geodetic(90, 0, 0)
(90.0, 0.0, 21.38499999999931)</code></pre><p>The same for Jupiter:</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; geo2geodetic(90, 0, 0, &quot;Jupiter&quot;)
(90.0, 0.0, 4638.0)</code></pre><p>Find geodetic coordinates for point of geographic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km:</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; geo2geodetic(43.16, -24.32, 3.87, 8724.32, 8619.19)
(43.849399515234516, -24.32, 53.53354478670964)</code></pre><p><strong>Notes</strong></p><p>Whereas the conversion from geodetic to geographic coordinates is given by an exact, analytical formula, the conversion from geographic to geodetic isn&#39;t. Approximative iterations (as used here) exist, but tend to become less good with increasing eccentricity and altitude.  The formula used in this routine should give correct results within six digits for all spatial locations, for an ellipsoid (planet) with an eccentricity similar to or less than Earth&#39;s.  More accurate results can be obtained via calculus, needing a non-determined amount of iterations.</p><p>In any case, the function <code>geodetic2geo</code>, which converts from geodetic (or planetodetic) to geographic coordinates, can be used to estimate the accuracy of <code>geo2geodetic</code>.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; collect(geodetic2geo(geo2geodetic(67.2, 13.4, 1.2))) - [67.2, 13.4, 1.2]
3-element Array{Float64,1}:
 -3.5672513831741526e-9
  0.0
  9.484211194177306e-10</code></pre><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.geo2mag" href="#AstroLib.geo2mag"><code>AstroLib.geo2mag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">geo2mag(latitude, longitude[, year]) -&gt; geomagnetic_latitude, geomagnetic_longitude</code></pre><p><strong>Purpose</strong></p><p>Convert from geographic to geomagnetic coordinates.</p><p><strong>Explanation</strong></p><p>Converts from geographic (latitude, longitude) to geomagnetic (latitude, longitude).  Altitude is not involved in this function.</p><p><strong>Arguments</strong></p><ul><li><code>latitude</code>: geographic latitude (North), in degrees.</li><li><code>longitude</code>: geographic longitude (East), in degrees.</li><li><code>year</code> (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year.</li></ul><p>The coordinates can be passed as arrays of the same length.</p><p><strong>Output</strong></p><p>The 2-tuple of magnetic (latitude, longitude) coordinates, in degrees.</p><p>If geographical coordinates are given as arrays, a 2-tuple of arrays of the same length is returned.</p><p><strong>Example</strong></p><p>Kyoto has geographic coordinates 35° 00&#39; 42&#39;&#39; N, 135° 46&#39; 06&#39;&#39; E, find its geomagnetic coordinates in 2016:</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; geo2mag(ten(35,0,42), ten(135,46,6), 2016)
(36.86579228937769, -60.184060536651614)</code></pre><p><strong>Notes</strong></p><p>This function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy).</p><p><code>mag2geo</code> converts geomagnetical coordinates to geographic coordinates.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.geodetic2geo-NTuple{5,Real}" href="#AstroLib.geodetic2geo-NTuple{5,Real}"><code>AstroLib.geodetic2geo</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">geodetic2geo(latitude, longitude, altitude) -&gt; latitude, longitude, altitude
geodetic2geo(latitude, longitude, altitude, planet) -&gt; latitude, longitude, altitude
geodetic2geo(latitude, longitude, altitude, equatorial_radius, polar_radius) -&gt; latitude, longitude, altitude</code></pre><p><strong>Purpose</strong></p><p>Convert from geodetic (or planetodetic) to geographic coordinates.</p><p><strong>Explanation</strong></p><p>Converts from geodetic (latitude, longitude, altitude) to geographic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth&#39;s oblateness.</p><p>Geographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground.</p><p><strong>Arguments</strong></p><p>The function has two base methods.  The arguments common to all methods and always mandatory are <code>latitude</code>, <code>longitude</code>, and <code>altitude</code>:</p><ul><li><code>latitude</code>: geodetic latitude, in degrees.</li><li><code>longitude</code>: geodetic longitude, in degrees.</li><li><code>altitude</code>: geodetic altitude, in kilometers.</li></ul><p>In order to convert to geographic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included).</p><p>If you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are:</p><ul><li><code>equatorial_radius</code>: value of the equatorial radius of the body, in kilometers.</li><li><code>polar_radius</code>: value of the polar radius of the body, in kilometers.</li></ul><p>Instead, if you want to use the method with the selection of a planet, the only additional argument is the planet name:</p><ul><li><code>planet</code> (optional string argument): string with the name of the Solar System planet, from &quot;Mercury&quot; to &quot;Pluto&quot;.  If omitted (so, when only <code>latitude</code>, <code>longitude</code>, and <code>altitude</code> are provided), the default is &quot;Earth&quot;.</li></ul><p>In all cases, the three coordinates can be passed as a 3-tuple <code>(latitude, longitude, altitude)</code>.  In addition, geodetic <code>latitude</code>, <code>longitude</code>, and <code>altitude</code> can be given as arrays of the same length.</p><p><strong>Output</strong></p><p>The 3-tuple <code>(latitude, longitude, altitude)</code> in geographic coordinates, for the body with specified equatorial and polar radii (Earth by default).</p><p>If geodetic coordinates are given as arrays, a 3-tuple of arrays of the same length is returned.</p><p><strong>Method</strong></p><p>Stephen P.  Keeler and Yves Nievergelt, &quot;Computing geodetic coordinates&quot;, SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI:<a href="http://dx.doi.org/10.1137/S0036144597323921">10.1137/S0036144597323921</a>).</p><p>Planetary constants from &quot;Allen&#39;s Astrophysical Quantities&quot;, Fourth Ed., (2000).</p><p><strong>Example</strong></p><p>Find geographic coordinates of geodetic North pole (latitude: 90°, longitude: 0°, altitude 0 km) of the Earth:</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; geodetic2geo(90, 0, 0)
(90.0, 0.0, -21.38499999999931)</code></pre><p>The same for Jupiter:</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; geodetic2geo(90, 0, 0, &quot;Jupiter&quot;)
(90.0, 0.0, -4638.0)</code></pre><p>Find geographic coordinates for point of geodetic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km:</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; geodetic2geo(43.16, -24.32, 3.87, 8724.32, 8619.19)
(42.46772711708433, -24.32, -44.52902080669082)</code></pre><p><strong>Notes</strong></p><p><code>geo2geodetic</code> converts from geographic (or planetographic) to geodetic coordinates.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.get_date-Tuple{Dates.DateTime,Bool,Bool}" href="#AstroLib.get_date-Tuple{Dates.DateTime,Bool,Bool}"><code>AstroLib.get_date</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_date([date, old=true, timetag=true]) -&gt; string</code></pre><p><strong>Purpose</strong></p><p>Returns the UTC date in <code>&quot;CCYY-MM-DD&quot;</code> format for FITS headers.</p><p><strong>Explanation</strong></p><p>This is the format required by the <code>DATE</code> and <code>DATE-OBS</code> keywords in a FITS header.</p><p><strong>Argument</strong></p><ul><li><code>date</code> (optional): the date in UTC standard.  If omitted, defaults to the current UTC time.  Each element can be either a <code>DateTime</code> type or anything that can be converted to that type.  In the case of vectorial input, each element is considered as a date, so you cannot provide a date by parts.</li><li><code>old</code> (optional boolean keyword): see below.</li><li><code>timetag</code> (optional boolean keyword): see below.</li></ul><p><strong>Output</strong></p><p>A string with the date formatted according to the given optional keywords.</p><ul><li>When no optional keywords (<code>timetag</code> and <code>old</code>) are supplied, the format of the output string is <code>&quot;CCYY-MM-DD&quot;</code> (year-month-day part of the date), where <code>CCYY</code> represents a 4-digit calendar year, <code>MM</code> the 2-digit ordinal number of a calendar month within the calendar year, and <code>DD</code> the 2-digit ordinal number of a day within the calendar month.</li><li>If the boolean keyword <code>old</code> is true (default: false), the year-month-day part of date has <code>&quot;DD/MM/YY&quot;</code> format.  This is the formerly (pre-1997) recommended for FITS.  Note that this format is now deprecated because it uses only a 2-digit representation of the year.</li><li>If the boolean keyword <code>timetag</code> is true (default: false), <code>&quot;Thh:mm:ss&quot;</code> is appended to the year-month-day part of the date, where &lt;hh&gt; represents the hour in the day, &lt;mm&gt; the minutes, &lt;ss&gt; the seconds, and the literal &#39;T&#39; the ISO 8601 time designator.</li></ul><p>Note that <code>old</code> and <code>timetag</code> keywords can be used together, so that the output string will have <code>&quot;DD/MM/YYThh:mm:ss&quot;</code> format.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib, Dates

julia&gt; get_date(DateTime(21937, 05, 30, 09, 59, 00), timetag=true)
&quot;21937-05-30T09:59:00&quot;</code></pre><p><strong>Notes</strong></p><ol><li>A discussion of the DATExxx syntax in FITS headers can be found in</li></ol><p>http://www.cv.nrao.edu/fits/documents/standards/year2000.txt</p><ol><li>Those who wish to use need further flexibility in their date formats (e.g. to</li></ol><p>use TAI time) should look at Bill Thompson&#39;s time routines in  http://sohowww.nascom.nasa.gov/solarsoft/gen/idl/time</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.get_juldate-Tuple{}" href="#AstroLib.get_juldate-Tuple{}"><code>AstroLib.get_juldate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_juldate() -&gt; julian_days</code></pre><p><strong>Purpose</strong></p><p>Return the number of Julian days for current time.</p><p><strong>Explanation</strong></p><p>Return for current time the number of Julian calendar days since epoch <code>-4713-11-24T12:00:00</code> as a floating point.</p><p><strong>Example</strong></p><pre><code class="language-julia">get_juldate()
daycnv(get_juldate())</code></pre><p><strong>Notes</strong></p><p>Use <code>jdcnv</code> to get the number of Julian days for a different date.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.hadec2altaz-Tuple{Real,Real,Real}" href="#AstroLib.hadec2altaz-Tuple{Real,Real,Real}"><code>AstroLib.hadec2altaz</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">hadec2altaz(ha, dec, lat[, ws=true]) -&gt; alt, az</code></pre><p><strong>Purpose</strong></p><p>Convert Hour Angle and Declination to Horizon (Alt-Az) coordinates.</p><p><strong>Explanation</strong></p><p>Can deal with the NCP singularity.  Intended mainly to be used by program <code>eq2hor</code>.</p><p><strong>Arguments</strong></p><p>Input coordinates may be either a scalar or an array, of the same dimension.</p><ul><li><code>ha</code>: the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined.</li><li><code>dec</code>: the local apparent declination, in degrees.</li><li><code>lat</code>: the local geodetic latitude, in degrees, scalar or array.</li><li><code>ws</code> (optional boolean keyword): if true, the output azimuth is measured West from South.  The default is to measure azimuth East from North.</li></ul><p><code>ha</code> and <code>dec</code> can be given as a 2-tuple <code>(ha, dec)</code>.</p><p><strong>Output</strong></p><p>2-tuple <code>(alt, az)</code></p><ul><li><code>alt</code>: local apparent altitude, in degrees.</li><li><code>az</code>: the local apparent azimuth, in degrees.</li></ul><p>The output coordinates are always floating points and have the same type (scalar or array) as the input coordinates.</p><p><strong>Example</strong></p><p>Arcturus is observed at an apparent hour angle of 336.6829 and a declination of 19.1825 while at the latitude of +43° 4&#39; 42&#39;&#39;.  What are the local altitude and azimuth of this object?</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; alt, az = hadec2altaz(336.6829, 19.1825, ten(43, 4, 42))
(59.08617155005685, 133.3080693440254)</code></pre><p><strong>Notes</strong></p><p><code>altaz2hadec</code> converts Horizon (Alt-Az) coordinates to Hour Angle and Declination.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.helio" href="#AstroLib.helio"><code>AstroLib.helio</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">helio(jd, list[, radians=true]) -&gt; hrad, hlong, hlat</code></pre><p><strong>Purpose</strong></p><p>Compute heliocentric coordinates for the planets.</p><p><strong>Explanation</strong></p><p>The mean orbital elements for epoch J2000 are used. These are derived from a 250 yr least squares fit of the DE 200 planetary ephemeris to a Keplerian orbit where each element is allowed to vary linearly with time. Useful mainly for dates between 1800 and 2050, this solution fits the terrestrial planet orbits to ~25&#39;&#39; or better, but achieves only ~600&#39;&#39; for Saturn.</p><p><strong>Arguments</strong></p><ul><li><code>jd</code>: julian date, scalar or vector</li><li><code>num</code>: integer denoting planet number, scalar or vector 1 = Mercury, 2 = Venus, ... 9 = Pluto</li><li><code>radians</code>(optional): if this keyword is set to <code>true</code>, than the longitude and latitude output are in radians rather than degrees.</li></ul><p><strong>Output</strong></p><ul><li><code>hrad</code>: the heliocentric radii, in astronomical units.</li><li><code>hlong</code>: the heliocentric (ecliptic) longitudes, in degrees.</li><li><code>hlat</code>: the heliocentric latitudes in degrees.</li></ul><p><strong>Example</strong></p><p>(1) Find heliocentric position of Venus on August 23, 2000</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; helio(jdcnv(2000,08,23,0), 2)
(0.7213758288364316, 198.39093251916148, 2.887355631705488)</code></pre><p>(2) Find the current heliocentric positions of all the planets</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; helio.([jdcnv(1900)], 1:9)
9-element Array{Tuple{Float64,Float64,Float64},1}:
 (0.4207394142180803, 202.60972662618906, 3.0503005607270532)
 (0.7274605731764012, 344.5381482401048, -3.3924346961624785)
 (0.9832446886519147, 101.54969268801035, 0.012669354526696368)
 (1.4212659241051142, 287.8531100442217, -1.5754626002228043)
 (5.386813769590955, 235.91306092135062, 0.9131692817310215)
 (10.054339927304339, 268.04069870870387, 1.0851704598594278)
 (18.984683376211326, 250.0555468087738, 0.05297087029604253)
 (29.87722677219009, 87.07244903504716, -1.245060583142733)
 (46.9647515992327, 75.94692594417324, -9.576681044165511)</code></pre><p><strong>Notes</strong></p><p>This program is based on the two-body model and thus neglects interactions between the planets.</p><p>The coordinates are given for equinox 2000 and <em>not</em> the equinox of the supplied date.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.helio_jd-Tuple{Real,Real,Real}" href="#AstroLib.helio_jd-Tuple{Real,Real,Real}"><code>AstroLib.helio_jd</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">helio_jd(date, ra, dec[, B1950=true, diff=false]) -&gt; jd_helio
helio_jd(date, ra, dec[, B1950=true, diff=true]) -&gt; time_diff</code></pre><p><strong>Purpose</strong></p><p>Convert geocentric (reduced) Julian date to heliocentric Julian date.</p><p><strong>Explanation</strong></p><p>This procedure corrects for the extra light travel time between the Earth and the Sun.</p><p>An online calculator for this quantity is available at http://www.physics.sfasu.edu/astro/javascript/hjd.html</p><p>Users requiring more precise calculations and documentation should look at the IDL code available at http://astroutils.astronomy.ohio-state.edu/time/</p><p><strong>Arguments</strong></p><ul><li><code>date</code>: reduced Julian date (= JD - 2400000).  You can use <code>juldate()</code> to calculate the reduced Julian date.</li><li><code>ra</code> and <code>dec</code>: right ascension and declination in degrees.  Default equinox is J2000.</li><li><code>B1950</code> (optional boolean keyword): if set to <code>true</code>, then input coordinates are assumed to be in equinox B1950 coordinates.  Default is <code>false</code>.</li><li><code>diff</code> (optional boolean keyword): if set to <code>true</code>, the function returns the time difference (heliocentric JD - geocentric JD) in seconds.  Default is <code>false</code>.</li></ul><p><strong>Output</strong></p><p>The return value depends on the value of <code>diff</code> optional keywords:</p><ul><li>if <code>diff</code> is <code>false</code> (default), then the heliocentric reduced Julian date is returned.</li><li>if <code>diff</code> is <code>true</code>, then the time difference in seconds between the geocentric and heliocentric Julian date is returned.</li></ul><p><strong>Example</strong></p><p>What is the heliocentric Julian date of an observation of V402 Cygni (J2000: RA = 20 9 7.8, Dec = 37 09 07) taken on June 15, 2016 at 11:40 UT?</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; jd = juldate(2016, 6, 15, 11, 40);

julia&gt; helio_jd(jd, ten(20, 9, 7.8) * 15, ten(37, 9, 7))
57554.98808289718</code></pre><p><strong>Notes</strong></p><p>Wayne Warren (Raytheon ITSS) has compared the results of this algorithm with the FORTRAN subroutines in the STARLINK SLALIB library (see http://star-www.rl.ac.uk/).</p><pre><code class="language-none">                                                 Time Diff (sec)
     Date               RA(2000)   Dec(2000)  STARLINK      IDL

1999-10-29T00:00:00.0  21 08 25.  -67 22 00.  -59.0        -59.0
1999-10-29T00:00:00.0  02 56 33.4 +00 26 55.  474.1        474.1
1940-12-11T06:55:00.0  07 34 41.9 -00 30 42.  366.3        370.2
1992-02-29T03:15:56.2  12 56 27.4 +42 10 17.  350.8        350.9
2000-03-01T10:26:31.8  14 28 36.7 -20 42 11.  243.7        243.7
2100-02-26T09:18:24.2  08 26 51.7 +85 47 28.  104.0        108.8</code></pre><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.helio_rv" href="#AstroLib.helio_rv"><code>AstroLib.helio_rv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">helio_rv(jd, T, P, V_0, K[, e, ω]) -&gt; rv</code></pre><p><strong>Purpose</strong></p><p>Return the heliocentric radial velocity of a spectroscopic binary.</p><p><strong>Explanation</strong></p><p>This function will return the heliocentric radial velocity of a spectroscopic binary star at a given heliocentric date given its orbit.</p><p><strong>Arguments</strong></p><ul><li><code>jd</code>: time of observation, as number of Julian days.</li><li><code>T</code>: time of periastron passage (max. +ve velocity for circular orbits), same time system as <code>jd</code></li><li><code>P</code>: the orbital period in same units as <code>jd</code></li><li><code>V_0</code>: systemic velocity</li><li><code>K</code>: velocity semi-amplitude in the same units as <code>V_0</code></li><li><code>e</code>: eccentricity of the orbit.  It defaults to 0 if omitted</li><li><code>ω</code>: longitude of periastron in degrees.  It defaults to 0 if omitted</li></ul><p><strong>Output</strong></p><p>The predicted heliocentric radial velocity in the same units as Gamma for the date(s) specified by <code>jd</code>.</p><p><strong>Example</strong></p><p>(1) What was the heliocentric radial velocity of the primary component of HU Tau at 1730 UT 25 Oct 1994?</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; jd = juldate(94, 10, 25, 17, 30); # Obtain Geocentric Julian days

julia&gt; hjd = helio_jd(jd, ten(04, 38, 16) * 15, ten(20, 41, 05)); # Convert to HJD

julia&gt; helio_rv(hjd, 46487.5303, 2.0563056, -6, 59.3)
-62.965570107789475</code></pre><p>NB: the functions <code>juldate</code> and <code>helio_jd</code> return a reduced HJD (HJD - 2400000) and so T and P must be specified in the same fashion.</p><p>(2) Plot two cycles of an eccentric orbit, <span>$e=0.6$</span>, <span>$\omega=45\degree$</span> for both components of a binary star.  Use <a href="https://github.com/JuliaPy/PyPlot.jl">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
φ = range(0, stop=2, length=1000); # Generate 1000 phase points
plot(φ ,helio_rv.(φ, 0, 1, 0, 100, 0.6, 45)) # Plot 1st component
plot(φ ,helio_rv.(φ, 0, 1, 0, 100, 0.6, 45+180)) # Plot 2nd component</code></pre><p><strong>Notes</strong></p><p>The user should ensure consistency with all time systems being used (i.e. <code>jd</code> and <code>t</code> should be in the same units and time system).  Generally, users should reduce large time values by subtracting a large constant offset, which may improve numerical accuracy.</p><p>If using the the function <code>juldate</code> and <code>helio_jd</code>, the reduced HJD time system must be used throughtout.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.hor2eq" href="#AstroLib.hor2eq"><code>AstroLib.hor2eq</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hor2eq(alt, az, jd[, obsname; ws=false, B1950=false, precession=true, nutate=true,
       aberration=true, refract=true, lat=NaN, lon=NaN, altitude=0, pressure=NaN,
       temperature=NaN]) -&gt; ra, dec, ha

hor2eq(alt, az, jd, lat, lon[, altitude=0; ws=false, B1950=false,
       precession=true, nutate=true, aberration=true, refract=true, pressure=NaN,
       temperature=NaN]) -&gt; ra, dec, ha</code></pre><p><strong>Purpose</strong></p><p>Converts local horizon coordinates (alt-az) to equatorial (ra-dec) coordinates.</p><p><strong>Explanation</strong></p><p>This is a function to calculate equatorial (ra,dec) coordinates from horizon (alt,az) coords. It is accurate to about 1 arcsecond or better. It performs precession, nutation, aberration, and refraction corrections.</p><p><strong>Arguments</strong></p><p>This function has two base methods.  With one you can specify the name of the observatory, if present in <code>AstroLib.observatories</code>, with the other one you can provide the coordinates of the observing site and, optionally, the altitude.</p><p>Common mandatory arguments:</p><ul><li><code>alt</code>: altitude of horizon coords, in degrees</li><li><code>az</code>: azimuth angle measured East from North (unless ws is <code>true</code>), in degrees</li><li><code>jd</code>: julian date</li></ul><p>Other positional arguments:</p><ul><li><code>obsname</code>: set this to a valid observatory name in <code>AstroLib.observatories</code>.</li></ul><p>or</p><ul><li><code>lat</code>: north geodetic latitude of location, in degrees.</li><li><code>lon</code>: AST longitude of location, in degrees. You can specify west longitude with a negative sign.</li><li><code>altitude</code>: the altitude of the observing location, in meters.  It is <code>0</code> by default</li></ul><p>Optional keyword arguments:</p><ul><li><code>ws</code> (optional boolean keyword): set this to <code>true</code> to get the azimuth measured westward from south. This is <code>false</code> by default</li><li><code>B1950</code> (optional boolean keyword): set this to <code>true</code> if the ra and dec are specified in B1950 (FK4 coordinates) instead of J2000 (FK5). This is <code>false</code> by default</li><li><code>precession</code> (optional boolean keyword): set this to <code>false</code> for no precession, <code>true</code> by default</li><li><code>nutate</code> (optional boolean keyword): set this to <code>false</code> for no nutation, <code>true</code> by default</li><li><code>aberration</code> (optional boolean keyword): set this to <code>false</code> for no aberration correction, <code>true</code> by default</li><li><code>refract</code> (optional boolean keyword): set this to <code>false</code> for no refraction correction, <code>true</code> by default</li><li><code>pressure</code> (optional keyword): the pressure at the observing location, in millibars. Default value is <code>NaN</code></li><li><code>temperature</code> (optional keyword): the temperature at the observing location, in Kelvins. Default value is <code>NaN</code></li></ul><p><strong>Output</strong></p><ul><li><code>ra</code>: right ascension of object, in degrees (FK5)</li><li><code>dec</code>: declination of the object, in degrees (FK5)</li><li><code>ha</code>: hour angle, in degrees</li></ul><p><strong>Example</strong></p><p>You are at Kitt Peak National Observatory, looking at a star at azimuth angle 264d 55m 06s and elevation 37d 54m 41s (in the visible). Today is Dec 25, 2041 and the local time is 10 PM precisely. What is the right ascension and declination (J2000) of the star you&#39;re looking at? The temperature here is about 0 Celsius, and the pressure is 781 millibars. The Julian date for this time is 2466879.7083333</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; ra_o, dec_o = hor2eq(ten(37,54,41), ten(264,55,06), 2466879.7083333,
                            &quot;kpno&quot;, pressure = 781, temperature = 273)
(3.3224480269254717, 15.19061543702944, 54.61174536229464)

julia&gt; adstring(ra_o, dec_o)
&quot; 00 13 17.4  +15 11 26&quot;</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.imf-Tuple{AbstractArray{#s757,1} where #s757&lt;:Real,AbstractArray{#s756,1} where #s756&lt;:Real,AbstractArray{#s755,1} where #s755&lt;:Real}" href="#AstroLib.imf-Tuple{AbstractArray{#s757,1} where #s757&lt;:Real,AbstractArray{#s756,1} where #s756&lt;:Real,AbstractArray{#s755,1} where #s755&lt;:Real}"><code>AstroLib.imf</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">imf(mass, expon, mass_range) -&gt; psi</code></pre><p><strong>Purpose</strong></p><p>Compute an N-component power-law logarithmic initial mass function (IMF).</p><p><strong>Explanation</strong></p><p>The function is normalized so that the total mass distribution equals one solar mass.</p><p><strong>Arguments</strong></p><ul><li><code>mass</code>: mass in units of solar mass, vector.</li><li><code>expon</code>: power law exponent, vector. The number of values in expon equals the number of different power-law components in the IMF.</li><li><code>mass_range</code>: vector containing the mass upper and lower limits of the IMF and masses where the IMF exponent changes. The number of values in mass<em>range should be one more than in expon. The values in mass</em>range should be monotonically increasing and positive.</li></ul><p><strong>Output</strong></p><ul><li><code>psi</code>: mass function, number of stars per unit logarithmic mass interval evaluated for supplied masses.</li></ul><p><strong>Example</strong></p><p>Show the number of stars per unit mass interval at 3 Msun for a Salpeter (expon = -1.35) IMF, with a mass range from 0.1 MSun to 110 Msun.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; imf([3], [-1.35], [0.1, 110]) / 3
1-element Array{Float64,1}:
 0.01294143518151214</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.ismeuv" href="#AstroLib.ismeuv"><code>AstroLib.ismeuv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ismeuv(wave, hcol[, he1col=hcol*0.1, he2col=0, fano=false]) -&gt; tau</code></pre><p><strong>Purpose</strong></p><p>Compute the continuum interstellar EUV optical depth</p><p><strong>Explanation</strong></p><p>The EUV optical depth is computed from the photoionization of hydrogen and helium.</p><p><strong>Arguments</strong></p><ul><li><code>wave</code>: wavelength value (in Angstroms). Useful range is 40 - 912 A; at shorter wavelength metal opacity should be considered, at longer wavelengths there is no photoionization.</li><li><code>hcol</code>: interstellar hydrogen column density in cm-2.</li><li><code>he1col</code> (optional): neutral helium column density in cm-2. Default is 0.1*hcol (10% of hydrogen column)</li><li><code>he2col</code> (optional): ionized helium column density in cm-2 Default is 0.</li><li><code>fano</code> (optional boolean keyword): If this keyword is true, then the 4 strongest auto-ionizing resonances of He I are included. The shape of these resonances is given by a Fano profile - see Rumph, Bowyer, &amp; Vennes 1994, AJ, 107, 2108. If these resonances are included then the input wavelength vector should have a fine (&gt;~0.01 A) grid between 190 A and 210 A, since the resonances are very narrow.</li></ul><p><strong>Output</strong></p><ul><li><code>tau</code>: Vector giving resulting optical depth, non-negative values.</li></ul><p><strong>Example</strong></p><p>One has a model EUV spectrum with wavelength, w (in Angstroms). Find the EUV optical depth by 1e18 cm-2 of HI, with N(HeI)/N(HI) = N(HeII)/N(HI) = 0.05.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; ismeuv.([670, 910], 1e19, 5e17, 5e17)
2-element Array{Float64,1}:
 27.35393320556168
 62.683796028917286</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.jdcnv" href="#AstroLib.jdcnv"><code>AstroLib.jdcnv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">jdcnv(date) -&gt; julian_days</code></pre><p><strong>Purpose</strong></p><p>Convert proleptic Gregorian Calendar date in UTC standard to number of Julian days.</p><p><strong>Explanation</strong></p><p>Takes the given proleptic Gregorian date in UTC standard and returns the number of Julian calendar days since epoch <code>-4713-11-24T12:00:00</code>.</p><p><strong>Argument</strong></p><ul><li><code>date</code>: date in proleptic Gregorian Calendar.  Each element can be either a <code>DateTime</code> or anything that can be converted directly to <code>DateTime</code>.</li></ul><p><strong>Output</strong></p><p>Number of Julian days, as a floating point.</p><p><strong>Example</strong></p><p>Find the Julian days number at 2016 August 23, 03:39:06.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib, Dates

julia&gt; jdcnv(DateTime(2016, 08, 23, 03, 39, 06))
2.4576236521527776e6

julia&gt; jdcnv(2016, 08, 23, 03, 39, 06)
2.4576236521527776e6

julia&gt; jdcnv(&quot;2016-08-23T03:39:06&quot;)
2.4576236521527776e6</code></pre><p><strong>Notes</strong></p><p>This is the inverse of <code>daycnv</code>.</p><p><code>get_juldate</code> returns the number of Julian days for current time.  It is equivalent to <code>jdcnv(now(Dates.UTC))</code>.</p><p>For the conversion of Julian date to number of Julian days, use <code>juldate</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.jprecess" href="#AstroLib.jprecess"><code>AstroLib.jprecess</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">jprecess(ra, dec[, epoch]) -&gt; ra2000, dec2000
jprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -&gt; ra2000, dec2000</code></pre><p><strong>Purpose</strong></p><p>Precess positions from B1950.0 (FK4) to J2000.0 (FK5).</p><p><strong>Explanation</strong></p><p>Calculate the mean place of a star at J2000.0 on the FK5 system from the mean place at B1950.0 on the FK4 system.</p><p><code>jprecess</code> function has two methods, one for each of the following cases:</p><ul><li>the proper motion is known and non-zero</li><li>the proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations.</li></ul><p><strong>Arguments</strong></p><p>The function has 2 methods.  The common mandatory arguments are:</p><ul><li><code>ra</code>: input B1950 right ascension, in degrees.</li><li><code>dec</code>: input B1950 declination, in degrees.</li></ul><p>The two methods have a different third argument (see &quot;Explanation&quot; section for more details).  It can be one of the following:</p><ul><li><code>muradec</code>: 2-element vector containing the proper motion in seconds of arc per tropical <em>century</em> in right ascension and declination.</li><li><code>epoch</code>: scalar giving epoch of original observations.</li></ul><p>If none of these two arguments is provided (so <code>jprecess</code> is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and <code>epoch = 1950</code>.</p><p>If it is used the method involving <code>muradec</code> argument, the following keywords are available:</p><ul><li><code>parallax</code> (optional numerical keyword): stellar parallax, in seconds of arc.</li><li><code>radvel</code> (optional numerical keyword): radial velocity in km/s.</li></ul><p>Right ascension and declination can be passed as the 2-tuple <code>(ra, dec)</code>.  You can also pass <code>ra</code>, <code>dec</code>, <code>parallax</code>, and <code>radvel</code> as arrays, all of the same length N.  In that case, <code>muradec</code> should be a matrix 2×N.</p><p><strong>Output</strong></p><p>The 2-tuple of right ascension and declination in 2000, in degrees, of input coordinates is returned.  If <code>ra</code> and <code>dec</code> (and other possible optional arguments) are arrays, the 2-tuple of arrays <code>(ra2000, dec2000)</code> of the same length as the input coordinates is returned.</p><p><strong>Method</strong></p><p>The algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 184.  See also Aoki et al (1983), A&amp;A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A.</p><p><strong>Example</strong></p><p>The SAO catalogue gives the B1950 position and proper motion for the star HD 119288.   Find the J2000 position.</p><ul><li>RA(1950) = 13h 39m 44.526s</li><li>Dec(1950) = 8d 38&#39; 28.63&#39;&#39;</li><li>Mu(RA) = -.0259 s/yr</li><li>Mu(Dec) = -.093 &#39;&#39;/yr</li></ul><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; muradec = 100 * [-15*0.0259, -0.093]; # convert to century proper motion

julia&gt; ra = ten(13, 39, 44.526)*15;

julia&gt; decl = ten(8, 38, 28.63);

julia&gt; adstring(jprecess(ra, decl, muradec), precision=2)
&quot; 13 42 12.740  +08 23 17.69&quot;</code></pre><p><strong>Notes</strong></p><p>&quot;When transferring individual observations, as opposed to catalog mean place, the safest method is to tranform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0&quot; – from the Explanatory Supplement (1992), p. 180</p><p><code>bprecess</code> performs the precession to B1950 coordinates.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.juldate-Tuple{Dates.DateTime}" href="#AstroLib.juldate-Tuple{Dates.DateTime}"><code>AstroLib.juldate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">juldate(date::DateTime) -&gt; reduced_julia_days</code></pre><p><strong>Purpose</strong></p><p>Convert from calendar to Reduced Julian Days.</p><p><strong>Explanation</strong></p><p>Julian Day Number is a count of days elapsed since Greenwich mean noon on 1 January 4713 B.C.  Julian Days are the number of Julian days followed by the fraction of the day elapsed since the preceding noon.</p><p>This function takes the given <code>date</code> and returns the number of Julian calendar days since epoch <code>1858-11-16T12:00:00</code> (Reduced Julian Days = Julian Days - 2400000).</p><p><strong>Argument</strong></p><ul><li><code>date</code>: date in Julian Calendar, UTC standard.  Each element can be given in <code>DateTime</code> type or anything that can be converted to that type.</li></ul><p><strong>Output</strong></p><p>The number of Reduced Julian Days is returned.</p><p><strong>Example</strong></p><p>Get number of Reduced Julian Days at 2016-03-20T15:24:00.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib, Dates

julia&gt; juldate(DateTime(2016, 03, 20, 15, 24))
57468.14166666667

julia&gt; juldate(2016, 03, 20, 15, 24)
57468.14166666667

julia&gt; juldate(&quot;2016-03-20T15:24&quot;)
57468.14166666667</code></pre><p><strong>Notes</strong></p><p>Julian Calendar is assumed, thus before <code>1582-10-15T00:00:00</code> this function is <em>not</em> the inverse of <code>daycnv</code>.  For the conversion proleptic Gregorian date to number of Julian days, use <code>jdcnv</code>, which is the inverse of <code>daycnv</code>.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.kepler_solver-Tuple{Real,Real}" href="#AstroLib.kepler_solver-Tuple{Real,Real}"><code>AstroLib.kepler_solver</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">kepler_solver(M, e) -&gt; E</code></pre><p><strong>Purpose</strong></p><p>Solve Kepler&#39;s equation in the elliptic motion regime (<span>$0 \leq e \leq 1$</span>) and return eccentric anomaly <span>$E$</span>.</p><p><strong>Explanation</strong></p><p>In order to find the position of a body in elliptic motion (e.g., in the two-body problem) at a given time <span>$t$</span>, one has to solve the <a href="https://en.wikipedia.org/wiki/Kepler%27s_equation">Kepler&#39;s equation</a></p><p><span>$M(t) = E(t) - e\sin E(t)$</span></p><p>where <span>$M(t) = (t - t_{0})/P$</span> is the mean anomaly, <span>$E(t)$</span> the eccentric anomaly, <span>$e$</span> the eccentricity of the orbit, <span>$t_0$</span> is the time of periapsis passage, and <span>$P$</span> is the period of the orbit.  Usually the eccentricity is given and one wants to find the eccentric anomaly <span>$E(t)$</span> at a specific time <span>$t$</span>, so that also the mean anomaly <span>$M(t)$</span> is known.</p><p><strong>Arguments</strong></p><ul><li><code>M</code>: mean anomaly.</li><li><code>e</code>: eccentricity, in the elliptic motion regime (<span>$0 \leq e \leq 1$</span>)</li></ul><p><strong>Output</strong></p><p>The eccentric anomaly <span>$E$</span>, restricted to the range <span>$[-\pi, \pi]$</span>.</p><p><strong>Method</strong></p><p>Many different numerical methods exist to solve Kepler&#39;s equation.  This function implements the algorithm proposed in Markley (1995) Celestial Mechanics and Dynamical Astronomy, 63, 101 (DOI:<a href="http://dx.doi.org/10.1007/BF00691917">10.1007/BF00691917</a>).  This method is not iterative, requires only four transcendental function evaluations, and has been proved to be fast and efficient over the entire range of elliptic motion <span>$0 \leq e \leq 1$</span>.</p><p><strong>Example</strong></p><p>(1) Find the eccentric anomaly for an orbit with eccentricity <span>$e = 0.7$</span> and for <span>$M(t) = 8\pi/3$</span>.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; ecc = 0.7;

julia&gt; E = kepler_solver(8pi/3, ecc)
2.5085279492864223</code></pre><p>(2) Plot the eccentric anomaly as a function of mean anomaly for eccentricity <span>$e = 0$</span>, <span>$0.5$</span>, <span>$0.9$</span>.  Recall that <code>kepler_solver</code> gives <span>$E \in [-\pi, \pi]$</span>, use <code>mod2pi</code> to have it in <span>$[0, 2\pi]$</span>.  Use <a href="https://github.com/JuliaPlots/Plots.jl/">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using AstroLib, PyPlot
M = range(0, stop=2pi, length=1001)[1:end-1];
for ecc in (0, 0.5, 0.9); plot(M, mod2pi.(kepler_solver.(M, ecc))); end</code></pre><p><strong>Notes</strong></p><p>The true anomaly can be calculated with <code>trueanom</code> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.lsf_rotate" href="#AstroLib.lsf_rotate"><code>AstroLib.lsf_rotate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lsf_rotate(delta_v, v_sin_i[, epsilon = 0.3]) -&gt; velocity_grid, lsf</code></pre><p><strong>Purpose</strong></p><p>Create a 1-d convolution kernel to broaden a spectrum from a rotating star.</p><p><strong>Explanation</strong></p><p>Can be used to derive the broadening effect (LSF, line spread function) due to rotation on a synthetic stellar spectrum.  Assumes constant limb darkening across the disk.</p><p><strong>Arguments</strong></p><ul><li><p><code>delta_v</code>: the step increment (in km/s) in the output rotation kernel</p></li><li><p><code>v_sin_i</code>: the rotational velocity projected along the line of sight (km/s)</p></li><li><p><code>epsilon</code> (optional numeric argument): the limb-darkening coefficient, default = 0.6 which is typical for photospheric lines.  The specific intensity <span>$I$</span> at any angle <span>$\theta$</span> from the specific intensity <span>$I_{\text{cen}}$</span> at the center of the disk is given by:</p><p><span>$I = I_{\text{cen}}\cdot(1 - \varepsilon\cdot(1 - \cos(\theta)))$</span></p></li></ul><p><strong>Output</strong></p><p>The 2-tuple (<code>velocity_grid</code>, <code>lsf</code>):</p><ul><li><code>velocity_grid</code>: vector of velocity grid with the same number of elements as <code>lsf</code> (see below)</li><li><code>lsf</code>: the convolution kernel vector for the specified rotational velocity. The number of points in <code>lsf</code> will be always be odd (the kernel is symmetric) and equal to either <code>ceil(2*v_sin_i/delta_v)</code> or <code>ceil(2*v_sin_i/delta_v) + 1</code>, whichever number is odd.  Elements of <code>lsf</code> will always be of type <code>AbstractFloat</code>.  To actually compute the broadening, the spectrum should be convolved with the rotational <code>lsf</code></li></ul><p><strong>Example</strong></p><p>Plot the line spread function for a star rotating at 90 km/s in velocity space every 3 km/s.  Use <a href="https://github.com/JuliaPlots/Plots.jl/">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
plot(lsf_rotate(3, 90)...)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.mag2flux" href="#AstroLib.mag2flux"><code>AstroLib.mag2flux</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mag2flux(mag[, zero_point, ABwave=number]) -&gt; flux</code></pre><p><strong>Purpose</strong></p><p>Convert from magnitudes to flux expressed in erg/(s cm² Å).</p><p><strong>Explanation</strong></p><p>This is the reverse of <code>flux2mag</code>.</p><p><strong>Arguments</strong></p><ul><li><code>mag</code>: the magnitude to be converted in flux.</li><li><code>zero_point</code>: the zero point level of the magnitude.  If not supplied then defaults to</li></ul><p>21.1 (Code et al 1976).  Ignored if the <code>ABwave</code> keyword is supplied</p><ul><li><code>ABwave</code> (optional numeric keyword): wavelength, in Angstroms.  If supplied, then the</li></ul><p>input <code>mag</code> is assumed to contain Oke AB magnitudes (Oke &amp; Gunn 1983, ApJ, 266, 713;  http://adsabs.harvard.edu/abs/1983ApJ...266..713O).</p><p><strong>Output</strong></p><p>The flux.</p><p>If the <code>ABwave</code> keyword is set, then the flux is given by the expression</p><div>\[\text{flux} = 10^{-0.4(\text{mag} +2.406 + 4\log_{10}(\text{ABwave}))}\]</div><p>Otherwise the flux is given by</p><div>\[\text{flux} =  10^{-0.4(\text{mag} + \text{zero point})}\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; mag2flux(8.3)
1.7378008287493692e-12

julia&gt; mag2flux(8.3, 12)
7.58577575029182e-9

julia&gt; mag2flux(8.3, ABwave=12)
3.6244115683017193e-7</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.mag2geo" href="#AstroLib.mag2geo"><code>AstroLib.mag2geo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mag2geo(latitude, longitude[, year]) -&gt; geographic_latitude, geographic_longitude</code></pre><p><strong>Purpose</strong></p><p>Convert from geomagnetic to geographic coordinates.</p><p><strong>Explanation</strong></p><p>Converts from geomagnetic (latitude, longitude) to geographic (latitude, longitude).  Altitude is not involved in this function.</p><p><strong>Arguments</strong></p><ul><li><code>latitude</code>: geomagnetic latitude (North), in degrees.</li><li><code>longitude</code>: geomagnetic longitude (East), in degrees.</li><li><code>year</code> (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year.</li></ul><p>The coordinates can be passed as arrays of the same length.</p><p><strong>Output</strong></p><p>The 2-tuple of geographic (latitude, longitude) coordinates, in degrees.</p><p>If geomagnetic coordinates are given as arrays, a 2-tuple of arrays of the same length is returned.</p><p><strong>Example</strong></p><p>Find position of North Magnetic Pole in 2016</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; mag2geo(90, 0, 2016)
(86.395, -166.29000000000002)</code></pre><p><strong>Notes</strong></p><p>This function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy).</p><p><code>geo2mag</code> converts geographic coordinates to geomagnetic coordinates.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.mean_obliquity-Tuple{Real}" href="#AstroLib.mean_obliquity-Tuple{Real}"><code>AstroLib.mean_obliquity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mean_obliquity(jd) -&gt; m_eps</code></pre><p><strong>Purpose</strong></p><p>Return the mean obliquity of the ecliptic for a given Julian date</p><p><strong>Explanation</strong></p><p>The function is used by the <a href="#AstroLib.co_nutate-Tuple{Real,Real,Real}"><code>co_nutate</code></a> procedure.</p><p><strong>Arguments</strong></p><ul><li><code>jd</code>: julian date</li></ul><p><strong>Output</strong></p><ul><li><code>m_eps</code>: mean obliquity of the ecliptic, in radians</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; mean_obliquity(jdcnv(1978,01,7,11, 01))
0.4091425159336512</code></pre><p><strong>Notes</strong></p><p>The algorithm used to find the mean obliquity(<code>eps0</code>) is mentioned in USNO Circular 179, but the canonical reference for the IAU adoption is apparently Hilton et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 2000</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.month_cnv-Tuple{Integer}" href="#AstroLib.month_cnv-Tuple{Integer}"><code>AstroLib.month_cnv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">month_cnv(number[, shor=true, up=true, low=true]) -&gt; month_name
month_cnv(name) -&gt; number</code></pre><p><strong>Purpose</strong></p><p>Convert between a month English name and  the equivalent number.</p><p><strong>Explanation</strong></p><p>For example, converts from &quot;January&quot; to 1  or vice-versa.</p><p><strong>Arguments</strong></p><p>The functions has two methods, one with numeric input (and three possible boolean keywords) and the other one with string input.</p><p>Numeric input arguments:</p><ul><li><code>number</code>: the number of the month to be converted to month name.</li><li><code>short</code> (optional boolean keyword): if true, the abbreviated (3-character) name of the month will be returned, e.g. &quot;Apr&quot; or &quot;Oct&quot;.  Default is false.</li><li><code>up</code> (optional boolean keyword): if true, the name of the month will be all in upper case, e.g. &quot;APRIL&quot; or &quot;OCTOBER&quot;.  Default is false.</li><li><code>low</code> (optional boolean keyword): if true, the name of the month will be all in lower case, e.g. &quot;april&quot; or &quot;october&quot;.  Default is false.</li></ul><p>String input argument:</p><ul><li><code>name</code>: month name to be converted to month number.</li></ul><p><strong>Output</strong></p><p>The month name or month number, depending on the input.  For numeric input, the format of the month name is influenced by the optional keywords.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; month_cnv.([&quot;janua&quot;, &quot;SEP&quot;, &quot;aUgUsT&quot;])
3-element Array{Int64,1}:
 1
 9
 8

julia&gt; month_cnv.([2, 12, 6], short=true, low=true)
3-element Array{String,1}:
 &quot;feb&quot;
 &quot;dec&quot;
 &quot;jun&quot;</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.moonpos-Tuple{Real}" href="#AstroLib.moonpos-Tuple{Real}"><code>AstroLib.moonpos</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">moonpos(jd[, radians=true]) -&gt; ra, dec, dis, geolong, geolat</code></pre><p><strong>Purpose</strong></p><p>Compute the right ascension and declination of the Moon at specified Julian date.</p><p><strong>Arguments</strong></p><ul><li><code>jd</code>: the Julian ephemeris date.  It can be either a scalar or an array</li><li><code>radians</code> (optional boolean keyword): if set to <code>true</code>, then all output angular quantities are given in radians rather than degrees.  The default is <code>false</code></li></ul><p><strong>Output</strong></p><p>The 5-tuple <code>(ra, dec, dis, geolong, geolat)</code>:</p><ul><li><code>ra</code>: apparent right ascension of the Moon in degrees, referred to the true equator of the specified date(s)</li><li><code>dec</code>: the declination of the Moon in degrees</li><li><code>dis</code>: the distance between the centre of the Earth and the centre of the Moon in kilometers</li><li><code>geolong</code>: apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s)</li><li><code>geolat</code>: apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s)</li></ul><p>If <code>jd</code> is an array, then all output quantities are arrays of the same length as <code>jd</code>.</p><p><strong>Method</strong></p><p>Derived from the Chapront ELP2000/82 Lunar Theory (Chapront-Touze&#39; and Chapront, 1983, 124, 50), as described by Jean Meeus in Chapter 47 of ``Astronomical Algorithms&#39;&#39; (Willmann-Bell, Richmond), 2nd edition, 1998.  Meeus quotes an approximate accuracy of 10&quot; in longitude and 4&quot; in latitude, but he does not give the time range for this accuracy.</p><p>Comparison of the IDL procedure with the example in ``Astronomical Algorithms&#39;&#39; reveals a very small discrepancy (~1 km) in the distance computation, but no difference in the position calculation.</p><p><strong>Example</strong></p><p>(1) Find the position of the moon on April 12, 1992</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; jd = jdcnv(1992, 4, 12);

julia&gt; adstring(moonpos(jd)[1:2],precision=1)
&quot; 08 58 45.23  +13 46 06.1&quot;</code></pre><p>This is within 1&quot; from the position given in the Astronomical Almanac.</p><p>(2) Plot the Earth-moon distance during 2016 with sampling of 6 hours.  Use <a href="https://github.com/JuliaPlots/Plots.jl/">PyPlot.jl</a> for plotting</p><pre><code class="language-julia">using PyPlot
points = DateTime(2016):Dates.Hour(6):DateTime(2017);
plot(points, moonpos(jdcnv.(points))[3])</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.mphase-Tuple{Real}" href="#AstroLib.mphase-Tuple{Real}"><code>AstroLib.mphase</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mphase(jd) -&gt; k</code></pre><p><strong>Purpose</strong></p><p>Return the illuminated fraction of the Moon at given Julian date(s).</p><p><strong>Arguments</strong></p><ul><li><code>jd</code>: the Julian ephemeris date.</li></ul><p><strong>Output</strong></p><p>The illuminated fraction <span>$k$</span> of Moon&#39;s disk, with <span>$0 \leq k \leq 1$</span>. <span>$k = 0$</span> indicates a new moon, while <span>$k = 1$</span> stands for a full moon.</p><p><strong>Method</strong></p><p>Algorithm from Chapter 46 of &quot;Astronomical Algorithms&quot; by Jean Meeus (Willmann-Bell, Richmond) 1991.  <code>sunpos</code> and <code>moonpos</code> are used to get positions of the Sun and the Moon, and the Moon distance.  The selenocentric elongation of the Earth from the Sun (phase angle) is then computed, and used to determine the illuminated fraction.</p><p><strong>Example</strong></p><p>Plot the illuminated fraction of the Moon for every day in January 2018 with a hourly sampling.  Use <a href="https://github.com/JuliaPlots/Plots.jl/">PyPlot.jl</a> for plotting</p><pre><code class="language-julia">using PyPlot
points = DateTime(2018,01,01):Dates.Hour(1):DateTime(2018,01,31,23,59,59);
plot(points, mphase.(jdcnv.(points)))</code></pre><p>Note that in this calendar month there are two full moons, this event is called <a href="https://en.wikipedia.org/wiki/Blue_moon">blue moon</a>.</p><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.nutate-Tuple{Real}" href="#AstroLib.nutate-Tuple{Real}"><code>AstroLib.nutate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">nutate(jd) -&gt; long, obliq</code></pre><p><strong>Purpose</strong></p><p>Return the nutation in longitude and obliquity for a given Julian date.</p><p><strong>Arguments</strong></p><ul><li><code>jd</code>: Julian ephemeris date, it can be either a scalar or a vector</li></ul><p><strong>Output</strong></p><p>The 2-tuple <code>(long, obliq)</code>, where</p><ul><li><code>long</code>: the nutation in longitude</li><li><code>obl</code>: the nutation in latitude</li></ul><p>If <code>jd</code> is an array, <code>long</code> and <code>obl</code> are arrays of the same length.</p><p><strong>Method</strong></p><p>Uses the formula in Chapter 22 of ``Astronomical Algorithms&#39;&#39; by Jean Meeus (1998, 2nd ed.) which is based on the 1980 IAU Theory of Nutation and includes all terms larger than 0.0003&quot;.</p><p><strong>Example</strong></p><p>(1) Find the nutation in longitude and obliquity 1987 on Apr 10 at Oh.  This is example 22.a from Meeus</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; jd = jdcnv(1987, 4, 10);

julia&gt; nutate(jd)
(-3.7879310771104917, 9.442520698644492)</code></pre><p>(2) Plot the daily nutation in longitude and obliquity during the 21st century. Use <a href="https://github.com/JuliaPlots/Plots.jl/">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
years = DateTime(2000):DateTime(2100);
long, obl = nutate(jdcnv.(years));
plot(years, long); plot(years, obl)</code></pre><p>You can see both the dominant large scale period of nutation, of 18.6 years, and smaller oscillations with shorter periods.</p><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.ordinal-Tuple{Integer}" href="#AstroLib.ordinal-Tuple{Integer}"><code>AstroLib.ordinal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ordinal(num) -&gt; result</code></pre><p><strong>Purpose</strong></p><p>Convert an integer to a correct English ordinal string.</p><p><strong>Explanation</strong></p><p>The first four ordinal strings are &quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;, &quot;4th&quot; ....</p><p><strong>Arguments</strong></p><ul><li><code>num</code>: number to be made ordinal. It should be of type int.</li></ul><p><strong>Output</strong></p><ul><li><code>result</code>: ordinal string, such as &#39;1st&#39; &#39;3rd &#39;164th&#39; &#39;87th&#39; etc</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; ordinal.(1:5)
5-element Array{String,1}:
 &quot;1st&quot;
 &quot;2nd&quot;
 &quot;3rd&quot;
 &quot;4th&quot;
 &quot;5th&quot;</code></pre><p><strong>Notes</strong></p><p>This function does not support float arguments, unlike the IDL implementation. Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.paczynski-Tuple{Real}" href="#AstroLib.paczynski-Tuple{Real}"><code>AstroLib.paczynski</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">paczynski(u) -&gt; amplification</code></pre><p><strong>Purpose</strong></p><p>Calculate gravitational microlensing amplification of a point-like source by a single point-like lens.</p><p><strong>Explanation</strong></p><p>Return the <a href="https://en.wikipedia.org/wiki/Gravitational_microlensing">gravitational microlensing</a> amplification of a point-like source by a single point-like lens, using Paczyński formula</p><div>\[A(u) = \frac{u^2 + 2}{u\sqrt{u^2 + 4}}\]</div><p>where <span>$u$</span> is the projected distance between the lens and the source in units of <a href="https://en.wikipedia.org/wiki/Einstein_radius">Einstein radii</a>.</p><p>In order to speed up calculations for extreme values of <span>$u$</span>, the following asyntotic expressions for <span>$A(u)$</span> are used:</p><div>\[A(u) =
\begin{cases}
 1/u &amp; |u| \ll 1 \\
 \text{sgn}(u) &amp; |u| \gg 1
\end{cases}\]</div><p><strong>Arguments</strong></p><ul><li><code>u</code>: projected distance between the lens and the source, in units of Einstein radii</li></ul><p><strong>Output</strong></p><p>The microlensing amplification for the given distance.</p><p><strong>Example</strong></p><p>Calculate the microlensing amplification for <span>$u = 10^{-10}$</span>, <span>$10^{-1}$</span>, <span>$1$</span>, <span>$10$</span>, <span>$10^{10}$</span>:</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; paczynski.([1e-10, 1e-1, 1, 10, 1e10])
5-element Array{Float64,1}:
  1.0e10
 10.037461005722337
  1.3416407864998738
  1.0001922892047386
  1.0</code></pre><p><strong>Notes</strong></p><p>The expression of <span>$A(u)$</span> of microlensing amplification has been given by Bohdan Paczyński in</p><ul><li>Paczynski, B. 1986, ApJ, 304, 1. DOI:<a href="http://dx.doi.org/10.1086/164140">10.1086/164140</a>, Bibcode:<a href="http://adsabs.harvard.edu/abs/1986ApJ...304....1P">1986ApJ...304....1P</a></li></ul><p>The same expression was actually found by Albert Einstein half a century earlier:</p><ul><li>Einstein, A. 1936, Science, 84, 506. DOI:<a href="http://dx.doi.org/10.1126/science.84.2188.506">10.1126/science.84.2188.506</a>, Bibcode:<a href="http://adsabs.harvard.edu/abs/1936Sci....84..506E">1936Sci....84..506E</a></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.planck_freq-Tuple{Real,Real}" href="#AstroLib.planck_freq-Tuple{Real,Real}"><code>AstroLib.planck_freq</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">planck_freq(frequency, temperature) -&gt; black_body_flux</code></pre><p><strong>Purpose</strong></p><p>Calculate the flux of a black body per unit frequency.</p><p><strong>Explanation</strong></p><p>Return the spectral radiance of a black body per unit frequency using <a href="https://en.wikipedia.org/wiki/Planck%27s_law">Planck&#39;s law</a></p><p><span>$B_\nu(\nu, T) = \frac{2h\nu ^3}{c^2} \frac{1}{e^\frac{h\nu}{k_\mathrm{B}T} - 1}$</span></p><p><strong>Arguments</strong></p><ul><li><code>frequency</code>: frequency at which the flux is to be calculated, in Hertz.</li><li><code>temperature</code>: the equilibrium temperature of the black body, in Kelvin.</li></ul><p><strong>Output</strong></p><p>The spectral radiance of the black body, in units of W/(sr·m²·Hz).</p><p><strong>Example</strong></p><p>Plot the spectrum of a black body in <span>$[10^{12}, 10^{15.4}]$</span> Hz at <span>$8000$</span> K. Use <a href="https://github.com/JuliaPlots/Plots.jl/">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
frequency = exp10.(range(12, stop=15.4, length=1000));
temperature = ones(frequency)*8000;
flux = planck_freq.(frequency, temperature);
plot(frequency, flux)</code></pre><p><strong>Notes</strong></p><p><code>planck_wave</code> calculates the flux of a black body per unit wavelength.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.planck_wave-Tuple{Real,Real}" href="#AstroLib.planck_wave-Tuple{Real,Real}"><code>AstroLib.planck_wave</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">planck_wave(wavelength, temperature) -&gt; black_body_flux</code></pre><p><strong>Purpose</strong></p><p>Calculate the flux of a black body per unit wavelength.</p><p><strong>Explanation</strong></p><p>Return the spectral radiance of a black body per unit wavelength using <a href="https://en.wikipedia.org/wiki/Planck%27s_law">Planck&#39;s law</a></p><p><span>$B_\lambda(\lambda, T) =\frac{2hc^2}{\lambda^5}\frac{1}{e^{\frac{hc}{\lambda k_\mathrm{B}T}} - 1}$</span></p><p><strong>Arguments</strong></p><ul><li><code>wavelength</code>: wavelength at which the flux is to be calculated, in meters.</li><li><code>temperature</code>: the equilibrium temperature of the black body, in Kelvin.</li></ul><p><strong>Output</strong></p><p>The spectral radiance of the black body, in units of W/(sr·m³).</p><p><strong>Example</strong></p><p>Plot the spectrum of a black body in <span>$[0, 3]$</span> µm at <span>$5000$</span> K.  Use <a href="https://github.com/JuliaPlots/Plots.jl/">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
wavelength = range(0, stop=3e-6, length=1000);
temperature = ones(wavelength)*5000;
flux = planck_wave.(wavelength, temperature);
plot(wavelength, flux)</code></pre><p><strong>Notes</strong></p><p><code>planck_freq</code> calculates the flux of a black body per unit frequency.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.planet_coords-Tuple{Real,Integer}" href="#AstroLib.planet_coords-Tuple{Real,Integer}"><code>AstroLib.planet_coords</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">planet_coords(date, num)</code></pre><p><strong>Purpose</strong></p><p>Find right ascension and declination for the planets when provided a date as input.</p><p><strong>Explanation</strong></p><p>This function uses the <a href="#AstroLib.helio"><code>helio</code></a> to get the heliocentric ecliptic coordinates of the planets at the given date which it then converts these to geocentric ecliptic coordinates ala &quot;Astronomical Algorithms&quot; by Jean Meeus (1991, p 209). These are then converted to right ascension and declination using <a href="#AstroLib.euler-Tuple{Real,Real,Integer}"><code>euler</code></a>.</p><p>The accuracy between the years 1800 and 2050 is better than 1 arcminute for the terrestial planets, but reaches 10 arcminutes for Saturn. Before 1850 or after 2050 the accuracy can get much worse.</p><p><strong>Arguments</strong></p><ul><li><code>date</code>: Can be either a single date or an array of dates. Each element can be either a <code>DateTime</code> type or Julian Date. It can be a scalar or vector.</li><li><code>num</code>: integer denoting planet number, scalar or vector 1 = Mercury, 2 = Venus, ... 9 = Pluto. If not in that change, then the program will throw an error.</li></ul><p><strong>Output</strong></p><ul><li><code>ra</code>: right ascension of planet(J2000), in degrees</li><li><code>dec</code>: declination of the planet(J2000), in degrees</li></ul><p><strong>Example</strong></p><p>Find the RA, Dec of Venus on 1992 Dec 20</p><pre><code class="language-julia-repl">julia&gt; using AstroLib, Dates

julia&gt; adstring(planet_coords(DateTime(1992,12,20),2))
&quot; 21 05 02.8  -18 51 41&quot;</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.polrec-Tuple{Real,Real}" href="#AstroLib.polrec-Tuple{Real,Real}"><code>AstroLib.polrec</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">polrec(radius, angle[, degrees=true]) -&gt; x, y</code></pre><p><strong>Purpose</strong></p><p>Convert 2D polar coordinates to rectangular coordinates.</p><p><strong>Explanation</strong></p><p>This is the partial inverse function of <code>recpol</code>.</p><p><strong>Arguments</strong></p><ul><li><code>radius</code>: radial coordinate of the point.  It may be a scalar or an array.</li><li><code>angle</code>: the angular coordinate of the point.  It may be a scalar or an array of the same lenth as <code>radius</code>.</li><li><code>degrees</code> (optional boolean keyword): if <code>true</code>, the <code>angle</code> is assumed to be in degrees, otherwise in radians.  It defaults to <code>false</code>.</li></ul><p>Mandatory arguments can also be passed as the 2-tuple <code>(radius, angle)</code>, so that it is possible to execute <code>recpol(polrec(radius, angle))</code>.</p><p><strong>Output</strong></p><p>A 2-tuple <code>(x, y)</code> with the rectangular coordinate of the input.  If <code>radius</code> and <code>angle</code> are arrays, <code>x</code> and <code>y</code> are arrays of the same length as <code>radius</code> and <code>angle</code>.</p><p><strong>Example</strong></p><p>Get rectangular coordinates <span>$(x, y)$</span> of the point with polar coordinates <span>$(r, \varphi) = (1.7, 227)$</span>, with angle <span>$\varphi$</span> expressed in degrees.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; x, y = polrec(1.7, 227, degrees=true)
(-1.1593972121062475, -1.2433012927525897)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.posang-Tuple{Integer,Real,Real,Real,Real}" href="#AstroLib.posang-Tuple{Integer,Real,Real,Real,Real}"><code>AstroLib.posang</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">posang(units, ra1, dec1, ra2, dec2) -&gt; angular_distance</code></pre><p><strong>Purpose</strong></p><p>Compute rigorous position angle of point 2 relative to point 1.</p><p><strong>Explanation</strong></p><p>Computes the rigorous position angle of point 2 (with given right ascension and declination) using point 1 (with given right ascension and declination) as the center.</p><p><strong>Arguments</strong></p><ul><li><code>units</code>: integer, can be either 0, or 1, or 2.  Describes units of inputs and</li></ul><p>output:     * 0: everything (input right ascensions and declinations, and output       distance) is radians     * 1: right ascensions are in decimal hours, declinations in decimal degrees,       output distance in degrees     * 2: right ascensions and declinations are in degrees, output distance in       degrees</p><ul><li><code>ra1</code>:  right ascension or longitude of point 1</li><li><code>dec1</code>: declination or latitude of point 1</li><li><code>ra2</code>: right ascension or longitude of point 2</li><li><code>dec2</code>: declination or latitude of point 2</li></ul><p>Both <code>ra1</code> and <code>dec1</code>, and <code>ra2</code> and <code>dec2</code> can be given as 2-tuples <code>(ra1, dec1)</code> and <code>(ra2, dec2)</code>.</p><p><strong>Output</strong></p><p>Angle of the great circle containing <code>[ra2, dec2]</code> from the meridian containing <code>[ra1, dec1]</code>, in the sense north through east rotating about <code>[ra1, dec1]</code>. See <code>units</code> argument above for units.</p><p><strong>Method</strong></p><p>The &quot;four-parts formula&quot; from spherical trigonometry (p. 12 of Smart&#39;s Spherical Astronomy or p. 12 of Green&#39; Spherical Astronomy).</p><p><strong>Example</strong></p><p>Mizar has coordinates (ra, dec) = (13h 23m 55.5s, +54° 55&#39; 31&#39;&#39;).  Its companion, Alcor, has coordinates (ra, dec) = (13h 25m 13.5s, +54° 59&#39; 17&#39;&#39;). Find the position angle of Alcor with respect to Mizar.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; posang(1, ten(13, 25, 13.5), ten(54, 59, 17), ten(13, 23, 55.5), ten(54, 55, 31))
-108.46011246802047</code></pre><p><strong>Notes</strong></p><ul><li>The function <code>sphdist</code> provides an alternate method of computing a spherical</li></ul><p>distance.</p><ul><li>Note that <code>posang</code> is not commutative: the position angle between A and B is <span>$\theta$</span>, then the position angle between B and A is <span>$180 + \theta$</span>.</li></ul><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.precess-NTuple{4,Real}" href="#AstroLib.precess-NTuple{4,Real}"><code>AstroLib.precess</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">precess(ra, dec, equinox1, equinox2[, FK4=true, radians=true]) -&gt; prec_ra, prec_dec</code></pre><p><strong>Purpose</strong></p><p>Precess coordinates from <code>equinox1</code> to <code>equinox2</code>.</p><p><strong>Explanation</strong></p><p>The default <code>(ra, dec)</code> system is FK5 based on epoch J2000.0 but FK4 based on B1950.0 is available via the <code>FK4</code> boolean keyword.</p><p><strong>Arguments</strong></p><ul><li><code>ra</code>: input right ascension, scalar or vector, in degrees, unless the <code>radians</code> keyword is set to <code>true</code></li><li><code>dec</code>: input declination, scalar or vector, in degrees, unless the <code>radians</code> keyword is set to <code>true</code></li><li><code>equinox1</code>: original equinox of coordinates, numeric scalar.</li><li><code>equinox2</code>: equinox of precessed coordinates.</li><li><code>FK4</code> (optional boolean keyword): if this keyword is set to <code>true</code>, the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is <code>false</code>, the default, use FK5 (J2000.0) precession angles.</li><li><code>radians</code> (optional boolean keyword): if this keyword is set to <code>true</code>, then the input and output right ascension and declination vectors are in radians rather than degrees.</li></ul><p><strong>Output</strong></p><p>The 2-tuple <code>(ra, dec)</code> of coordinates modified by precession.</p><p><strong>Example</strong></p><p>The Pole Star has J2000.0 coordinates (2h, 31m, 46.3s, 89d 15&#39; 50.6&quot;); compute its coordinates at J1985.0</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; ra, dec = ten(2,31,46.3)*15, ten(89,15,50.6)
(37.94291666666666, 89.26405555555556)

julia&gt; adstring(precess(ra, dec, 2000, 1985), precision=1)
&quot; 02 16 22.73  +89 11 47.3&quot;</code></pre><p>Precess the B1950 coordinates of Eps Ind (RA = 21h 59m,33.053s, DEC = (-56d, 59&#39;, 33.053&quot;) to equinox B1975.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; ra, dec = ten(21, 59, 33.053) * 15, ten(-56, 59, 33.053)
(329.88772083333333, -56.992514722222225)

julia&gt; adstring(precess(ra, dec, 1950, 1975, FK4=true), precision=1)
&quot; 22 01 15.46  -56 52 18.7&quot;</code></pre><p><strong>Method</strong></p><p>Algorithm from &quot;Computational Spherical Astronomy&quot; by Taff (1983), p. 24. (FK4). FK5 constants from &quot;Explanatory Supplement To The Astronomical Almanac&quot; 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac).</p><p><strong>Notes</strong></p><p>Accuracy of precession decreases for declination values near 90 degrees. <code>precess</code> should not be used more than 2.5 centuries from 2000 on the FK5 system (1950.0 on the FK4 system).  If you need better accuracy, use <code>bprecess</code> or <code>jprecess</code> as needed.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.precess_cd" href="#AstroLib.precess_cd"><code>AstroLib.precess_cd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">precess_cd(cd, epoch1, epoch2, crval_old, crval_new[, FK4=true]) -&gt; cd</code></pre><p><strong>Purpose</strong></p><p>Precess the coordinate description matrix.</p><p><strong>Explanation</strong></p><p>The coordinate matrix is precessed from epoch1 to epoch2.</p><p><strong>Arguments</strong></p><ul><li><code>cd</code>: 2 x 2 coordinate description matrix in degrees</li><li><code>epoch1</code>: original equinox of coordinates, scalar</li><li><code>epoch2</code>: equinox of precessed coordinates, scalar</li><li><code>crval_old</code>: 2 element vector containing right ascension and declination in degrees of the reference pixel in the original equinox</li><li><code>crval_new</code>: 2 element vector giving crval in the new equinox</li><li><code>FK4</code> (optional boolean keyword): if this keyword is set to <code>true</code>, then the precession constants are taken in the FK4 reference frame. When it is <code>false</code>, the default is the FK5 frame</li></ul><p><strong>Output</strong></p><ul><li><code>cd</code>: coordinate description containing precessed values</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; precess_cd([20 60; 45 45], 1950, 2000, [34, 58], [12, 83])
2×2 Array{Float64,2}:
  48.8944  147.075
 110.188   110.365</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library. This function should not be used for values more than 2.5 centuries from the year 1900. This function calls <a href="#AstroLib.sec2rad-Tuple{Real}"><code>sec2rad</code></a>, <a href="#AstroLib.precess-NTuple{4,Real}"><code>precess</code></a> and <a href="#AstroLib.bprecess"><code>bprecess</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.precess_xyz-NTuple{5,Real}" href="#AstroLib.precess_xyz-NTuple{5,Real}"><code>AstroLib.precess_xyz</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">precess_xyz(x, y, z, equinox1, equinox2) -&gt; prec_x, prec_y, prec_z</code></pre><p><strong>Purpose</strong></p><p>Precess equatorial geocentric rectangular coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>, <code>y</code>, <code>z</code>: scalars or vectors giving heliocentric rectangular coordinates.</li><li><code>equinox1</code>: original equinox of coordinates, numeric scalar.</li><li><code>equinox2</code>: equinox of precessed coordinates, numeric scalar.</li></ul><p>Input coordinates can be given also a 3-tuple <code>(x, y, z)</code>.</p><p><strong>Output</strong></p><p>The 3-tuple <code>(x, y, z)</code> of coordinates modified by precession.</p><p><strong>Example</strong></p><p>Precess 2000 equinox coordinates <code>(1, 1, 1)</code> to 2050.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; precess_xyz(1, 1, 1, 2000, 2050)
(0.9838854500981734, 1.0110925876508692, 1.0048189888146941)</code></pre><p><strong>Method</strong></p><p>The equatorial geocentric rectangular coordinates are converted to right ascension and declination, precessed in the normal way, then changed back to <code>x</code>, <code>y</code> and <code>z</code> using unit vectors.</p><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.premat-Tuple{Real,Real}" href="#AstroLib.premat-Tuple{Real,Real}"><code>AstroLib.premat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">premat(equinox1, equinox2[, FK4=true]) -&gt; precession_matrix</code></pre><p><strong>Purpose</strong></p><p>Return the precession matrix needed to go from <code>equinox1</code> to <code>equinox2</code>.</p><p><strong>Explanation</strong></p><p>This matrix is used by <code>precess</code> and <code>baryvel</code> to precess astronomical coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>equinox1</code>: original equinox of coordinates.</li><li><code>equinox2</code>: equinox of precessed coordinates.</li><li><code>FK4</code> (optional boolean keyword): if this keyword is set to <code>true</code>, the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is <code>false</code>, the default, use FK5 (J2000.0) precession angles.</li></ul><p><strong>Output</strong></p><p>A 3×3 matrix, used to precess equatorial rectangular coordinates.</p><p><strong>Example</strong></p><p>Return the precession matrix from 1950.0 to 1975.0 in the FK4 system</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; premat(1950,1975,FK4=true)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 0.999981    -0.00558775  -0.00242909
 0.00558775   0.999984    -6.78691e-6
 0.00242909  -6.78633e-6   0.999997</code></pre><p><strong>Method</strong></p><p>FK4 constants from &quot;Computational Spherical Astronomy&quot; by Taff (1983), p. 24. (FK4). FK5 constants from &quot;Explanatory Supplement To The Astronomical Almanac&quot; 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac).</p><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.rad2sec-Tuple{Real}" href="#AstroLib.rad2sec-Tuple{Real}"><code>AstroLib.rad2sec</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rad2sec(rad) -&gt; seconds</code></pre><p><strong>Purpose</strong></p><p>Convert from radians to seconds.</p><p><strong>Argument</strong></p><ul><li><code>rad</code>: number of radians.</li></ul><p><strong>Output</strong></p><p>The number of seconds corresponding to <code>rad</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; rad2sec(1)
206264.80624709636</code></pre><p><strong>Notes</strong></p><p>Use <code>sec2rad</code> to convert seconds to radians.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.radec-Tuple{Real,Real}" href="#AstroLib.radec-Tuple{Real,Real}"><code>AstroLib.radec</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">radec(ra::Real, dec::Real[, hours=true]) -&gt; ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds</code></pre><p><strong>Purpose</strong></p><p>Convert right ascension and declination from decimal to sexagesimal units.</p><p><strong>Explanation</strong></p><p>The conversion is to sexagesimal hours for right ascension, and sexagesimal degrees for declination.</p><p><strong>Arguments</strong></p><ul><li><code>ra</code>: decimal right ascension, scalar or array.  It is expressed in degrees, unless the optional keyword <code>hours</code> is set to <code>true</code>.</li><li><code>dec</code>: declination in decimal degrees, scalar or array, same number of elements as <code>ra</code>.</li><li><code>hours</code> (optional boolean keyword): if <code>false</code> (the default), <code>ra</code> is assumed to be given in degrees, otherwise <code>ra</code> is assumed to be expressed in hours.</li></ul><p><strong>Output</strong></p><p>A 6-tuple of <code>AbstractFloat</code>:</p><pre><code class="language-none">(ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds)</code></pre><p>If <code>ra</code> and <code>dec</code> are arrays, also each element of the output 6-tuple are arrays of the same dimension.</p><p><strong>Example</strong></p><p>Position of Sirius in the sky is (ra, dec) = (6.7525, -16.7161), with right ascension expressed in hours.  Its sexagesimal representation is given by</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; radec(6.7525, -16.7161, hours=true)
(6.0, 45.0, 9.0, -16.0, 42.0, 57.9600000000064)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.recpol-Tuple{Real,Real}" href="#AstroLib.recpol-Tuple{Real,Real}"><code>AstroLib.recpol</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">recpol(x, y[, degrees=true]) -&gt; radius, angle</code></pre><p><strong>Purpose</strong></p><p>Convert 2D rectangular coordinates to polar coordinates.</p><p><strong>Explanation</strong></p><p>This is the partial inverse function of <code>polrec</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: the abscissa coordinate of the point.  It may be a scalar or an array.</li><li><code>y</code>: the ordinate coordinate of the point.  It may be a scalar or an array of the same lenth as <code>x</code>.</li><li><code>degrees</code> (optional boolean keyword): if <code>true</code>, the output <code>angle</code> is given</li></ul><p>in degrees, otherwise in radians.  It defaults to <code>false</code>.</p><p>Mandatory arguments may also be passed as the 2-tuple <code>(x, y)</code>, so that it is possible to execute <code>polrec(recpol(x, y))</code>.</p><p><strong>Output</strong></p><p>A 2-tuple <code>(radius, angle)</code> with the polar coordinates of the input.  The coordinate <code>angle</code> coordinate lies in the range <span>$[-\pi, \pi]$</span> if <code>degrees=false</code>, or <span>$[-180, 180]$</span> when <code>degrees=true</code>.</p><p>If <code>x</code> and <code>y</code> are arrays, <code>radius</code> and <code>angle</code> are arrays of the same length as <code>radius</code> and <code>angle</code>.</p><p><strong>Example</strong></p><p>Calculate polar coordinates <span>$(r, \varphi)$</span> of point with rectangular coordinates <span>$(x, y) = (2.24, -1.87)$</span>.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; r, phi = recpol(2.24, -1.87)
(2.917961617293826, -0.6956158538564537)</code></pre><p>Angle <span>$\varphi$</span> is given in radians.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.rhotheta-NTuple{8,Real}" href="#AstroLib.rhotheta-NTuple{8,Real}"><code>AstroLib.rhotheta</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rhotheta(period, periastron, eccentricity, semimajor_axis, inclination, omega, omega2, epoch) -&gt; rho, theta</code></pre><p><strong>Purpose</strong></p><p>Calculate the separation and position angle of a binary star.</p><p><strong>Explanation</strong></p><p>This function will return the separation <span>$\rho$</span> and position angle <span>$\theta$</span> of a visual binary star derived from its orbital elements.  The algorithms described in the following book will be used: Meeus J., 1992, Astronomische Algorithmen, Barth.  Compared to the examples given at page 400 and no discrepancy found.</p><p><strong>Arguments</strong></p><ul><li><code>period</code>: period [year]</li><li><code>periastro</code>: time of periastron passage [year]</li><li><code>eccentricity</code>: eccentricity of the orbit</li><li><code>semimajor_axis</code>: semi-major axis [arc second]</li><li><code>inclination</code>: inclination angle [degree]</li><li><code>omega</code>: node [degree]</li><li><code>omega2</code>: longitude of periastron [degree]</li><li><code>epoch</code>: epoch of observation [year]</li></ul><p>All input parameters have to be scalars.</p><p><strong>Output</strong></p><p>The 2-tuple <span>$(\rho, \theta)$</span>, where</p><ul><li><span>$\rho$</span> is separation [arc second], and</li><li><span>$\theta$</span> is position angle (degree).</li></ul><p><strong>Example</strong></p><p>Find the position of Eta Coronae Borealis at the epoch 2016</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; ρ, θ = rhotheta(41.623, 1934.008, 0.2763, 0.907, 59.025, 23.717, 219.907, 2016)
(0.6351167848659552, 214.42513387396497)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.sec2rad-Tuple{Real}" href="#AstroLib.sec2rad-Tuple{Real}"><code>AstroLib.sec2rad</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sec2rad(sec) -&gt; radians</code></pre><p><strong>Purpose</strong></p><p>Convert from seconds to radians.</p><p><strong>Argument</strong></p><ul><li><code>sec</code>: number of seconds.</li></ul><p><strong>Output</strong></p><p>The number of radians corresponding to <code>sec</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; sec2rad(3600 * 30)
0.5235987755982988</code></pre><p><strong>Notes</strong></p><p>Use <code>rad2sec</code> to convert radians to seconds.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.sixty-Tuple{Real}" href="#AstroLib.sixty-Tuple{Real}"><code>AstroLib.sixty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sixty(number) -&gt; [deg, min, sec]</code></pre><p><strong>Purpose</strong></p><p>Converts a decimal number to sexagesimal.</p><p><strong>Explanation</strong></p><p>The reverse of <code>ten</code> function.</p><p><strong>Argument</strong></p><ul><li><code>number</code>: decimal number to be converted to sexagesimal.</li></ul><p><strong>Output</strong></p><p>An array of three <code>AbstractFloat</code>, that are the sexagesimal counterpart (degrees, minutes, seconds) of <code>number</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; sixty(-0.615)
3-element StaticArrays.SArray{Tuple{3},Float64,1,3}:
 -0.0
 36.0
 54.0</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.sphdist-NTuple{4,Real}" href="#AstroLib.sphdist-NTuple{4,Real}"><code>AstroLib.sphdist</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sphdist(long1, lat1, long2, lat2[, degrees=true]) -&gt; angular_distance</code></pre><p><strong>Purpose</strong></p><p>Angular distance between points on a sphere.</p><p><strong>Arguments</strong></p><ul><li><code>long1</code>:  longitude of point 1</li><li><code>lat1</code>: latitude of point 1</li><li><code>long2</code>: longitude of point 2</li><li><code>lat2</code>: latitude of point 2</li><li><code>degrees</code> (optional boolean keyword): if <code>true</code>, all angles, including the output distance, are assumed to be in degrees, otherwise they are all in radians.  It defaults to <code>false</code>.</li></ul><p><strong>Output</strong></p><p>Angular distance on a sphere between points 1 and 2, as an <code>AbstractFloat</code>.  It is expressed in radians unless <code>degrees</code> keyword is set to <code>true</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; sphdist(120, -43, 175, +22)
1.5904422616007134</code></pre><p><strong>Notes</strong></p><ul><li><code>gcirc</code> function is similar to <code>sphdist</code>, but may be more suitable for astronomical applications.</li></ul><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.sunpos-Tuple{Real}" href="#AstroLib.sunpos-Tuple{Real}"><code>AstroLib.sunpos</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sunpos(jd[, radians=true]) -&gt; ra, dec, elong, obliquity</code></pre><p><strong>Purpose</strong></p><p>Compute the right ascension and declination of the Sun at a given date.</p><p><strong>Arguments</strong></p><ul><li><code>jd</code>: the Julian date of when you want to calculate Sun position.  It can be either a scalar or a vector.  Use <code>jdcnv</code> to get the Julian date for a given date and time.</li><li><code>radians</code> (optional boolean keyword): if set to <code>true</code>, all output quantities are given in radians.  The default is <code>false</code>, so all quantities are given in degrees.</li></ul><p><strong>Output</strong></p><p>The 4-tuple <code>(ra, dec, elong, obliquity)</code>:</p><ul><li><code>ra</code>: the right ascension of the Sun at that date</li><li><code>dec</code>: the declination of the Sun at that date</li><li><code>elong</code>: ecliptic longitude of the Sun at that date</li><li><code>obliquity</code>: the obliquity of the ecliptic</li></ul><p>All quantities are given in degrees, unless <code>radians</code> keyword is set to <code>true</code> (see &quot;Arguments&quot; section).  If <code>jd</code> is an array, arrays of the same given as <code>jd</code> are returned.</p><p><strong>Method</strong></p><p>Uses a truncated version of Newcomb&#39;s Sun.  Adapted from the IDL routine SUN_POS by CD Pike, which was adapted from a FORTRAN routine by B. Emerson (RGO).</p><p><strong>Example</strong></p><p>(1) Find the apparent right ascension and declination of the Sun on May 1, 1982</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; adstring(sunpos(jdcnv(1982, 5, 1))[1:2], precision=2)
&quot; 02 31 32.614  +14 54 34.92&quot;</code></pre><p>The Astronomical Almanac gives <code>02 31 32.58 +14 54 34.9</code> so the error for this case is &lt; 0.5&quot;.</p><p>(2) Plot the apparent right ascension, in hours, and declination of the Sun, in degrees, for every day in 2016.  Use <a href="https://github.com/JuliaPlots/Plots.jl/">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
days = DateTime(2016):DateTime(2016, 12, 31);
ra, declin = sunpos(jdcnv.(days));
plot(days, ra/15); plot(days, declin)</code></pre><p><strong>Notes</strong></p><p>Patrick Wallace (Rutherford Appleton Laboratory, UK) has tested the accuracy of a C adaptation of the present algorithm and found the following results.  From 1900-2100 <code>sunpos</code> gave 7.3 arcsec maximum error, 2.6 arcsec RMS.  Over the shorter interval 1950-2050 the figures were 6.4 arcsec max, 2.2 arcsec RMS.</p><p>The returned <code>ra</code> and <code>dec</code> are in the given date&#39;s equinox.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.ten" href="#AstroLib.ten"><code>AstroLib.ten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ten(deg[, min, sec]) -&gt; decimal
ten(&quot;deg:min:sec&quot;) -&gt; decimal</code></pre><p><strong>Purpose</strong></p><p>Converts a sexagesimal number or string to decimal.</p><p><strong>Explanation</strong></p><p><code>ten</code> is the inverse of the <code>sixty</code> function.</p><p><strong>Arguments</strong></p><p><code>ten</code> takes as argument either three scalars (<code>deg</code>, <code>min</code>, <code>sec</code>) or a string. The string should have the form <code>&quot;deg:min:sec&quot;</code> or <code>&quot;deg min sec&quot;</code>.  Also any iterable like <code>(deg, min, sec)</code> or <code>[deg, min, sec]</code> is accepted as argument.</p><p>If minutes and seconds are not specified they default to zero.</p><p><strong>Output</strong></p><p>The decimal conversion of the sexagesimal numbers provided is returned.</p><p><strong>Method</strong></p><p>The formula used for the conversion is</p><div>\[\mathrm{sign}(\mathrm{deg})·\left(|\mathrm{deg}| + \frac{\mathrm{min}}{60} + \frac{\mathrm{sec}}{3600}\right)\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; ten(-0.0, 19, 47)
-0.3297222222222222

julia&gt; ten(&quot;+5:14:58&quot;)
5.249444444444444

julia&gt; ten(&quot;-10 26&quot;)
-10.433333333333334

julia&gt; ten((-10, 26))
-10.433333333333334</code></pre><p><strong>Notes</strong></p><p>These functions cannot deal with <code>-0</code> (negative integer zero) in numeric input. If it is important to give sense to negative zero, you can either make sure to pass a floating point negative zero <code>-0.0</code> (this is the best option), or use negative minutes and seconds, or non-integer negative degrees and minutes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.tic_one" href="#AstroLib.tic_one"><code>AstroLib.tic_one</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tic_one(zmin, pixx, incr[, ra=true]) -&gt; min2, tic1</code></pre><p><strong>Purpose</strong></p><p>Determine the position of the first tic mark for astronomical images.</p><p><strong>Explanation</strong></p><p>For use in labelling images with right ascension and declination axes. This routine determines the position in pixels of the first tic.</p><p><strong>Arguments</strong></p><ul><li><code>zmin</code>: astronomical coordinate value at axis zero point (degrees  or hours).</li><li><code>pixx</code>: distance in pixels between tic marks (usually obtained from <a href="#AstroLib.tics"><code>tics</code></a>).</li><li><code>incr</code> - increment in minutes for labels (usually an even number obtained  from the procedure <a href="#AstroLib.tics"><code>tics</code></a>).</li><li><code>ra</code> (optional boolean keyword): if true, incremental value being entered  is in minutes of time, else it is assumed that value is in else it&#39;s in minutes of arc.  Default is false.</li></ul><p><strong>Output</strong></p><p>The 2 tuple <code>(min2, tic1)</code>:</p><ul><li><code>min2</code>: astronomical coordinate value at first tic mark</li><li><code>tic1</code>: position in pixels of first tic mark</li></ul><p><strong>Example</strong></p><p>Suppose a declination axis has a value of 30.2345 degrees at its zero point.  A tic mark is desired every 10 arc minutes, which corresponds to 12.74 pixels, with increment for labels being 10 minutes. Then</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; tic_one(30.2345, 12.74, 10)
(30.333333333333332, 7.554820000000081)</code></pre><p>yields values of min2 ≈ 30.333 and tic1 ≈ 7.55482, i.e. the first tic mark should be labeled 30 deg 20 minutes and be placed at pixel value 7.55482.</p><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.ticpos-Tuple{Real,Real,Real}" href="#AstroLib.ticpos-Tuple{Real,Real,Real}"><code>AstroLib.ticpos</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ticpos(deglen, pixlen, ticsize) -&gt; ticsize, incr, units</code></pre><p><strong>Purpose</strong></p><p>Specify distance between tic marks for astronomical coordinate overlays.</p><p><strong>Explanation</strong></p><p>User inputs number an approximate distance between tic marks, and the axis length in degrees. <code>ticpos</code> will return a distance between tic marks such that the separation is a round multiple in arc seconds, arc minutes, or degrees.</p><p><strong>Arguments</strong></p><ul><li><code>deglen</code>: length of axis in degrees, positive scalar</li><li><code>pixlen</code>: length of axis in plotting units (pixels), postive scalar</li><li><code>ticsize</code>: distance between tic marks (pixels).  This value will be  adjusted by <code>ticpos</code> such that the distance corresponds to a round  multiple in the astronomical coordinate.</li></ul><p><strong>Output</strong></p><p>The 3-tuple <code>(ticsize, incr, units)</code>:</p><ul><li><code>ticsize</code>: distance between tic marks (pixels), positive scalar</li><li><code>incr</code>: incremental value for tic marks in round units given  by the <code>units</code> parameter</li><li><code>units</code>: string giving units of ticsize, either &#39;Arc Seconds&#39;, &#39;Arc Minutes&#39;, or &#39;Degrees&#39;</li></ul><p><strong>Example</strong></p><p>Suppose a 512 x 512 image array corresponds to 0.2 x 0.2 degrees on the sky. A tic mark is desired in round angular units, approximately every 75 pixels. Then</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; ticpos(0.2, 512, 75)
(85.33333333333333, 2.0, &quot;Arc Minutes&quot;)</code></pre><p>i.e. a good tic mark spacing is every 2 arc minutes, corresponding to 85.333 pixels.</p><p><strong>Notes</strong></p><p>All the arguments taken as input are assumed to be positive in nature.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.tics" href="#AstroLib.tics"><code>AstroLib.tics</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tics(radec_min, radec_max, numx, ticsize[, ra=true]) -&gt; ticsize, incr</code></pre><p><strong>Purpose</strong></p><p>Compute a nice increment between tic marks for astronomical images.</p><p><strong>Explanation</strong></p><p>For use in labelling a displayed image with right ascension or declination axes.  An approximate distance between tic marks is input, and a new value is computed such that the distance between tic marks is in simple increments of the tic label values.</p><p><strong>Arguements</strong></p><ul><li><code>radec_min</code> : minimum axis value (degrees).</li><li><code>radec_min</code> : maximum axis value (degrees).</li><li><code>numx</code> : number of pixels in x direction.</li><li><code>ticsize</code> : distance between tic marks (pixels).</li><li><code>ra</code> (optional boolean keyword): if true, incremental value would be in minutes of time. Default is false.</li></ul><p><strong>Output</strong></p><p>A 2-tuple <code>(ticsize, incr)</code>:</p><ul><li><code>ticsize</code> : distance between tic marks (pixels).</li><li><code>incr</code> : incremental value for tic labels.  The format is dependent on the optional keyword. If true (i.e for right ascension), it&#39;s in minutes of time, else it&#39;s in minutes of arc (for declination).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; tics(55, 60, 100.0, 1/2)
(0.66, 2.0)

julia&gt; tics(30, 60, 12, 2, true)
(2.75, 30.0)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.true_obliquity-Tuple{Real}" href="#AstroLib.true_obliquity-Tuple{Real}"><code>AstroLib.true_obliquity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">true_obliquity(jd) -&gt; t_eps</code></pre><p><strong>Purpose</strong></p><p>Return the true obliquity of the ecliptic for a given Julian date</p><p><strong>Explanation</strong></p><p>The function is used by the <a href="#AstroLib.co_aberration"><code>co_aberration</code></a> procedure.</p><p><strong>Arguments</strong></p><ul><li><code>jd</code>: Julian date.</li></ul><p><strong>Output</strong></p><ul><li><code>t_eps</code>: true obliquity of the ecliptic, in radians</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; true_obliquity(jdcnv(1978,01,7,11, 01))
0.4090953896211926</code></pre><p><strong>Notes</strong></p><p>The function calls <a href="#AstroLib.mean_obliquity-Tuple{Real}"><code>mean_obliquity</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.trueanom-Tuple{Real,Real}" href="#AstroLib.trueanom-Tuple{Real,Real}"><code>AstroLib.trueanom</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">trueanom(E, e) -&gt; true anomaly</code></pre><p><strong>Purpose</strong></p><p>Calculate true anomaly for a particle in elliptic orbit with eccentric anomaly <span>$E$</span> and eccentricity <span>$e$</span>.</p><p><strong>Explanation</strong></p><p>In the two-body problem, once that the <a href="https://en.wikipedia.org/wiki/Kepler%27s_equation">Kepler&#39;s equation</a> is solved and <span>$E(t)$</span> is determined, the polar coordinates <span>$(r(t), \theta(t))$</span> of the body at time <span>$t$</span> in the elliptic orbit are given by</p><p><span>$\theta(t) = 2\arctan \left(\sqrt{\frac{1 + e}{1 - e}} \tan\frac{E(t)}{2} \right)$</span></p><p><span>$r(t) = \frac{a(1 - e^{2})}{1 + e\cos(\theta(t) - \theta_{0})}$</span></p><p>in which <span>$a$</span> is the semi-major axis of the orbit, and <span>$\theta_0$</span> the value of angular coordinate at time <span>$t = t_{0}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>E</code>: eccentric anomaly.</li><li><code>e</code>: eccentricity, in the elliptic motion regime (<span>$0 \leq e \leq 1$</span>)</li></ul><p><strong>Output</strong></p><p>The true anomaly.</p><p><strong>Example</strong></p><p>Plot the true anomaly as a function of mean anomaly for eccentricity <span>$e = 0$</span>, <span>$0.5$</span>, <span>$0.9$</span>.  Use <a href="https://github.com/JuliaPlots/Plots.jl/">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
M = range(0, stop=2pi, length=1001)[1:end-1];
for ecc in (0, 0.5, 0.9)
    plot(M, mod2pi.(trueanom.(kepler_solver.(M, ecc), ecc)))
end</code></pre><p><strong>Notes</strong></p><p>The eccentric anomaly can be calculated with <a href="#AstroLib.kepler_solver-Tuple{Real,Real}"><code>kepler_solver</code></a> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.uvbybeta" href="#AstroLib.uvbybeta"><code>AstroLib.uvbybeta</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">uvbybeta(by, m1, c1, n[, hbeta=NaN, eby_in=NaN]) -&gt; te, mv, eby, delm0, radius</code></pre><p><strong>Purpose</strong></p><p>Derive dereddened colors, metallicity, and Teff from Stromgren colors.</p><p><strong>Arguments</strong></p><ul><li><code>by</code>: Stromgren b-y color</li><li><code>m1</code>: Stromgren line-blanketing parameter</li><li><code>c1</code>: Stromgren Balmer discontinuity parameter</li><li><code>n</code>: Integer which can be any value between 1 to 8, giving approximate stellar classification. (1) B0 - A0, classes III - V, 2.59 &lt; Hbeta &lt; 2.88,-0.20 &lt;   c0   &lt; 1.00 (2) B0 - A0, class   Ia     , 2.52 &lt; Hbeta &lt; 2.59,-0.15 &lt;   c0   &lt; 0.40 (3) B0 - A0, class   Ib     , 2.56 &lt; Hbeta &lt; 2.61,-0.10 &lt;   c0   &lt; 0.50 (4) B0 - A0, class   II     , 2.58 &lt; Hbeta &lt; 2.63,-0.10 &lt;   c0   &lt; 0.10 (5) A0 - A3, classes III - V, 2.87 &lt; Hbeta &lt; 2.93,-0.01 &lt; (b-y)o &lt; 0.06 (6) A3 - F0, classes III - V, 2.72 &lt; Hbeta &lt; 2.88, 0.05 &lt; (b-y)o &lt; 0.22 (7) F1 - G2, classes III - V, 2.60 &lt; Hbeta &lt; 2.72, 0.22 &lt; (b-y)o &lt; 0.39 (8) G2 - M2, classes  IV - V, 0.20 &lt; m0    &lt; 0.76, 0.39 &lt; (b-y)o &lt; 1.00</li><li><code>hbeta</code> (optional): H-beta line strength index. If it is not supplied, then by default its value will be <code>NaN</code> and the code will estimate a value based on by, m1,and c1. It is not used for stars in group 8.</li><li><code>eby_in</code> (optional): specifies the E(b-y) color to use. If not supplied, then by default its value will be <code>NaN</code> and E(b-y) will be estimated from the Stromgren colors.</li></ul><p><strong>Output</strong></p><ul><li><code>te</code>: approximate effective temperature</li><li><code>mv</code>: absolute visible magnitude</li><li><code>eby</code>: color excess E(b-y)</li><li><code>delm0</code>: metallicity index, delta m0, may not be calculable for early B stars and so returns <code>NaN</code>.</li><li><code>radius</code>: stellar radius (R/R(solar))</li></ul><p><strong>Example</strong></p><p>Suppose 5 stars have the following Stromgren parameters</p><p>by = [-0.001 ,0.403, 0.244, 0.216, 0.394] m1 = [0.105, -0.074, -0.053, 0.167, 0.186] c1 = [0.647, 0.215, 0.051, 0.785, 0.362] hbeta = [2.75, 2.552, 2.568, 2.743, 0] nn = [1,2,3,7,8]</p><p>Determine the stellar parameters</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; by = [-0.001 ,0.403, 0.244, 0.216, 0.394];

julia&gt; m1 = [0.105, -0.074, -0.053, 0.167, 0.186];

julia&gt; c1 = [0.647, 0.215, 0.051, 0.785, 0.362];

julia&gt; hbeta = [2.75, 2.552, 2.568, 2.743, 0];

julia&gt; nn = [1,2,3,7,8];

julia&gt; uvbybeta.(by, m1, c1, nn, hbeta)
5-element Array{NTuple{5,Float64},1}:
 (13057.535222326893, -0.27375469585031265, 0.04954396423248884, -0.008292894218734928, 2.7136529525371897)
 (14025.053834219656, -6.907050783073221, 0.4140562248995983, NaN, 73.50771722263974)
 (18423.76405400214, -5.935816553877892, 0.2828247876690783, NaN, 39.84106215808709)
 (7210.507090112837, 2.2180408083364167, 0.018404079180028038, 0.018750927360588615, 2.0459018065648165)
 (5755.671513413262, 3.9449408311022, -0.025062997393370458, 0.03241423718769865, 1.5339239690774464)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.vactoair-Tuple{Real}" href="#AstroLib.vactoair-Tuple{Real}"><code>AstroLib.vactoair</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">vactoair(wave_vacuum) -&gt; wave_air</code></pre><p><strong>Purpose</strong></p><p>Converts vacuum wavelengths to air wavelengths.</p><p><strong>Explanation</strong></p><p>Corrects for the index of refraction of air under standard conditions. Wavelength values below <span>$2000 Å$</span> will not be altered.  Uses relation of Ciddor (1996).</p><p><strong>Arguments</strong></p><ul><li><code>wave_vacuum</code>: vacuum wavelength in angstroms.  Wavelengths are corrected for the index of refraction of air under standard conditions.  Wavelength values below <span>$2000 Å$</span> will <em>not</em> be altered, take care within <span>$[1 Å, 2000 Å]$</span>.</li></ul><p><strong>Output</strong></p><p>Air wavelength in angstroms.</p><p><strong>Method</strong></p><p>Uses relation of Ciddor (1996), Applied Optics 35, 1566 (http://adsabs.harvard.edu/abs/1996ApOpt..35.1566C).</p><p><strong>Example</strong></p><p>If the vacuum wavelength is <code>w = 2000</code>, then <code>vactoair(w)</code> yields an air wavelength of <code>1999.353</code>.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; vactoair(2000)
1999.3526230448367</code></pre><p><strong>Notes</strong></p><p><code>airtovac</code> converts air wavelengths to vacuum wavelengths.</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.xyz" href="#AstroLib.xyz"><code>AstroLib.xyz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">xyz(jd[, equinox]) -&gt; x, y, z, v_x, v_y, v_z</code></pre><p><strong>Purpose</strong></p><p>Calculate geocentric <span>$x$</span>, <span>$y$</span>, and <span>$z$</span> and velocity coordinates of the Sun.</p><p><strong>Explanation</strong></p><p>Calculates geocentric <span>$x$</span>, <span>$y$</span>, and <span>$z$</span> vectors and velocity coordinates (<span>$dx$</span>, <span>$dy$</span> and <span>$dz$</span>) of the Sun.  (The positive <span>$x$</span> axis is directed towards the equinox, the <span>$y$</span>-axis, towards the point on the equator at right ascension 6h, and the <span>$z$</span> axis toward the north pole of the equator).  Typical position accuracy is <span>$&lt;10^{-4}$</span> AU (15000 km).</p><p><strong>Arguments</strong></p><ul><li><code>jd</code>: number of Reduced Julian Days for the wanted date.  It can be either a scalar or a vector.</li><li><code>equinox</code> (optional numeric argument): equinox of output. Default is 1950.</li></ul><p>You can use <code>juldate</code> to get the number of Reduced Julian Days for the selected dates.</p><p><strong>Output</strong></p><p>The 6-tuple <span>$(x, y, z, v_x, v_y, v_z)$</span>, where</p><ul><li><span>$x, y, z$</span>: scalars or vectors giving heliocentric rectangular coordinates (in AU) for each date supplied.  Note that <span>$\sqrt{x^2 + y^2 + z^2}$</span> gives the Earth-Sun distance for the given date.</li><li><span>$v_x, v_y, v_z$</span>: velocity vectors corresponding to <span>$x, y$</span>, and <span>$z$</span>.</li></ul><p><strong>Example</strong></p><p>What were the rectangular coordinates and velocities of the Sun on 1999-01-22T00:00:00 (= JD 2451200.5) in J2000 coords?  Note: Astronomical Almanac (AA) is in TDT, so add 64 seconds to UT to convert.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib, Dates

julia&gt; jd = juldate(DateTime(1999, 1, 22))
51200.5

julia&gt; xyz(jd + 64/86400, 2000)
(0.514568709240398, -0.7696326261820209, -0.33376880143023935, 0.014947267514079971, 0.008314838205477328, 0.003606857607575486)</code></pre><p>Compare to Astronomical Almanac (1999 page C20)</p><pre><code class="language-none">            x  (AU)        y  (AU)     z (AU)
xyz:      0.51456871   -0.76963263  -0.33376880
AA:       0.51453130   -0.7697110   -0.3337152
abs(err): 0.00003739    0.00007839   0.00005360
abs(err)
    (km):   5609          11759         8040</code></pre><p>NOTE: Velocities in AA are for Earth/Moon barycenter       (a very minor offset) see AA 1999 page E3</p><pre><code class="language-none">           x vel (AU/day) y vel (AU/day)   z vel (AU/day)
xyz:      -0.014947268   -0.0083148382    -0.0036068576
AA:       -0.01494574    -0.00831185      -0.00360365
abs(err):  0.000001583    0.0000029886     0.0000032076
abs(err)
 (km/sec): 0.00265        0.00519          0.00557</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.ydn2md-Tuple{Integer,Integer}" href="#AstroLib.ydn2md-Tuple{Integer,Integer}"><code>AstroLib.ydn2md</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ydn2md(year, day) -&gt; date</code></pre><p><strong>Purpose</strong></p><p>Convert from year and day number of year to a date.</p><p><strong>Explanation</strong></p><p>Returns the date corresponding to the <code>day</code> of <code>year</code>.</p><p><strong>Arguments</strong></p><ul><li><code>year</code>: the year, as an integer.</li><li><code>day</code>: the day of <code>year</code>, as an integer.</li></ul><p><strong>Output</strong></p><p>The date, of <code>Date</code> type, of <span>$\text{day} - 1$</span> days after January 1st of <code>year</code>.</p><p><strong>Example</strong></p><p>Find the date of the 60th and 234th days of the year 2016.</p><pre><code class="language-julia-repl">julia&gt; using AstroLib

julia&gt; ydn2md.(2016, [60, 234])
2-element Array{Dates.Date,1}:
 2016-02-29
 2016-08-21</code></pre><p><strong>Note</strong></p><p><code>ymd2dn</code> converts from a date to day of the year.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.ymd2dn" href="#AstroLib.ymd2dn"><code>AstroLib.ymd2dn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ymd2dn(date) -&gt; number_of_days</code></pre><p><strong>Purpose</strong></p><p>Convert from a date to day of the year.</p><p><strong>Explanation</strong></p><p>Returns the day of the year for <code>date</code> with January 1st being day 1.</p><p><strong>Arguments</strong></p><ul><li><code>date</code>: the date with <code>Date</code> type.  Can be a single date or an array of dates.</li></ul><p><strong>Output</strong></p><p>The day of the year for the given <code>date</code>.  If <code>date</code> is an array, returns an array of days.</p><p><strong>Example</strong></p><p>Find the days of the year for March 5 in the years 2015 and 2016 (this is a leap year).</p><pre><code class="language-julia-repl">julia&gt; using AstroLib, Dates

julia&gt; ymd2dn.([Date(2015, 3, 5), Date(2016, 3, 5)])
2-element Array{Int64,1}:
 64
 65</code></pre><p><strong>Note</strong></p><p><code>ydn2md</code> converts from year and day number of year to a date.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.zenpos" href="#AstroLib.zenpos"><code>AstroLib.zenpos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">zenpos(jd, latitude, longitude) -&gt; zenith_right_ascension, declination
zenpos(date, latitude, longitude, tz) -&gt; zenith_right_ascension, declination</code></pre><p><strong>Purpose</strong></p><p>Return the zenith right ascension and declination in radians for a given Julian date or a local civil time and timezone.</p><p><strong>Explanation</strong></p><p>The local sidereal time is computed with the help of <a href="#AstroLib.ct2lst-Tuple{Real,Real}"><code>ct2lst</code></a>, which is the right ascension of the zenith. This and the observatories latitude (corresponding to the declination) are converted to radians and returned as the zenith direction.</p><p><strong>Arguments</strong></p><p>The function can be called in two different ways. The arguments common to both methods are <code>latitude</code> and <code>longitude</code>:</p><ul><li><code>latitude</code> : latitude of the desired location.</li><li><code>longitude</code> : longitude of the desired location.</li></ul><p>The zenith direction can be computed either by providing the Julian date:</p><ul><li><code>jd</code> : the Julian date of the date and time for which the zenith position is desired.</li></ul><p>or the time zone and the date:</p><ul><li><code>tz</code>: the time zone (in hours) of the desired location (e.g. 4 = EDT, 5 = EST)</li><li><code>date</code>: the local civil time with type <code>DateTime</code>.</li></ul><p><strong>Output</strong></p><p>A 2-tuple <code>(ra, dec)</code>:</p><ul><li><code>ra</code> : the right ascension (in radians) of the zenith.</li><li><code>dec</code> : the declination (in radians) of the zenith.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using AstroLib, Dates

julia&gt; zenpos(DateTime(2017, 04, 25, 18, 59), 43.16, -24.32, 4)
(0.946790432684706, 0.7532841051607526)

julia&gt; zenpos(jdcnv(2016, 05, 05, 13, 41), ten(35,0,42), ten(135,46,6))
(3.5757821152779536, 0.6110688599440813)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.POLELATLONG" href="#AstroLib.POLELATLONG"><code>AstroLib.POLELATLONG</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>List of locations of North Magnetic Pole since 1590.</p><p>This is provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.observatories" href="#AstroLib.observatories"><code>AstroLib.observatories</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>List of observing sites.  The observatories have <code>Observatory</code> type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.planets" href="#AstroLib.planets"><code>AstroLib.planets</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>List of planets of the Solar System, from Mercury to Pluto.  The elements of the list have <code>Planet</code> type.</p><p>Reference for most quantities is the Planetary Fact Sheet: http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html and the Keplerian Elements for Approximate Positions of the Major Planets: https://ssd.jpl.nasa.gov/txt/p<em>elem</em>t1.txt</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AstroLib.co_refract_forward-Tuple{Real,Real,Real}" href="#AstroLib.co_refract_forward-Tuple{Real,Real,Real}"><code>AstroLib.co_refract_forward</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">co_refract_forward(alt, pre, temp) -&gt; ref</code></pre><p><strong>Purpose</strong></p><p>A function used by <a href="#AstroLib.co_refract"><code>co_refract</code></a> to find apparent (or observed) altitude</p><p><strong>Arguments</strong></p><ul><li><code>alt</code>: the observed (or apparent) altitude, in degrees</li><li><code>pre</code>: pressure, in millibars</li><li><code>temp</code>: temperature, in Kelvins</li></ul><p><strong>Output</strong></p><ul><li><code>ref</code>: the atmospheric refraction, in minutes of arc</li></ul><p><strong>Notes</strong></p><p>The atmospheric refraction is calculated by Saemundsson&#39;s formula</p><p>Code of this function is based on IDL Astronomy User&#39;s Library.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Introduction</span></a></footer></article></body></html>
