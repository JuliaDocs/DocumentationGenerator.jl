<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · LibSpatialIndex.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LibSpatialIndex.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibSpatialIndex.RTree" href="#LibSpatialIndex.RTree"><code>LibSpatialIndex.RTree</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The RTree index [guttman84] is a balanced tree structure that consists of index nodes, leaf nodes and data.</p><p>Every node (leaf and index) has a fixed capacity of entries, (the node capacity) chosen at index creation An <code>RTree</code> abstracts the data with their Minimum Bounding Region (<code>MBR</code>) and clusters these MBRs according to various heuristics in the leaf nodes. Queries are evaluated from the root of the tree down the leaves. Since the index is balanced nodes can be under full. They cannot be empty though. A <code>fillfactor</code> specifies the minimum number of entries allowed in any node. The fill factor is usually close to <code>70%</code>.</p><p><strong>Options</strong></p><ul><li><code>ndim</code>: Dimensionality of the data that will be inserted.</li><li><code>indextype</code>: one of <code>RT_RTree</code> (default), <code>RT_MVRTree</code>, or <code>RT_TPRTree</code>.</li><li><code>variant</code>: one of <code>RT_Linear</code>, <code>RT_Quadratic</code>, or <code>RT_Star</code> (default).</li><li><code>storage</code>: one of <code>RT_Memory</code> (default), <code>RT_Disk</code>, or <code>RT_Custom</code>.</li><li><code>indexcapacity</code>: The index node capacity. Default is <code>100</code>.</li><li><code>leafcapacity</code>: The leaf node capacity. Default is <code>100</code>.</li><li><code>leafpoolcapacity</code>: Default is <code>100</code>.</li><li><code>indexpoolcapacity</code>: Default is <code>100</code>.</li><li><code>regionpoolcapacity</code>: Default is <code>1000</code>.</li><li><code>pointpoolcapacity</code>: Default is <code>500</code>.</li><li><code>tightMBR</code>: Default is <code>true</code>.</li><li><code>nearminimumoverlapfactor</code>: Default is <code>32</code>.</li><li><code>fillfactor</code>: The fill factor. Default is <code>0.7</code>.</li><li><code>splitdistributionfactor</code>: Default is <code>0.4</code>.</li><li><code>reinsertfactor</code>: Default is <code>0.3</code>.</li></ul><p><strong>Performance</strong></p><p>Dataset size, data density, etc. have nothing to do with capacity and page size. What you are trying to achieve is fast reads from the disk and take advantage of disk buffering and prefetching.</p><p>Normally, you select the page size to be equal to the disk page size (depends on how you format the drive). Then you choose the node capacity to be enough to fill the whole page (including data entries if you have any).</p><p>There is a tradeoff though in making node capacity too large. The larger the capacity, the longer the “for loops” for inserting, deleting, locating node entries take (CPU time). On the other hand, the larger the capacity the shorter the tree becomes, reducing the number of random IOs to reach the leaves. Hence, you might want to fit multiple nodes (of smaller capacity) inside a single page to balance I/O and CPU cost, in case your disk page size is too large.</p><p>Finally, if you have enough buffer space to fit most of the index nodes in main memory, then large capacities do not make too much sense, because the height of the tree does not matter any more. Of course, the smaller the capacity, the larger the number of leaf nodes you will have to retrieve from disk for range queries (point queries and nearest neighbor queries will not suffer that much). So very small capacities hurt as well.</p><p>There is another issue when trying to fit multiple nodes per page: Leftover space. You might have leftover space due to data entries that do not have a fixed size. Unfortunately, in that case, leftover space per page is lost, negatively impacting space usage.</p><p>Selecting the right page size is easy; make it equal to the disk page size. Selecting the right node capacity is an art.</p><p><strong>References</strong></p><p>[guttman84] “R-Trees: A Dynamic Index Structure for Spatial Searching”     Antonin Guttman, Proc. 1984 ACM-SIGMOD Conference on Management of     Data (1985), 47-57.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibSpatialIndex.insert!-Tuple{LibSpatialIndex.RTree,Integer,Array{Float64,1},Array{Float64,1}}" href="#LibSpatialIndex.insert!-Tuple{LibSpatialIndex.RTree,Integer,Array{Float64,1},Array{Float64,1}}"><code>LibSpatialIndex.insert!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Inserts an item into the <code>rtree</code> with given <code>id</code> and boundingbox specified by <code>minvalues</code> and <code>maxvalues</code>, where the item lies within the interval <code>[minvalues[i],maxvalues[i]]</code> for each axis <code>i</code> in 1, ..., <code>ndim</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibSpatialIndex.intersects-Tuple{LibSpatialIndex.RTree,Array{Float64,1},Array{Float64,1}}" href="#LibSpatialIndex.intersects-Tuple{LibSpatialIndex.RTree,Array{Float64,1},Array{Float64,1}}"><code>LibSpatialIndex.intersects</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns a vector of <code>id</code>s corresponding to items in <code>rtree</code> that intersects the box specified by <code>minvalues</code> and <code>maxvalues</code>.</p><p>Each item intersects the interval <code>[minvalues[i],maxvalues[i]]</code> for each axis <code>i</code> in 1, ..., <code>ndim</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibSpatialIndex.intersects-Tuple{LibSpatialIndex.RTree,Array{Float64,1}}" href="#LibSpatialIndex.intersects-Tuple{LibSpatialIndex.RTree,Array{Float64,1}}"><code>LibSpatialIndex.intersects</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns a vector of <code>id</code>s corresponding to items in <code>rtree</code> that intersects the coordinates specified by <code>point</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibSpatialIndex.knn-Tuple{LibSpatialIndex.RTree,Array{Float64,1},Array{Float64,1},Integer}" href="#LibSpatialIndex.knn-Tuple{LibSpatialIndex.RTree,Array{Float64,1},Array{Float64,1},Integer}"><code>LibSpatialIndex.knn</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns a vector of <code>id</code>s corresponding to the <code>k</code> items in <code>rtree</code> that are nearest to the box specified by <code>minvalues</code> and <code>maxvalues</code>.</p><p>Each item intersects the interval <code>[minvalues[i],maxvalues[i]]</code> for each axis <code>i</code> in 1, ..., <code>ndim</code>. If there are fewer than <code>k</code> items in <code>rtree</code>, it will return less than <code>k</code> items. On the other hand, if there are ties between some of the items, it might return more than <code>k</code> items.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibSpatialIndex.knn-Tuple{LibSpatialIndex.RTree,Array{Float64,1},Integer}" href="#LibSpatialIndex.knn-Tuple{LibSpatialIndex.RTree,Array{Float64,1},Integer}"><code>LibSpatialIndex.knn</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns a vector of <code>id</code>s corresponding to the <code>k</code> items in <code>rtree</code> that are nearest to the box specified by <code>minvalues</code> and <code>maxvalues</code>.</p><p>If there are fewer than <code>k</code> items in <code>rtree</code>, it will return less than <code>k</code> items. On the other hand, if there are ties between some of the items, it might return more than <code>k</code> items.</p></div></div></section><footer><hr/></footer></article></body></html>
