var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#NetworkLayout.jl-1",
    "page": "Readme",
    "title": "NetworkLayout.jl",
    "category": "section",
    "text": "Layout algorithms for graphs and trees in pure Julia.(Image: Coverage Status)Linux, OSX : (Image: Build Status)Windows : (Image: Build status)"
},

{
    "location": "#Algorithms-1",
    "page": "Readme",
    "title": "Algorithms",
    "category": "section",
    "text": ""
},

{
    "location": "#Scalable-Force-Directed-Placement-1",
    "page": "Readme",
    "title": "Scalable Force Directed Placement",
    "category": "section",
    "text": "Spring-Electric Force Directed Placement algorithm as explained in Efficient and High Quality Force-Directed Graph Drawing by Yifan Hu.Module Name : SFDP"
},

{
    "location": "#Usage-1",
    "page": "Readme",
    "title": "Usage",
    "category": "section",
    "text": "layout(adjacency_matrix,dimension;startpostitions,tol,C,K,iterations)"
},

{
    "location": "#arguments-1",
    "page": "Readme",
    "title": "arguments",
    "category": "section",
    "text": "adjacency_matrix - sparse/full adjacency matrix that represents the graph\ndimension - dimension in which the layouting code has to be generated. dimension can be an integer specifying               the dimension or a Point type, eg. Point3f0 which denotes 3D.\nstartpositions - co-ordinates of the layout to start with. By default, a random layout is used (kwarg)\ntol - permitted distance between current and calculated co-ordinate. Lower the tolerance, more the number of iterations (kwarg)\nC, K - used to scale the layout (kwarg)\niterations - Number of iterations we apply the forces (kwarg)"
},

{
    "location": "#returns-1",
    "page": "Readme",
    "title": "returns",
    "category": "section",
    "text": "positions - co-ordinates of nodes in the layout"
},

{
    "location": "#iterator-1",
    "page": "Readme",
    "title": "iterator",
    "category": "section",
    "text": "A user can move between iterations using a Layout object."
},

{
    "location": "#Example-1",
    "page": "Readme",
    "title": "Example",
    "category": "section",
    "text": "using LightGraphs\nusing NetworkLayout:SFDP\ng = WheelGraph(10)\na = adjacency_matrix(g) # generates a sparse adjacency matrix\nnetwork = layout(a,Point2f0,tol=0.1,C=1,K=1,iterations=10) # generate 2D layoutUsing Iterator :g = WheelGraph(10)\na = adjacency_matrix(g)\ntol = 0.1\nC = 0.2\nK = 1\niterations = 100\nnetwork = Layout(a,locs,tol,C,K,iterations)\nstate = start(network)\nwhile !done(network,state)\n  network, state = next(network,state)\nend\nreturn network.positions(Image: sfdp)The image shows a LightGraphs.WheelGraph(10) object layout generated by SFDP Algorithm."
},

{
    "location": "#Buchheim-Tree-Drawing-1",
    "page": "Readme",
    "title": "Buchheim Tree Drawing",
    "category": "section",
    "text": "Buchheim Tree Drawing as explained in Improving Walker\'s Algorithm to Run in Linear Time by Christoph Buchheim, Michael Junger and Sebastian Leipert.Module Name : Buchheim"
},

{
    "location": "#Usage-2",
    "page": "Readme",
    "title": "Usage",
    "category": "section",
    "text": "layout(adjacency_list; nodesize)"
},

{
    "location": "#arguments-2",
    "page": "Readme",
    "title": "arguments",
    "category": "section",
    "text": "adjacency_list - adjacency list that represents the tree\nnodesize - sizes of nodes (used to position the nodes) (kwarg)"
},

{
    "location": "#returns-2",
    "page": "Readme",
    "title": "returns",
    "category": "section",
    "text": "positions - co-ordinates of the layout"
},

{
    "location": "#Example-2",
    "page": "Readme",
    "title": "Example",
    "category": "section",
    "text": "using NetworkLayout:Buchheim\nadj_list = Vector{Int}[   # adjacency list\n        [2,3,4],\n        [5,6],\n        [7],\n        [],\n        [],\n        [],\n        []\n      ]\n nodesize = [1,2.3,1.2,2,3,1.4,0.8]\n locs = layout(adj_list,nodesize=nodesize) # generating the layout for the tree\n ```\n ![tree](https://cloud.githubusercontent.com/assets/8404278/17638844/afd280a4-610a-11e6-8fea-5c99808bd740.png)\n\nThe image shows a `LightGraphs.BinaryTree(4)` object layout by Buchheim Algorithm.\n\n### Spring/Repulsion Model\n\nSpring/Repulsion model of Fruchterman and Reingold (1991). Original code taken from [GraphLayout.jl](https://github.com/IainNZ/GraphLayout.jl)\n\nModule Name : `Spring`\n\n#### Usage\njulia layout(adjacency_matrix,dimension;startpositions,C,iterations,initialtemp)##### arguments\n * `adjacency_matrix` - sparse/full adjacency matrix that represents the graph\n * `dimension` - dimension in which the layouting code has to be generated. `dimension` can be an integer specifying\n                  the dimension or a `Point` type, eg. `Point3f0` which denotes 3D.\n * `startpositions` - co-ordinates of the layout to start with. By default, a random layout is used (kwarg)\n * `iterations` - Number of iterations we apply the forces (kwarg)\n * `C` - Constant to fiddle with density of resulting layout (kwarg)\n * `initialtemp` - Initial \"temperature\", controls movement per iteration (kwarg)\n\n##### returns\n `positions` - co-ordinates of nodes in the layout\n\n##### iterator\n\nA user can move between iterations using a `Layout` object.\n\n\n#### Example\njulia using LightGraphs using NetworkLayout:Spring g = WheelGraph(30) a = adjacency_matrix(g) # generates a sparse adjacency matrix network = layout(a,Point2f0,C=2.0,iterations=100,K=2.0) # generate 2D layoutUsing Iterator :\njulia g = WheelGraph(30) a = adjacency_matrix(g) iterations = 200 C = 2.0 initialtemp = 2.0 network = Layout(a,locs,C,iterations,initialtemp) state = start(network) while !done(network,state)  network, state = next(network,state) end return network.positions![spring](https://cloud.githubusercontent.com/assets/8404278/17638354/1c20cc56-6107-11e6-82ed-8873431d8d33.png)\n\nThe image shows a `LightGraphs.WheelGraph(10)` object layout generated by Spring Algorithm.\n\n### Stress Majorization\n\nBased on the algorithm explained in \"Graph Drawing by Stress Majorization\" by Emden R Gansner, Yehuda Koren and Stephen North. Original code taken from [GraphLayout.jl](https://github.com/IainNZ/GraphLayout.jl)\n\nModule Name : `Stress`\n\n#### Usage\njulia layout(δ,dimension;startpositions,weights,iterations,abstols,reltols,abstolx)##### arguments\n * `δ` - Matrix of pairwise distances (Adjacency Matrix can be used)\n * `dimension` - dimension in which the layouting code has to be generated. `dimension` can be an integer specifying\n                  the dimension or a `Point` type, eg. `Point3f0` which denotes 3D.\n * `weights` - Matrix of weights (kwarg)\n * `startpositions` - co-ordinates of the layout to start with. By default, a random layout is used (kwarg)\n * `iterations` - Number of iterations we apply the forces (kwarg)\n * `abstols` - Absolute tolerance for convergence of stress (kwarg)\n * `reltols` - Relative tolerance for convergence of stress (kwarg)\n * `abstolx` - Absolute tolerance for convergence of layout (kwarg)\n\n##### returns\n `positions` - co-ordinates of nodes in the layout\n\n##### iterator\n\nA user can move between iterations using a `Layout` object.\n\n\n#### Example\njulia using LightGraphs using NetworkLayout:Stress g = CompleteGraph(10) a = adjacency_matrix(g) # generates a sparse adjacency matrix network = layout(a,2) # generate 2D layoutUsing Iterator :\njulia g = CompleteGraph(10) δ = adjacency_matrix(g) startpositions=rand(Point{3, Float64}, size(δ,1)) iter = Layout(δ, Point{3,Float64}; startpositions=startpositions) state = start(iter) while !done(iter, state)     iter, state = next(iter, state) end iter.positions\n![stress](https://cloud.githubusercontent.com/assets/8404278/17638554/5e65e26c-6108-11e6-9522-30e6fa044d26.png)\n\nThe image shows a `LightGraphs.CompleteGraph(10)` object layout using Stress Algorithm.\n\n### Spectral Layout Algorithm\n\nUses the technique of Spectral Graph Drawing, which is an under-appreciated method of graph layouts; easier, simpler, and faster than the more common spring-based methods. Original code taken from [PlotRecipes.jl](https://github.com/JuliaPlots/PlotRecipes.jl)\n\nModule Name : `Spectral`\n\n#### Usage\njulia layout(adjacencymatrix; nodeweights, kw...)##### arguments\n * `adjacency_matrix` - Adjacency Matrix in dense/sparse format\n * `node_weights` - weights for different nodes (kwarg)\n\n##### returns\n `positions` - co-ordinates of nodes in the layout\n\n#### Example\njulia using LightGraphs using NetworkLayout:Spectral g = CompleteGraph(10) a = adjacency_matrix(g) # generates a sparse adjacency matrix network = layout(a) # generate 3D layout![spectral](https://cloud.githubusercontent.com/assets/8404278/17638718/a0b451ca-6109-11e6-9a66-fd22332b8541.png)\n\nThe image shows a `LightGraphs.CompleteGraph(10)` object layout by Spectral Algorithm.\n\n### Circular Layout Algorithm\n\nPosition nodes on a circle. Original code taken from [GraphPlot.jl](https://github.com/afternone/GraphPlot.jl)\n\nModule Name : `Circular`\n\n#### Usage\njulia layout(adjacency_matrix)##### arguments\n * `adjacency_matrix` - Adjacency Matrix in dense/sparse format\n\n##### returns\n `positions` - co-ordinates of nodes in the layout\n\n#### Example\njulia using LightGraphs using NetworkLayout:Circular g = CompleteGraph(30) a = adjacency_matrix(g) # generates a sparse adjacency matrix network = layout(a) # generate 2D layout\n![circular](https://cloud.githubusercontent.com/assets/8404278/17638609/d8eb4428-6108-11e6-934b-f326f07cf044.png)\n\nThe image shows a `LightGraphs.CompleteGraph(10)` object layout using Circular Algorithm.\n\n### Shell Layout Algorithm\n\nPosition nodes in concentric circles. Original code taken from [GraphPlot.jl](https://github.com/afternone/GraphPlot.jl)\n\nModule Name : `Shell`\n\n#### Usage\njulia layout(adjacency_matrix;nlist)##### arguments\n * `adjacency_matrix` - Adjacency Matrix in dense/sparse format\n * `nlist` - Shell-wise separation of nodes (kwarg)\n\n##### returns\n `positions` - co-ordinates of nodes in the layout\n\n#### Example\njulia using LightGraphs using NetworkLayout:Shell g = CompleteGraph(30) n = Array(Vector{Int},2) n[1] = [1:15] n[2] = [16:30] a = adjacency_matrix(g) # generates a sparse adjacency matrix network = layout(a,nlist=n) # generate 2D layout ``` (Image: shell)This figure shows a LightGraphs.CompleteGraph(30) object in 2 shells."
},

{
    "location": "#Benchmarks-1",
    "page": "Readme",
    "title": "Benchmarks",
    "category": "section",
    "text": "The iterative algorithms have been benchmarked using 3 different graphs: LightGraphs.WheelGraph(10), LightGraphs.WheelGraph(100) and jagmesh1. The number of iterations is fixed on 100. The following graph is obtained which shows SFDP to be the fastest in a general scenario, but Stress Algorithm is faster when the number of edges per graph is comparatively less, as in jagmesh1.(Image: bench)NOTE : All screenshots are generated using NetworkViz.jl, ThreeJS.jl and Escher.jl. The plot used is generated using Gadfly.jl"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [NetworkLayout]\nOrder = [:type, :function]"
},

]}
