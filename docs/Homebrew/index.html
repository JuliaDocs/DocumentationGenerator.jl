<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · Homebrew.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Homebrew.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Usage-(Users)-1">Usage (Users)</a></li><li class="toplevel"><a class="toctext" href="#Usage-(Package-Authors)-1">Usage (Package Authors)</a></li><li><a class="toctext" href="#Why-Package-Authors-should-use-Homebrew.jl-1">Why Package Authors should use Homebrew.jl</a></li><li><a class="toctext" href="#Why-doesn&#39;t-this-package-use-my-system-wide-Homebrew-installation?-1">Why doesn&#39;t this package use my system-wide Homebrew installation?</a></li><li><a class="toctext" href="#Advanced-usage-1">Advanced usage</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Homebrew.jl-(OSX-only)-1" href="#Homebrew.jl-(OSX-only)-1">Homebrew.jl (OSX only)</a></h1><p><a href="https://travis-ci.org/JuliaPackaging/Homebrew.jl"><img src="https://travis-ci.org/JuliaPackaging/Homebrew.jl.svg" alt="Build Status"/></a></p><p>Homebrew.jl sets up a <a href="http://brew.sh">homebrew</a> installation inside your <a href="http://julialang.org/">Julia</a> package directory.  It uses Homebrew to provide specialized binary packages to satisfy dependencies for other Julia packages, without the need for a compiler or other development tools; it is completely self-sufficient.</p><p>Package authors with dependencies that want binaries distributed in this manner should open an issue here for inclusion into the package database.</p><p>NOTE: If you have MacPorts installed, and are seeing issues with <code>git</code> or <code>curl</code> complaining about certificates, try to update the the <code>curl</code> and <code>curl-ca-bundle</code> packages before using Homebrew.jl. From the terminal, run:</p><pre><code class="language-none">port selfupdate
port upgrade curl curl-ca-bundle</code></pre><h1><a class="nav-anchor" id="Usage-(Users)-1" href="#Usage-(Users)-1">Usage (Users)</a></h1><p>As a user, you ideally shouldn&#39;t ever have to use Homebrew directly, short of installing it via <code>Pkg.add(&quot;Homebrew&quot;)</code>. However, there is a simple to use interface for interacting with the Homebrew package manager:</p><ul><li><code>Homebrew.add(&quot;pkg&quot;)</code> will install <code>pkg</code>, note that if you want to install a package from a non-default tap, you can do so via <code>Homebrew.add(&quot;user/tap/formula&quot;)</code>.  An example of this is installing the <code>metis4</code> formula from the <a href="https://github.com/Homebrew/homebrew-science"><code>Homebrew/science</code> tap</a> via <code>Homebrew.add(&quot;homebrew/science/metis4&quot;)</code>.</li><li><code>Homebrew.rm(&quot;pkg&quot;)</code> will uninstall <code>pkg</code></li><li><code>Homebrew.update()</code> will update the available formulae for installation and upgrade installed packages if a newer version is available</li><li><code>Homebrew.list()</code> will list all installed packages and versions</li><li><code>Homebrew.installed(&quot;pkg&quot;)</code> will return a <code>Bool</code> denoting whether or not <code>pkg</code> is installed</li><li><code>Homebrew.prefix()</code> will return the prefix that all packages are installed to</li></ul><h1><a class="nav-anchor" id="Usage-(Package-Authors)-1" href="#Usage-(Package-Authors)-1">Usage (Package Authors)</a></h1><p>As a package author, the first thing to do is to <a href="https://github.com/Homebrew/brew/blob/master/share/doc/homebrew/Formula-Cookbook.md">write</a>/<a href="http://braumeister.org/">find</a> a Homebrew formula for whatever package you wish to create.  The easiest way to tell if the binary will work out-of-the-box is <code>Homebrew.add()</code> it.  Formulae from the default <code>homebrew/core</code> tap need no prefix, but if you are installing something from another tap, you need to prefix it with the appropriate tap name. For example, to install <code>metis4</code> from the <code>homebrew/science</code> tap, you would run <code>Homebrew.add(&quot;homebrew/science/metis4&quot;)</code>. Programs installed to <code>&lt;prefix&gt;/bin</code> and libraries installed to <code>&lt;prefix&gt;/lib</code> will automatically be availble for <code>run()</code>&#39;ing and <code>dlopen()</code>&#39;ing.</p><p>If that doesn&#39;t &quot;just work&quot;, there may be some special considerations necessary for your piece of software. Open an issue here with a link to your formula and we will discuss what the best approach for your software is. To see examples of formulae we have already included for special usage, peruse the <a href="https://github.com/staticfloat/homebrew-juliadeps">homebrew-juliadeps</a> repository.</p><p>To have your Julia package automatically install these precompiled binaries, <code>Homebrew.jl</code> offers a BinDeps provider which can be accessed as <code>Homebrew.HB</code>.  Simply declare your dependency on <code>Homebrew.jl</code> via a <code>@osx Homebrew</code> in your REQUIRE files, create a BinDeps <code>library_dependency</code> and state that <code>Homebrew</code> provides that dependency:</p><pre><code class="language-julia">using BinDeps
@BinDeps.setup
nettle = library_dependency(&quot;nettle&quot;, aliases = [&quot;libnettle&quot;,&quot;libnettle-4-6&quot;])

...
# Wrap in @osx_only to avoid non-OSX users from erroring out
@osx_only begin
    using Homebrew
    provides( Homebrew.HB, &quot;nettle&quot;, nettle, os = :Darwin )
end

@BinDeps.install Dict(:nettle =&gt; :nettle)</code></pre><p>Then, the <code>Homebrew</code> package will automatically download the requisite bottles for any dependencies you state it can provide.  This example garnered from the <code>build.jl</code> file from <a href="https://github.com/staticfloat/Nettle.jl/blob/master/deps/build.jl"><code>Nettle.jl</code> package</a>.</p><h2><a class="nav-anchor" id="Why-Package-Authors-should-use-Homebrew.jl-1" href="#Why-Package-Authors-should-use-Homebrew.jl-1">Why Package Authors should use Homebrew.jl</a></h2><p>A common question is why bother with Homebrew formulae and such when a package author could simply compile the <code>.dylib</code>&#39;s needed by their package, upload them somewhere and download them to a user&#39;s installation somewhere.  There are multiple reasons, and although they are individually surmountable Homebrew offers a simpler (and standardized) method of solving many of these problems automatically:</p><ul><li><p>On OSX shared libraries link via full paths.  This means that unless you manually alter the path inside of a <code>.dylib</code> or binary to have an <code>@rpath</code> or <code>@executable_path</code> in it, the path will be attempting to point to the exact location on your harddrive that the shared library was found at compile-time.  This is not an issue if all libraries linked to are standard system libraries, however as soon as you wish to link to a library in a non-standard location you must alter the paths.  Homebrew does this for you automatically, rewriting the paths during installation via <code>install_name_tool</code>.  To see the paths embedded in your libraries and executable files, run <code>otool -L &lt;file&gt;</code>.</p></li><li><p>Dependencies on other libraries are handled gracefully by Homebrew.  If your package requires some heavy-weight library such as <code>cairo</code>, <code>glib</code>, etc... Homebrew already has those libraries ready to be installed for you.</p></li><li><p>Releasing new versions of binaries can be difficult.  Homebrew.jl has builtin mechanisms for upgrading all old packages, and even detecting when a binary of the same version number has a new revision (e.g. if an old binary had an error embedded inside it).</p></li></ul><h2><a class="nav-anchor" id="Why-doesn&#39;t-this-package-use-my-system-wide-Homebrew-installation?-1" href="#Why-doesn&#39;t-this-package-use-my-system-wide-Homebrew-installation?-1">Why doesn&#39;t this package use my system-wide Homebrew installation?</a></h2><p>Some of the formulae in the <a href="https://github.com/staticfloat/homebrew-juliadeps">staticfloat/juliadeps tap</a> are specifically patched to work with Julia. Some of these patches have not (or will not) be merged back into Homebrew mainline, so we don&#39;t want to conflict with any packages the user may or may not have installed.</p><p>Users can modify Homebrew&#39;s internal workings, so it&#39;s better to have a known good Homebrew installation than to risk bug reports from users that have unknowingly merged patches into Homebrew that break functionality we require.</p><p>If you already have something installed, and it is usable, (e.g. <code>BinDeps</code> can load it and it passes any quick internal tests the Package authors have defined) then <code>Homebrew.jl</code> won&#39;t try to install it. <code>BinDeps</code> always checks to see if there is a library in the current load path that satisfies the requirements setup by package authors, and if there is, it doesn&#39;t build anything.</p><h2><a class="nav-anchor" id="Advanced-usage-1" href="#Advanced-usage-1">Advanced usage</a></h2><p><code>Homebrew.jl</code> provides a convenient wrapper around most of the functionality of Homebrew, however there are rare cases where access to the full suite of <code>brew</code> commands is necessary.  To facilitate this, users that are familiar with the <code>brew</code> command set can use <code>Homebrew.brew()</code> to directly feed commands to the <code>brew</code> binary within <code>Homebrew.jl</code>.  Example usage:</p><pre><code class="language-none">julia&gt; using Homebrew

julia&gt; Homebrew.brew(`info staticfloat/juliadeps/libgfortran`)
staticfloat/juliadeps/libgfortran: stable 6.2 (bottled)
http://gcc.gnu.org/wiki/GFortran
/Users/sabae/.julia/v0.5/Homebrew/deps/usr/Cellar/libgfortran/6.2 (9 files, 2M) *
  Poured from bottle on 2016-11-21 at 13:14:33
From: https://github.com/staticfloat/homebrew-juliadeps/blob/master/libgfortran.rb
==&gt; Dependencies
Build: gcc ✘</code></pre><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
