<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DynamicalSystemsBase.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DynamicalSystemsBase.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.ContinuousDynamicalSystem" href="#DynamicalSystemsBase.ContinuousDynamicalSystem"><code>DynamicalSystemsBase.ContinuousDynamicalSystem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ContinuousDynamicalSystem(eom, state, p [, jacobian [, J]]; t0 = 0.0)</code></pre><p>A <code>DynamicalSystem</code> restricted to continuous-time systems (also called <em>ODEs</em>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.DiscreteDynamicalSystem" href="#DynamicalSystemsBase.DiscreteDynamicalSystem"><code>DynamicalSystemsBase.DiscreteDynamicalSystem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DiscreteDynamicalSystem(eom, state, p [, jacobian [, J]]; t0::Int = 0)</code></pre><p>A <code>DynamicalSystem</code> restricted to discrete-time systems (also called <em>maps</em>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.DynamicalSystem" href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystemsBase.DynamicalSystem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DynamicalSystem</code></pre><p>The central structure of <strong>DynamicalSystems.jl</strong>. All functions of the suite that can use known equations of motion expect an instance of this type.</p><p><strong>Constructing a <code>DynamicalSystem</code></strong></p><pre><code class="language-julia">DiscreteDynamicalSystem(eom, state, p [, jacobian [, J0]]; t0::Int = 0)
ContinuousDynamicalSystem(eom, state, p [, jacobian [, J0]]; t0 = 0.0)</code></pre><p>with <code>eom</code> the equations of motion function (see below). <code>p</code> is a parameter container, which we highly suggest to use a mutable object like <code>Array</code>, <a href="https://github.com/JuliaDiffEq/LabelledArrays.jl"><code>LMArray</code></a> or a dictionary. Pass <code>nothing</code> in the place of <code>p</code> if your system does not have parameters.</p><p><code>t0</code>, <code>J0</code> allow you to choose the initial time and provide an initialized Jacobian matrix. See <code>CDS_KWARGS</code> for the default options used to evolve continuous systems (through <code>OrdinaryDiffEq</code>).</p><p><strong>Equations of motion</strong></p><p>The are two &quot;versions&quot; for <code>DynamicalSystem</code>, depending on whether the equations of motion (<code>eom</code>) are in-place (iip) or out-of-place (oop). Here is how to define them:</p><ul><li><strong>oop</strong> : The <code>eom</code> <strong>must</strong> be in the form <code>eom(x, p, t) -&gt; SVector</code> which means that given a state <code>x::SVector</code> and some parameter container <code>p</code> it returns an <a href="http://juliaarrays.github.io/StaticArrays.jl/stable/pages/api.html#SVector-1"><code>SVector</code></a> (from the <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays</a> module) containing the next state.</li><li><strong>iip</strong> : The <code>eom</code> <strong>must</strong> be in the form <code>eom!(xnew, x, p, t)</code> which means that given a state <code>x::Vector</code> and some parameter container <code>p</code>, it writes in-place the new state in <code>xnew</code>.</li></ul><p><code>t</code> stands for time (integer for discrete systems). iip is suggested for big systems, whereas oop is suggested for small systems. The break-even point at around 100 dimensions, and for using functions that use the tangent space (like e.g. <code>lyapunovs</code> or <code>gali</code>), the break-even point is at around 10 dimensions.</p><p>The constructor deduces automatically whether <code>eom</code> is iip or oop. It is not possible however to deduce whether the system is continuous or discrete just from the equations of motion, hence the 2 constructors.</p><p><strong>Jacobian</strong></p><p>The optional argument <code>jacobian</code> for the constructors is a <em>function</em> and (if given) must also be of the same form as the <code>eom</code>, <code>jacobian(x, p, n) -&gt; SMatrix</code> for the out-of-place version and <code>jacobian!(xnew, x, p, n)</code> for the in-place version.</p><p>If <code>jacobian</code> is not given, it is constructed automatically using the module <a href="http://www.juliadiff.org/ForwardDiff.jl/stable/"><code>ForwardDiff</code></a>. It is <strong>heavily</strong> advised to provide a Jacobian function, as it gives <em>multiple</em> orders of magnitude speedup.</p><p><strong>Interface to DifferentialEquations.jl</strong></p><p>Continuous systems are solved using <a href="http://docs.juliadiffeq.org/latest/"><strong>DifferentialEquations.jl</strong></a>. The following two interfaces are provided:</p><pre><code class="language-none">ContinuousDynamicalSystem(prob::ODEProblem [, jacobian [, J0]])
ODEProblem(continuous_dynamical_system, tspan, args...)</code></pre><p>where in the second case <code>args</code> stands for the <a href="http://docs.juliadiffeq.org/latest/types/ode_types.html#Constructors-1">standard extra arguments</a> of <code>ODEProblem</code>: <code>callback, mass_matrix</code>.</p><p>If you want to use callbacks with <a href="#DynamicalSystemsBase.tangent_integrator"><code>tangent_integrator</code></a> or <a href="#DynamicalSystemsBase.parallel_integrator"><code>parallel_integrator</code></a>, then invoke them with extra arguments as shown in the <a href="https://juliadynamics.github.io/DynamicalSystems.jl/latest/advanced/">Advanced Documentation</a>.</p><p><strong>Relevant Functions</strong></p><p><a href="#DynamicalSystemsBase.trajectory"><code>trajectory</code></a>, <a href="#DynamicalSystemsBase.set_parameter!-Tuple{Any,Any,Any}"><code>set_parameter!</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.dimension-Union{Tuple{DynamicalSystem{IIP,S,D,F,P,JAC,JM,IAD} where IAD where JM where JAC where P where F}, Tuple{D}, Tuple{S}, Tuple{IIP}} where D where S where IIP" href="#DynamicalSystemsBase.dimension-Union{Tuple{DynamicalSystem{IIP,S,D,F,P,JAC,JM,IAD} where IAD where JM where JAC where P where F}, Tuple{D}, Tuple{S}, Tuple{IIP}} where D where S where IIP"><code>DynamicalSystemsBase.dimension</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dimension(thing) -&gt; D</code></pre><p>Return the dimension of the <code>thing</code>, in the sense of state-space dimensionality.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.get_deviations" href="#DynamicalSystemsBase.get_deviations"><code>DynamicalSystemsBase.get_deviations</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_deviations(tang_integ)</code></pre><p>Return the deviation vectors of the <a href="#DynamicalSystemsBase.tangent_integrator"><code>tangent_integrator</code></a> in a form of a matrix with columns the vectors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.get_state-Tuple{Any}" href="#DynamicalSystemsBase.get_state-Tuple{Any}"><code>DynamicalSystemsBase.get_state</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_state(ds::DynamicalSystem)</code></pre><p>Return the state of <code>ds</code>.</p><pre><code class="language-none">get_state(integ [, i::Int = 1])</code></pre><p>Return the state of the integrator, in the sense of the state of the dynamical system.</p><p>If the integrator is a <a href="#DynamicalSystemsBase.parallel_integrator"><code>parallel_integrator</code></a>, passing <code>i</code> will return the <code>i</code>-th state. The function also correctly returns the true state of the system for tangent integrators.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.integrator" href="#DynamicalSystemsBase.integrator"><code>DynamicalSystemsBase.integrator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">integrator(ds::DynamicalSystem [, u0]; diffeq...) -&gt; integ</code></pre><p>Return an integrator object that can be used to evolve a system interactively using <code>step!(integ [, Δt])</code>. Optionally specify an initial state <code>u0</code>.</p><p>The state of this integrator is a vector.</p><ul><li><code>diffeq...</code> are keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. See <a href="#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> for examples. Only valid for continuous systems.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.jacobian" href="#DynamicalSystemsBase.jacobian"><code>DynamicalSystemsBase.jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">jacobian(ds::DynamicalSystem, u = ds.u0, t = ds.t0)</code></pre><p>Return the jacobian of the system at <code>u</code>, at <code>t</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.parallel_integrator" href="#DynamicalSystemsBase.parallel_integrator"><code>DynamicalSystemsBase.parallel_integrator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parallel_integrator(ds::DynamicalSystem, states; kwargs...)</code></pre><p>Return an integrator object that can be used to evolve many <code>states</code> of a system in parallel at the <em>exact same times</em>, using <code>step!(integ [, Δt])</code>.</p><p><code>states</code> are expected as vectors of vectors.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>diffeq...</code> : Keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. See <a href="#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> for examples. Only valid for continuous systems. These keywords can also include <code>callback</code> for <a href="http://docs.juliadiffeq.org/latest/features/callback_functions.html">event handling</a>.</li></ul><p>It is <em>heavily</em> advised to use the functions <a href="#DynamicalSystemsBase.get_state-Tuple{Any}"><code>get_state</code></a> and <a href="#DynamicalSystemsBase.set_state!-Tuple{Any,Any}"><code>set_state!</code></a> to manipulate the integrator. Provide <code>i</code> as a second argument to change the <code>i</code>-th state.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.set_deviations!" href="#DynamicalSystemsBase.set_deviations!"><code>DynamicalSystemsBase.set_deviations!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_deviations!(tang_integ, Q)</code></pre><p>Set the deviation vectors of the <a href="#DynamicalSystemsBase.tangent_integrator"><code>tangent_integrator</code></a> to <code>Q</code>, which must be a matrix with each column being a deviation vector.</p><p>Automatically does <code>u_modified!(tang_integ, true)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.set_parameter!-Tuple{Any,Any,Any}" href="#DynamicalSystemsBase.set_parameter!-Tuple{Any,Any,Any}"><code>DynamicalSystemsBase.set_parameter!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_parameter!(ds::DynamicalSystem, index, value)
set_parameter!(ds::DynamicalSystem, values)</code></pre><p>Change one or many parameters of the system by setting <code>p[index] = value</code> in the first case and <code>p .= values</code> in the second.</p><p>The same function also works for any integrator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.set_state!-Tuple{Any,Any}" href="#DynamicalSystemsBase.set_state!-Tuple{Any,Any}"><code>DynamicalSystemsBase.set_state!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_state!(integ, u [, i::Int = 1])</code></pre><p>Set the state of the integrator to <code>u</code>, in the sense of the state of the dynamical system. Works for any integrator (normal, tangent, parallel).</p><p>For parallel integrator, you can choose which state to set (using <code>i</code>).</p><p>Automatically does <code>u_modified!(integ, true)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.tangent_integrator" href="#DynamicalSystemsBase.tangent_integrator"><code>DynamicalSystemsBase.tangent_integrator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tangent_integrator(ds::DynamicalSystem, Q0 | k::Int; kwargs...)</code></pre><p>Return an integrator object that evolves in parallel both the system as well as deviation vectors living on the tangent space.</p><p><code>Q0</code> is a <em>matrix</em> whose columns are initial values for deviation vectors. If instead of a matrix <code>Q0</code> an integer <code>k</code> is given, then <code>k</code> random orthonormal vectors are choosen as initial conditions.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>u0</code> : Optional different initial state.</li><li><code>diffeq...</code> : Keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. See <a href="#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> for examples. Only valid for continuous systems. These keywords can also include <code>callback</code> for <a href="http://docs.juliadiffeq.org/latest/features/callback_functions.html">event handling</a>.</li></ul><p>It is <em>heavily</em> advised to use the functions <a href="#DynamicalSystemsBase.get_state-Tuple{Any}"><code>get_state</code></a>, <a href="#DynamicalSystemsBase.get_deviations"><code>get_deviations</code></a>, <a href="#DynamicalSystemsBase.set_state!-Tuple{Any,Any}"><code>set_state!</code></a>, <a href="#DynamicalSystemsBase.set_deviations!"><code>set_deviations!</code></a> to manipulate the integrator.</p><p><strong>Description</strong></p><p>If <span>$J$</span> is the jacobian of the system then the <em>tangent dynamics</em> are the equations that evolve in parallel the system as well as a deviation vector (or matrix) <span>$w$</span>:</p><div>\[\begin{aligned}
\dot{u} &amp;= f(u, p, t) \\
\dot{w} &amp;= J(u, p, t) \times w
\end{aligned}\]</div><p>with <span>$f$</span> being the equations of motion and <span>$u$</span> the system state. Similar equations hold for the discrete case.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalSystemsBase.trajectory" href="#DynamicalSystemsBase.trajectory"><code>DynamicalSystemsBase.trajectory</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trajectory(ds::DynamicalSystem, T [, u]; kwargs...) -&gt; dataset</code></pre><p>Return a dataset that will contain the trajectory of the system, after evolving it for total time <code>T</code>, optionally starting from state <code>u</code>. See <a href="@ref"><code>Dataset</code></a> for info on how to use this object.</p><p>A <code>W×D</code> dataset is returned, with <code>W = length(t0:dt:T)</code> with <code>t0:dt:T</code> representing the time vector (<em>not</em> returned) and <code>D</code> the system dimension. For discrete systems both <code>T</code> and <code>dt</code> must be integers.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>dt</code> :  Time step of value output during the solving of the continuous system. For discrete systems it must be an integer. Defaults to <code>0.01</code> for continuous and <code>1</code> for discrete.</li><li><code>Ttr</code> : Transient time to evolve the initial state before starting saving states.</li><li><code>diffeq...</code> : Keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. For example <code>abstol = 1e-9</code>.  Only valid for continuous systems. If you want to specify a solver, do so by using the name <code>alg</code>, e.g.: <code>alg = Tsit5(), maxiters = 1000</code>. This requires you to have been first <code>using OrdinaryDiffEq</code> to access the solvers. See <code>DynamicalSystemsBase.CDS_KWARGS</code> for default values. These keywords can also include <code>callback</code> for <a href="http://docs.juliadiffeq.org/latest/features/callback_functions.html">event handling</a>. Using a <code>SavingCallback</code> with <code>trajectory</code> will lead to unexpected behavior!</li></ul></div></div></section><footer><hr/></footer></article></body></html>
