<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ImageTransformations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ImageTransformations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageTransformations.InvWarpedView" href="#ImageTransformations.InvWarpedView"><code>ImageTransformations.InvWarpedView</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">InvWarpedView(img, tinv, [indices]) -&gt; wv</code></pre><p>Create a view of <code>img</code> that lazily transforms any given index <code>I</code> passed to <code>wv[I]</code> to correspond to <code>img[inv(tinv)(I)]</code>. While technically this approach is known as backward mode warping, note that <code>InvWarpedView</code> is created by supplying the forward transformation</p><p>The conceptual difference to <a href="#ImageTransformations.WarpedView"><code>WarpedView</code></a> is that <code>InvWarpedView</code> is intended to be used when reasoning about the image is more convenient that reasoning about the indices. Furthermore, <code>InvWarpedView</code> allows simple nesting of transformations, in which case the transformations will be composed into a single one.</p><p>The optional parameter <code>indices</code> can be used to specify the domain of the resulting <code>wv</code>. By default the indices are computed in such a way that <code>wv</code> contains all the original pixels in <code>img</code>.</p><p>see <a href="#ImageTransformations.invwarpedview-Tuple{AbstractArray,CoordinateTransformations.Transformation,Vararg{Any,N} where N}"><code>invwarpedview</code></a> for more information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageTransformations.WarpedView" href="#ImageTransformations.WarpedView"><code>ImageTransformations.WarpedView</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">WarpedView(img, tform, [indices]) -&gt; wv</code></pre><p>Create a view of <code>img</code> that lazily transforms any given index <code>I</code> passed to <code>wv[I]</code> to correspond to <code>img[tform(I)]</code>. This approach is known as backward mode warping.</p><p>The optional parameter <code>indices</code> can be used to specify the domain of the resulting <code>wv</code>. By default the indices are computed in such a way that <code>wv</code> contains all the original pixels in <code>img</code>. To do this <code>inv(tform)</code> has to be computed. If the given transformation <code>tform</code> does not support <code>inv</code>, then the parameter <code>indices</code> has to be specified manually.</p><p>see <a href="#ImageTransformations.warpedview-Tuple{AbstractArray,CoordinateTransformations.Transformation,Vararg{Any,N} where N}"><code>warpedview</code></a> for more information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageTransformations.imresize-Union{Tuple{T}, Tuple{AbstractArray{T,0},Tuple{}}} where T" href="#ImageTransformations.imresize-Union{Tuple{T}, Tuple{AbstractArray{T,0},Tuple{}}} where T"><code>ImageTransformations.imresize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">imresize(img, sz) -&gt; imgr
imresize(img, inds) -&gt; imgr
imresize(img; ratio) -&gt; imgr</code></pre><p>Change <code>img</code> to be of size <code>sz</code> (or to have indices <code>inds</code>). If <code>ratio</code> is used, then <code>sz = ceil(Int, size(img).*ratio)</code>. This interpolates the values at sub-pixel locations. If you are shrinking the image, you risk aliasing unless you low-pass filter <code>img</code> first.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; img = testimage(&quot;lena_gray_256&quot;) # 256*256
julia&gt; imresize(img, 128, 128) # 128*128
julia&gt; imresize(img, 1:128, 1:128) # 128*128
julia&gt; imresize(img, (128, 128)) # 128*128
julia&gt; imresize(img, (1:128, 1:128)) # 128*128
julia&gt; imresize(img, (1:128, )) # 128*256
julia&gt; imresize(img, 128) # 128*256
julia&gt; imresize(img, ratio = 0.5) # 128*128

σ = map((o,n)-&gt;0.75*o/n, size(img), sz)
kern = KernelFactors.gaussian(σ)   # from ImageFiltering
imgr = imresize(imfilter(img, kern, NA()), sz)</code></pre><p>See also <a href="#ImageTransformations.restrict-Tuple{AbstractArray,Tuple{}}"><code>restrict</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageTransformations.imrotate-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Real,Vararg{Any,N} where N}} where T" href="#ImageTransformations.imrotate-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Real,Vararg{Any,N} where N}} where T"><code>ImageTransformations.imrotate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">imrotate(img, θ, [indices], [degree = Linear()], [fill = NaN]) -&gt; imgr</code></pre><p>Rotate image <code>img</code> by <code>θ</code>∈[0,2π) in a clockwise direction around its center point. To rotate the image counterclockwise, specify a negative value for angle.</p><p>By default, rotated image <code>imgr</code> will not be cropped. Bilinear interpolation will be used and values outside the image are filled with <code>NaN</code> if possible, otherwise with <code>0</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; img = testimage(&quot;cameraman&quot;)

# rotate with bilinear interpolation but without cropping 
julia&gt; imrotate(img, π/4)

# rotate with bilinear interpolation and with cropping
julia&gt; imrotate(img, π/4, axes(img))

# rotate with nearest interpolation but without cropping
julia&gt; imrotate(img, π/4, Constant())</code></pre><p>See also <a href="#ImageTransformations.warp-Union{Tuple{T}, Tuple{AbstractExtrapolation{T,N,ITPT,IT} where IT where ITPT where N,Any}, Tuple{AbstractExtrapolation{T,N,ITPT,IT} where IT where ITPT where N,Any,Tuple}} where T"><code>warp</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageTransformations.invwarpedview-Tuple{AbstractArray,CoordinateTransformations.Transformation,Vararg{Any,N} where N}" href="#ImageTransformations.invwarpedview-Tuple{AbstractArray,CoordinateTransformations.Transformation,Vararg{Any,N} where N}"><code>ImageTransformations.invwarpedview</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">invwarpedview(img, tinv, [indices], [degree = Linear()], [fill = NaN]) -&gt; wv</code></pre><p>Create a view of <code>img</code> that lazily transforms any given index <code>I</code> passed to <code>wv[I]</code> to correspond to <code>img[inv(tinv)(I)]</code>. While technically this approach is known as backward mode warping, note that <code>InvWarpedView</code> is created by supplying the forward transformation. The given transformation <code>tinv</code> must accept a <code>SVector</code> as input and support <code>inv(tinv)</code>. A useful package to create a wide variety of such transformations is <a href="https://github.com/FugroRoames/CoordinateTransformations.jl">CoordinateTransformations.jl</a>.</p><p>When invoking <code>wv[I]</code>, values for <code>img</code> must be reconstructed at arbitrary locations <code>inv(tinv)(I)</code>. <code>InvWarpedView</code> serves as a wrapper around <a href="#ImageTransformations.WarpedView"><code>WarpedView</code></a> which takes care of interpolation and extrapolation. The parameters <code>degree</code> and <code>fill</code> can be used to specify the b-spline degree and the extrapolation scheme respectively.</p><p>The optional parameter <code>indices</code> can be used to specify the domain of the resulting <code>wv</code>. By default the indices are computed in such a way that <code>wv</code> contains all the original pixels in <code>img</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageTransformations.restrict-Tuple{AbstractArray,Tuple{}}" href="#ImageTransformations.restrict-Tuple{AbstractArray,Tuple{}}"><code>ImageTransformations.restrict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">restrict(img[, region]) -&gt; imgr</code></pre><p>Reduce the size of <code>img</code> by two-fold along the dimensions listed in <code>region</code>, or all spatial coordinates if <code>region</code> is not specified.  It anti-aliases the image as it goes, so is better than a naive summation over 2x2 blocks.</p><p>See also <a href="#ImageTransformations.imresize-Union{Tuple{T}, Tuple{AbstractArray{T,0},Tuple{}}} where T"><code>imresize</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageTransformations.warp-Union{Tuple{T}, Tuple{AbstractExtrapolation{T,N,ITPT,IT} where IT where ITPT where N,Any}, Tuple{AbstractExtrapolation{T,N,ITPT,IT} where IT where ITPT where N,Any,Tuple}} where T" href="#ImageTransformations.warp-Union{Tuple{T}, Tuple{AbstractExtrapolation{T,N,ITPT,IT} where IT where ITPT where N,Any}, Tuple{AbstractExtrapolation{T,N,ITPT,IT} where IT where ITPT where N,Any,Tuple}} where T"><code>ImageTransformations.warp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">warp(img, tform, [indices], [degree = Linear()], [fill = NaN]) -&gt; imgw</code></pre><p>Transform the coordinates of <code>img</code>, returning a new <code>imgw</code> satisfying <code>imgw[I] = img[tform(I)]</code>. This approach is known as backward mode warping. The transformation <code>tform</code> must accept a <code>SVector</code> as input. A useful package to create a wide variety of such transformations is <a href="https://github.com/FugroRoames/CoordinateTransformations.jl">CoordinateTransformations.jl</a>.</p><p><strong>Reconstruction scheme</strong></p><p>During warping, values for <code>img</code> must be reconstructed at arbitrary locations <code>tform(I)</code> which do not lie on to the lattice of pixels. How this reconstruction is done depends on the type of <code>img</code> and the optional parameter <code>degree</code>.</p><p>When <code>img</code> is a plain array, then on-grid b-spline interpolation will be used. It is possible to configure what degree of b-spline to use with the parameter <code>degree</code>. For example one can use <code>degree = Linear()</code> for linear interpolation, <code>degree = Constant()</code> for nearest neighbor interpolation, or <code>degree = Quadratic(Flat())</code> for quadratic interpolation.</p><p>In the case <code>tform(I)</code> maps to indices outside the original <code>img</code>, those locations are set to a value <code>fill</code> (which defaults to <code>NaN</code> if the element type supports it, and <code>0</code> otherwise). The parameter <code>fill</code> also accepts extrapolation schemes, such as <code>Flat()</code>, <code>Periodic()</code> or <code>Reflect()</code>.</p><p>For more control over the reconstruction scheme –- and how beyond-the-edge points are handled –- pass <code>img</code> as an <code>AbstractInterpolation</code> or <code>AbstractExtrapolation</code> from <a href="https://github.com/JuliaMath/Interpolations.jl">Interpolations.jl</a>.</p><p><strong>The meaning of the coordinates</strong></p><p>The output array <code>imgw</code> has indices that would result from applying <code>inv(tform)</code> to the indices of <code>img</code>. This can be very handy for keeping track of how pixels in <code>imgw</code> line up with pixels in <code>img</code>.</p><p>If you just want a plain array, you can &quot;strip&quot; the custom indices with <code>parent(imgw)</code>.</p><p><strong>Examples: a 2d rotation (see JuliaImages documentation for pictures)</strong></p><pre><code class="language-none">julia&gt; using Images, CoordinateTransformations, TestImages, OffsetArrays

julia&gt; img = testimage(&quot;lighthouse&quot;);

julia&gt; axes(img)
(Base.OneTo(512),Base.OneTo(768))

# Rotate around the center of `img`
julia&gt; tfm = recenter(RotMatrix(-pi/4), center(img))
AffineMap([0.707107 0.707107; -0.707107 0.707107], [-196.755,293.99])

julia&gt; imgw = warp(img, tfm);

julia&gt; axes(imgw)
(-196:709,-68:837)

# Alternatively, specify the origin in the image itself
julia&gt; img0 = OffsetArray(img, -30:481, -384:383);  # origin near top of image

julia&gt; rot = LinearMap(RotMatrix(-pi/4))
LinearMap([0.707107 -0.707107; 0.707107 0.707107])

julia&gt; imgw = warp(img0, rot);

julia&gt; axes(imgw)
(-293:612,-293:611)

julia&gt; imgr = parent(imgw);

julia&gt; axes(imgr)
(Base.OneTo(906),Base.OneTo(905))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageTransformations.warpedview-Tuple{AbstractArray,CoordinateTransformations.Transformation,Vararg{Any,N} where N}" href="#ImageTransformations.warpedview-Tuple{AbstractArray,CoordinateTransformations.Transformation,Vararg{Any,N} where N}"><code>ImageTransformations.warpedview</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">warpedview(img, tform, [indices], [degree = Linear()], [fill = NaN]) -&gt; wv</code></pre><p>Create a view of <code>img</code> that lazily transforms any given index <code>I</code> passed to <code>wv[I]</code> to correspond to <code>img[tform(I)]</code>. This approach is known as backward mode warping. The given transformation <code>tform</code> must accept a <code>SVector</code> as input. A useful package to create a wide variety of such transformations is <a href="https://github.com/FugroRoames/CoordinateTransformations.jl">CoordinateTransformations.jl</a>.</p><p>When invoking <code>wv[I]</code>, values for <code>img</code> must be reconstructed at arbitrary locations <code>tform(I)</code> which do not lie on to the lattice of pixels. How this reconstruction is done depends on the type of <code>img</code> and the optional parameter <code>degree</code>. When <code>img</code> is a plain array, then on-grid b-spline interpolation will be used, where the pixel of <code>img</code> will serve as the coeficients. It is possible to configure what degree of b-spline to use with the parameter <code>degree</code>. The two possible values are <code>degree = Linear()</code> for linear interpolation, or <code>degree = Constant()</code> for nearest neighbor interpolation.</p><p>In the case <code>tform(I)</code> maps to indices outside the domain of <code>img</code>, those locations are set to a value <code>fill</code> (which defaults to <code>NaN</code> if the element type supports it, and <code>0</code> otherwise). Additionally, the parameter <code>fill</code> also accepts extrapolation schemes, such as <code>Flat()</code>, <code>Periodic()</code> or <code>Reflect()</code>.</p><p>The optional parameter <code>indices</code> can be used to specify the domain of the resulting <code>WarpedView</code>. By default the indices are computed in such a way that the resulting <code>WarpedView</code> contains all the original pixels in <code>img</code>. To do this <code>inv(tform)</code> has to be computed. If the given transformation <code>tform</code> does not support <code>inv</code>, then the parameter <code>indices</code> has to be specified manually.</p><p><code>warpedview</code> is essentially a non-coping, lazy version of <a href="#ImageTransformations.warp-Union{Tuple{T}, Tuple{AbstractExtrapolation{T,N,ITPT,IT} where IT where ITPT where N,Any}, Tuple{AbstractExtrapolation{T,N,ITPT,IT} where IT where ITPT where N,Any,Tuple}} where T"><code>warp</code></a>. As such, the two functions share the same interface, with one important difference. <code>warpedview</code> will insist that the resulting <code>WarpedView</code> will be a view of <code>img</code> (i.e. <code>parent(warpedview(img, ...)) === img</code>). Consequently, <code>warpedview</code> restricts the parameter <code>degree</code> to be either <code>Linear()</code> or <code>Constant()</code>.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
